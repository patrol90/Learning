<html>
<head>
<title>ОБЪЕКТНО-ОРИЕНТИРОВАННОЕ ПРОГРАММИРОВАНИЕ И ПРОЕКТИРОВАНИЕ</title>
<link href=style.css rel=stylesheet type=text/css>
</head>
<body>
<P>   
<center>

<div class="title">КОНСПЕКТЫ ЛЕКЦИЙ ПО КУРСУ <br>
&quot;ОБЪЕКТНО-ОРИЕНТИРОВАННОЕ<br>
ПРОГРАММИРОВАНИЕ И ПРОЕКТИРОВАНИЕ&quot;</div>
<P>
Часть 1 (семестр 5)
     <p>
      <hr width="100%" SIZE="1">
      <a name="REF_1_C"></a>СОДЕРЖАНИЕ</div>
      </center>
<a href="ood_lk.htm">Чаcть 2</a>

      <dl>
        <p>
        <div align="justify">
          <dt><a href="#REF_1_0">ВВЕДЕНИЕ</a>
        </div>
        <p>&nbsp;</p>
        <dt><a href="#REF_1_1">1.
            РАЗВИТИЕ ЭЛЕМЕНТОВ ЯЗЫКА С В ЯЗЫКЕ С++</a>
        <p>
        <dd>1.1. <a title="Обзор расширений языка C в языке C++" href="#REF_1_1_1">Соотношение
          языков C и C++</a>
        <dd>1.2. <a title="Виды комментариев в языке C++" href="#REF_1_1_2">Комментарии
          в C++</a>
        <dd>1.3. <a title="Правила записи идентификаторов объектов в языке C++" href="#REF_1_1_3">Идентификаторы
          объектов</a>
        <dd>1.4. <a href="#REF_1_1_4">Область
          действия (видимости) объекта</a>
        <dd>1.5. <a href="#REF_1_1_5">Атрибуты
          типа const и volatile</a>
        <dd>1.6. <a href="#REF_1_1_6">Ссылки
          (обращение по адресу)</a>
        <dd>1.7. <a href="#REF_1_1_7">Набор
          и приоритет операций в языке С++</a>
        <dd>1.8. <a href="#REF_1_1_8">Операция
          преобразования типа</a>
        <dd>1.9. <a href="#REF_1_1_9">Обьявление
          и переопределение функций</a>
        <dd>1.10. <a href="#REF_1_1_10">Установка
          умалчиваемых значений параметров
          функций</a>
        <dd>1.11. <a href="#REF_1_1_11">Функции
          с переменным числом параметров</a>
        <dd>1.12. <a href="#REF_1_1_12">Встраиваемые
          функции</a>
        <dd>1.13. <a href="#REF_1_1_13">Управление
          размещением объектов в памяти</a>
        <dd>1.14. <a href="#REF_1_1_14">Пространства имен</a>
          <p>
        <dt><a href="#REF_1_2">2. КЛАССЫ
            ОБЪЕКТОВ</a>
        <p>
        <dd>2.1. <a href="#REF_1_2_1">Понятие
          класса объектов</a>
        <dd>2.2. <a href="#REF_1_2_2">Функции-элементы</a>
        <dd>2.3. <a href="#REF_1_2_3">Статические
          элементы класса</a>
        <dd>2.4. <a href="#REF_1_2_4">Дружественные
          функции класса</a>
        <dd>2.5. <a href="#REF_1_2_5">Конструкторы
          и деструкторы объектов</a>
        <dd>2.6. <a href="#REF_1_2_6">Конструкторы
          вложенных классов</a>
        <dd>2.7. <a href="#REF_1_2_7">Конструирование
          массивов объектов</a>
        <dd>2.8. <a href="#REF_1_2_8">Конструирование
          статических объектов</a>
          <p>
        <dt><a href="#REF_1_3">3.
            ОПРЕДЕЛЕНИЕ ОПЕРАЦИЙ НАД ОБЪЕКТАМИ
            КЛАССОВ</a>
        <p>
        <dd>3.1. <a href="#REF_1_3_1">Схема
          определения операций над объектами</a>
        <dd>3.2. <a href="#REF_1_3_2">Особенности
          определения операций</a>
        <dd>3.3. <a href="#REF_1_3_3">Способы
          согласования типов</a>
        <dd>3.4. <a href="#REF_1_3_4">Особенности
          использования ссылочных типов</a>
        <dd>3.5. <a href="#REF_1_3_5">Особенности
          операций присваивания и
          инициализации</a>
        <dd>3.6. <a href="#REF_1_3_6">Пример
          переопределения операции индексации</a>
        <dd>3.7. <a href="#REF_1_3_7">Пример
          переопределения операции вызова
          функции</a>
          <p>
        <dt><a href="#REF_1_4">4.
            ПРОИЗВОДНЫЕ КЛАССЫ</a>
        <p>
        <dd>4.1. <a href="#REF_1_4_1">Понятие
          производного класса</a>
        <dd>4.2. <a href="#REF_1_4_2">Виртуальные
          базовые классы</a>
        <dd>4.3. <a href="#REF_1_4_3">Конструкторы
          и деструкторы производных классов</a>
        <dd>4.4. <a href="#REF_1_4_4">Динамическая
          взаимосвязь компонент производного и
          базовых классов</a>
        <dd>4.5. <a href="#REF_1_4_5">Виртуальные
          функции</a>
        <dd>4.6. <a href="#REF_1_4_6">Понятие
          абстрактного класса</a>
          <p>
        <dt><a href="#REF_1_5">5.
            ОБЪЕКТНО-ОРИЕНТИРОВАННЫЙ ВВОД-ВЫВОД
            НА ЯЗЫКЕ С++</a>
        <p>
        <dd>5.1. <a href="#REF_1_5_1">Классы
          и потоки ввода-вывода</a>
        <dd>5.2. <a href="#REF_1_5_2">Ввод-вывод
          данных базовых типов</a>
        <dd>5.3. <a href="#REF_1_5_3">Ввод-вывод
          объектов определенных пользователем
          классов</a>
        <dd>5.4. <a href="#REF_1_5_4">Контроль
          исключительных ситуаций ввода-вывода</a>
        <dd>5.5. <a href="#REF_1_5_5">Форматный
          ввод-вывод</a>
        <dd>5.6. <a href="#REF_1_5_6">Бесформатный
          ввод-вывод</a>
        <dd>5.7. <a href="#REF_1_5_7">Управление
          позиционированием потока</a>
        <dd>5.8. <a href="#REF_1_5_8">Связанные
          потоки</a>
        <dd>5.9. <a href="#REF_1_5_9">Создание
          и организация взаимодействия потоков</a>
        <dd>5.10. <a href="#REF_1_5_10">Файловый
          ввод-вывод</a>
        <dd>5.11. <a href="#REF_1_5_11">Строко-ориентированный
          ввод-вывод</a>
<p>
        <DT><A HREF="#REF_2_1">6. ТЕХНОЛОГИЧЕСКИЕ АСПЕКТЫ ОБЪЕКТНО-ОРИЕНТИРОВАННОГО
 ПРОГРАММИРОВАНИЯ НА ЯЗЫКЕ С++</A>
       <P>
       <dd>6.1. <A HREF="#REF_2_1_1">Обзор операционных особенностей объектов класса</A>
       <DD>6.2. <A HREF="#REF_2_1_2">Особенности динамического управления памятью</A>
       <DD>6.3. <A HREF="#REF_2_1_3">Использование статических элементов класса</A>
       <DD>6.4. <A HREF="#REF_2_1_4">Статическое и динамическое связывание</A>
       <DD>6.5. <A HREF="#REF_2_1_5">Виртуальные деструкторы</A>
       <DD>6.6. <A HREF="#REF_2_1_6">Динамические особенности операторов присваивания</A>
       <P>
       <DT><A HREF="#REF_2_2">7. ШАБЛОНЫ В ЯЗЫКЕ С++</A>
       <P>
       <DD>7.1. <A HREF="#REF_2_2_1">Назначение и виды шаблонов</A>
       <DD>7.2. <A HREF="#REF_2_2_2">Определение и использование шаблонов функций</A>
       <DD>7.3. <A HREF="#REF_2_2_3">Переопределение шаблонов и специализация функций</A>
       <DD>7.4. <A HREF="#REF_2_2_4">Определение шаблонов классов</A> 
       <DD>7.5. <A HREF="#REF_2_2_5">Использование шаблонов классов</A>
       <DD>7.6. <A HREF="#REF_2_2_6">Специализация параметризованных классов</A>
       <DD>7.7. <A HREF="#REF_2_2_7">Характеристика шаблонов</A>
       <DD>7.8. <A HREF="#REF_2_2_8">Стандартная библиотека шаблонов</A>
       <P>
       <DT><A HREF="#REF_2_3">8. ОБРАБОТКА ИСКЛЮЧИТЕЛЬНЫХ СИТУАЦИЙ</A>
       <P>
       <DD>8.1. <A HREF="#REF_2_3_1">Схема обработки исключений в С++</A>
       <DD>8.2. <A HREF="#REF_2_3_2">Понятие структурного управления исключениями</A>
       <DD>8.3. <A HREF="#REF_2_3_3">Кадрированное управление исключениями</A>
       <DD>8.4. <A HREF="#REF_2_3_4">Завершающее управление исключениями</A>
       <DD>8.5. <A HREF="#REF_2_3_5">Иерархическое управление исключениями</A>
       <DD>8.6. <A HREF="#REF_2_3_6">Особенности порождения исключений в конструкторах и деструкторах</A>
       <DD>8.7. <A HREF="#REF_2_3_7">Спецификация исключений в функциях</A>
       <DD>8.8. <A HREF="#REF_2_3_8">Стандартные исключения</A>
       <P>
       <DT><A HREF="#REF_2_4">9. ДИНАМИЧЕСКАЯ ИДЕНТИФИКАЦИЯ И ПРИВЕДЕНИЕ ТИПА</A>
       <P>
       <DD>9.1. <A HREF="#REF_2_4_1">Динамическая идентификация типа</A>
       <DD>9.2. <A HREF="#REF_2_4_2">Обзор новых возможностей приведения типа</A> 
       <DD>9.3. <A HREF="#REF_2_4_3">Динамическое приведение типа</A> 
       <DD>9.4. <A HREF="#REF_2_4_4">Статическое приведение типа</A> 
       <DD>9.5. <A HREF="#REF_2_4_5">Преобразования типа с сохранением значений</A> 
       <P>
       <dt><a href="#REF_2_Z">ЗАКЛЮЧЕНИЕ</a>
       <P>
       <dt><a href="#REF_2_R">ЛИТЕРАТУРА</a></dt>
       <P>
       <dt><a href="sp_lk.htm">Приложение. Язык программирования C</a></dt>
       </div>
      </dl>
      <p>
      <p>
      <hr width="100%" SIZE="1">
      <p><a href="#REF_1_C">Начало</a>
<p>
      <div class="header"><a name="REF_1_0"></a>ВВЕДЕНИЕ</div>
      <p>Среди многих современных
      языков программирования язык С++
      выделяется ориентацией на обьектно-ориентированное
      программирование. Обьектно-ориентированное
      программирование - технология создания
      новых типов данных, наследующих
      некоторые черты ранее созданных типов
      данных. Определяемые пользователем типы
      данных в языке С++ называют классами.
      <ul>
        <p>Технология обьектно-ориентированного
        программирования явилась результатом
        эволюции методов программирования в
        направлении ярко выраженного
        конструктивного использования
        принципов структуризации, модульности
        и абстракции.</p>
        <p>Ключевые понятия систем
        обьектно-ориентированного
        программирования:</p>
        <li>
          <p>пакетирование (encapsulation) -
          связывание в единое целое обьектов
          некоторых существующих типов и
          функций доступа к ним с целью
          определения обьектов нового типа;
        <li>
          <p>наследование (inheritance) -
          использование элементов данных и
          функций ранее определенных обьектов
          при образовании иерархии производных
          обьектов;
        <li>
          <p>полиморфизм (polymorphizm) -
          возможность ассоциации некоторого
          имени с множеством уникальных для
          каждого уровня иерархии производных
          обьектов понятий.</li>
      </ul>
      <p>В процедурном
      программировании известны два типа
      модулей: функция - входные параметры и
      результат - старый способ надежного
      программирования; файл - совокупность
      функций и глобальных переменных, где
      глобальные переменные определяют
      контекст состояния процесса
      использования функций.
      <p>Пример использования модулей
      - функций:
<pre><div class="code"> 
/* ************** Файл my_show.h **************** */ 
#include &lt;stdio.h&gt;
#include &lt;window.h&gt;
#include &lt;conio.h&gt;
#include &lt;time.h&gt;

/* Отображение текущего времени */ 
      void show_time_xy(int x, int y) { 
      struct time t;
      gettime(&t);
      gotoxy(x,y);
      printf(&quot;The current time is: %2d:%02d:%02d.%02d\n&quot;, 
                   t.ti_hour, t.ti_min, t.ti_sec,t.ti_hund); 
} 

/* ************** Файл my_show.cpp **************** */ 
#include &lt;my_show.h&gt;

      void main() {
      show_time_xy(10,10);
      show_time_xy(11,11);
} </div></pre>
      <p>Достоинство - описание
      функции и известные значения аргументов
      достаточны для прогнозирования
      поведения (исходный текст достаточен
      для объяснения работы программы).
      <p>Недостаток - каждая операция
      вызова требует полного представления
      задачи списком параметров, разработчик
      должен владеть алгоритмом решения всей
      задачи.
      <p>Пример использования модулей
      - файлов:
<pre><div class="code">
/* ************** Файл my_time.с **************** */ 
/* Подсистема отображения текущего времени */ 
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#include &lt;conio.h&gt;
#include &quot;my_show.h&quot;

static int x=10, y=10;

   void _show_time() { 
    show_time_xy(x,y); 
   } 
   
   void set_time(int new_x,  int new_y) {
     x=new_x; y=new_y;  
   }
   
   void get_time(int *px,  int *py) {
     *px=x; *py=y;  
   }
}

 /* Использование подсистемы отображения файлов */ 
#include &quot;my_time.c&quot;
 void main() { 
  show_time(); 
   int x, y;
   get_time_xy(&x,&y);
   x++, y++; 
   set_time_xy(x, y); 
   show_time(); 
} 
</div></pre>
      <p>Достоинства - сокращение
      записи и реализации операции вызова,
      работа с понятием контекста, разделение
      труда программистов.
      <p>Проблемы - диагностика ошибок
      требует анализа всех глобальных
      переменных, а также слежения за
      операциями вызова функций, разработчик
      должен заниматься синхронизацией
      вызова функций (исходный текст
      недостаточен для объяснения работы
      программы, требуется трассировка).</p>

<p>Реализация пакетирования в С++: 
<pre><div class="code"> 

/* ************** Файл my_time.h **************** */

#include &lt;stdio.h&gt;
#include &lt;window.h&gt;
#include &lt;conio.h&gt;
#include &lt;time.h&gt;
#include &quot;my_show.h&quot;

struct my_time { // Один из видов класса в C++ 
 int x,y; // Элементы данных

 void show_time() { // Функция - элемент класса 
  show_time_xy(x,y);
 }

 void set_time_xy(int new_x, int new_y) { // Функция - элемент класса
  x=new_x; y=new_y;
 }

 void get_time_xy(int *px, int *py) { // Функция - элемент класса
  *px=x;  *py=y;
 }

 my_time() { // Функция - элемент класса (конструктор)
  x=y=0;
 }
};  // Определен новый тип данных (класс) !!!
</div></pre>


<pre><div class="code">
/* ************** Файл my_time.cpp **************** */
#include "my_time.h"

void main() {
 my_time t; // Декларация объекта класса. Память выделяется автоматически...
 t.show_time(); // Вызов функции - элемента класса... 
 t.set_time_xy(10,10);
 t.show_time();
 int x, y;
 t.get_time_xy(&x,&y);
 x++, y++;
 t.set_time_xy(x,y);
 t.show_time();
}
</div></pre>
<p>Данные и функции описаны в одной языковой конструкции, компилятор может контролировать их использование. 
<p>Реализация наследования в С++: 
<pre><div class="code"> 

/* ************** Файл your_time.h **************** */

#include "my_time.h"

/* Класс отображения времени с сохранением текущей позиции */

struct your_time: public my_time {
 void safe_show_time() {
  int x=wherex();
  int y=wherey();
  show_time();
  gotoxy(x,y);
 }
};

/* ************** Файл your_time.cpp **************** */
#include "your_time.h"

void main() {
 your_time t;
 t.show_time();  // Старые функции доступны
 t.set_time_xy(10,10);
 t.safe_show_time(); // Вызов новой функции
 int x, y;
 t.get_time_xy(&x,&y);
 x++, y++;
 t.set_time_xy(x,y);
 t.show_time();
}
</div></pre>
<p>Ранее написанный исходный текст остается без изменений, старые версии работают, программу можно развивать далее в сторону расширения. 
<p>Реализация полиморфизма в С++: 

<pre><div class="code"> 

/* ************** Файл your_time.cpp **************** */
#include "your_time.h"

// Организация периодического отображения времени

struct common_show_time: public your_time {
  virtual // Признак будущих уточнений функции  
   void common_show() { // Отображение текущего времени
    safe_show_time();
   }
  
void time_at_line(int n) { // Периодическое отображение времени
   for (int i=0; i < n; i++)
    common_show();
  }
};

// Привязка отображения времени к реальным часам

struct show_real_time: public common_show_time {
  void common_show() {  // Имя common_show уже использовалось...
   safe_show_time();
   sleep(1); // Задержка на 1 сек
  }
};

void main() {
 show_real_time t;
 t.time_at_line();
 common_show_time v;
 v.time_at_line(5);
}
</div></pre> 
<p>Ранее написанный исходный текст остается без изменений, программу можно развивать далее в сторону уточнения и детализации.
  <p>В наибольшей степени
      технология обьектно-ориентированного
      программирования проявляет свои
      преимущества при создании,
      сопровождении и развитии больших (с
      размером исходного текста порядка
      десятка тысяч операторов) программных
      комплексов. Достигаемая с ее
      применением концептуальная стройность
      и прозрачность программ хорошо
      согласуется с человеческим фактором, а
      накладные расходы на освоение и
      поддержку составляют незначительную
      долю.
      <p>
      <hr width="100%" size="3">
      <p><a href="#REF_1_C">Начало</a>
<p>
      <div class="header"><a name="REF_1_1"></a>1. РАЗВИТИЕ ЭЛЕМЕНТОВ
      ЯЗЫКА С В ЯЗЫКЕ С++</div>
      <p>
      <div class="header"><a name="REF_1_1_1"></a>1.1. Соотношение языков C и
      C++<br>
      </div>
      <p>Язык C++ в современном виде [1,9]
      сформировался к 1983 г. на основе языка C с
      использованием наиболее полезных
      концепций языков SIMULA-67 и ALGOL-68.
      <p>Язык C++ ориентирован на
      поддержку технологии объектно-ориентированного
      программирования. Суть этой технологии
      состоит в первом приближении в
      следующем:
      <ul>
        <li>
          <p>формирование при решении
          прикладных задач понятия классов
          операционных объектов;</p>
        <li>
          <p>описание типов данных,
          характеризующих объекты класса и
          операции над объектами;</p>
        <li>
          <p>программирование
          алгоритмов решения задачи в терминах
          операций над базовыми и определенными
          пользователем объектами в рамках
          традиционных операционных
          возможностей языка C.</p>
        </li>
      </ul>
      <p>Язык С++ не содержит средств
      обработки прерываний (обработка
      исключительных ситуаций сейчас
      обсуждается [9]), операторов
      параллельного программирования, ввода-вывода.
      Подобные средства реализуются
      библиотечными функциями. Вместе с тем,
      поддержка понятия определяемого
      пользователем класса объектов ставит
      язык С++ наравне с высокоуровневыми
      языками программирования.
      <p>Язык С++ полностью совместим с
      языком С. Формально можно считать язык С
      подмножеством языка С++. Программы на
      языке С практически без изменений
      пригодны для обработки системами
      программирования С++, но не наоборот.
      <ul>
        <p>Перечень существенных
        лексических расширений стандартного
        языка С:</p>
        <li>
          <p>возможность <a href="#REF_1_2">определения
          новых типов операционных объектов(классов)</a>
          посредством определения структур
          данных представления объекта и набора
          функций манипулирования объектами,
          причем данные определения объекта
          могут быть скрытыми;
        <li>
          <p>введение контроля набора и
          типов аргументов функций,
          преобразования типов и задания <a href="#REF_1_1_10">умалчиваемых
          значений аргументов</a>;
        <li>
          <p><a href="#REF_1_1_9">переопределение
          функций</a>;
        <li>
          <p><a href="#REF_1_3">переопределение
          операций</a>;
        <li>
          <p>возможность <a href="#REF_1_1_12">встраивания
          тела функции</a> в точку ее вызова
          подобно эквивалентному
          макрорасширению;
        <li>
          <p><a href="#REF_1_1_5">определение
          объектов-констант</a>;
        <li>
          <p>определение объектов типа <a href="#REF_1_1_6">ссылок</a>;
        <li>
          <p>управление распределением
          памяти <a href="#REF_1_1_13">операторами
          new и delete</a>.</li>
      </ul>
      <p>Далее в настоящем разделе
      последовательно рассматриваются
      элементы языка C++, являющиеся
      расширением подобных в языке C.
      <p><center>
      <div class="header"><a name="REF_1_1_2"></a>1.2. Комментарии в
      C++<br>
      </div>
      </center>
      <p>Комментарии - элемент
      пояснения аспектов реализации
      программы, которые не могут быть
      непосредственно отражены операторами
      языка программирования.</p>
      <ul>
        <p>Язык C++ допускает два способа
        записи комментариев в исходном тексте
        программы:</p>
        <li>
          <p>традиционное для языка С
          использование пар символов /* и */ для
          обрамления игнорируемой компилятором
          последовательности символов (по
          умолчанию комментарии такого типа не
          могут быть вложенными);</p>
        <li>
          <p>однострочные комментарии,
          начинающиеся в любом месте строки с
          пары символов // и заканчивающиеся в
          конце строки.</p>
        </li>
      </ul>
      <p>Примеры записи комментариев в
      стиле языка С:
      <pre><div class="code">
   /* Декларация глобальных объектов */
   int status; /* Состояние процесса */
   /* ПРОЦЕДУРА ОБРАБОТКИ ОШИБОК */
</div></pre> 
Примеры записи однострочных комментариев:
<pre><div class="code">
   // Декларация глобальных объектов
   int status; // Состояние процесса
   // ПРОЦЕДУРА ОБРАБОТКИ ОШИБОК</div></pre>
      <p>Первый способ удобен для
      написания многострочных комментариев и
      быстрой корректировки исходного текста
      на этапе отладки,а второй способ
      предпочтительнее для коротких
      комментариев.</p>
      <p>Пара символов // может
      применяться для комментирования текста
      с символами /* и */ и, наоборот, символы /* и
      */ могут подавлять действие символов //.</p>
      <div class="header"><a name="REF_1_1_3"></a>1.3.
      Идентификаторы объектов<br>
      </div>
      <p>Идентификаторы (имена)
      объектов в программах на языках C и C++
      могут состоять их практически любого
      числа символов из множества {a...z, A...Z,
      0...9,_}, первый из которых должен
      принадлежать множеству {a...z, A...Z,_} (здесь
      фигурные скобки заключают элементы
      множества). Идентификаторы не должны
      совпадать с ключевыми словами языка C++.
      Набор ключевых слов определяется
      реализацией транслятора.
      <p>Список ключевых слов языка С++:
      <div align="justify">
        <pre> asm     continue     float     new        sizeof    typedef 
 auto    default      for       operator   static    void
 break   delete       friend    private    struct    volatile 
 case    do           goto      protected  switch    virtual
 catch   double       if        public     template  unsigned     
 char    else         inline    register   this      union
 class   enum         int       return     throw     while  
 const   extern       long      short      try     
</pre>
      </div>
      <div class="header"><a name="REF_1_1_4"></a>1.4. Область
      действия (видимости) объекта<br>
      </div>
      <p>Имя любого объекта программы
      на языке C имеет атрибут локальной или
      глобальной области действия описания
      объекта. Такой атрибут определяется
      неявно местоположением оператора
      описания объекта. Рассмотрим фрагмент
      исходного текста программы на языке С:
       <pre><div class="code">     
 
  int error_n=0; // глобальная переменная
   
  void f1() { 
      int x; // локальная переменная 
      // ... 
   }
      
   struct complex { // глобальное описание типа данных 
      float re,im; 
   };
     
   void f2(int x) { 
      int y; 
      complex z; // локальная переменная типа struct complex 
      // ... 
      if (!scanf(&quot; %d&quot;,&amp;y))
         error_n++; // изменение глобальной переменной
      z.re=(float)y, z.im=0; 
      // ... 
   }</div></pre>
      <p>Можно утверждать, что
      границей разделения областей действия
      имен объектов в языке C является блок
      определения функции. Имена локальных
      объектов, описанных в функции до первого
      исполнимого оператора, действуют в
      пределах тела функции. Локальными
      являются и аргументы функции. Имена
      глобальных объектов, описанных вне
      функции, действуют от точки описания до
      конца файла исходного текста программы.
      <p>В языке C++ границей разделения
      областей действия имен является любой
      операторный блок, ограниченный
      символами фигурных скобок '{' и '}'. Имена
      объектов, определенные вне блока,
      остаются в блоке доступными, но любое
      ранее определенное имя можно
      переопределить для ссылки на другой
      объект. После выхода из блока
      переопределенное имя вновь обретает
      свой прежний смысл. Другими словами,
      локальное имя объекта скрывает старое
      определение объекта и, по существу,
      образуется иерархия локальных областей
      действия.
        <pre><div class="code">
   // ПРИМЕРЫ СКРЫТИЯ ИМЕН ОБЪЕКТОВ
   int x; // глобальное имя x
   
   void f() { 
      int x; // локальное имя x скрывает глобальное имя x 
      x = 1; // присваивание значения локальному x 
      { 
          int x; // скрытие первого локального имени x 
          x = 2; // присваивание значения второму локальному x 
      } 
      x = 3; // присваивание значения первому локальному x 
   }
   int* p=&amp;x; // определение адреса глобального x
</div></pre>
      <p>Скрытие имен удобно и
      практически неизбежно при написании
      больших программ. Однако при чтении
      текста программы можно не заметить, что
      некоторое имя скрыто, а возникающие
      вследствие этого ошибки очень трудно
      обнаружить. Скрытие имен рекомендуется
      минимизировать. Очевидно, что
      использование для общих переменных во
      вложенных блоках коротких и
      невыразительных имен вроде i или x
      провоцирует будущие неприятности.
      Возможность использования скрытого
      локального имени язык С++ не
      предоставляет, но скрытое <strong>глобальное</strong>
      имя становится доступным посредством
      применения унарной операции привязки
      имени, обозначаемой парой символов
      &quot;::&quot; (часто такую операцию называют
      операцией разрешения видимости).
        <pre><div class="code">
   // ПРИМЕР ИСПОЛЬЗОВАНИЯ ОПЕРАЦИИ РАЗРЕШЕНИЯ ВИДИМОСТИ

   int x; // глобальная переменная x
 
  void f() { 
      int x = 1; // скрытие глобальной переменной x 
      ::x = 2; // обращение к глобальной переменной x 
      // ... 
   }</div></pre>
      <p>Операция привязки имени
      обладает максимальным приоритетом.
      <p>Обсудим особенности языка С++,
      порождаемые расширением понятия
      области действия описания объектов.
      <p>Область видимости имени
      начинается в точке описания. Последнее
      означает, что имя можно использовать
      даже в выражении инициализации
      именуемого объекта. Например: <pre><div class="code">
   #include &lt;stdio.h&gt;
   double x=0;

   void main() { 
      printf(&quot;\n %d %ld&quot;,sizeof(x),x);
      static int x=sizeof(x); 
      { 
        printf(&quot;\n %d&quot;,x); 
        char x=sizeof(x);
        printf(&quot;\n %d&quot;,x); 
        { 
           printf(&quot;\n %d&quot;,x); 
           char x=x^x;
           printf(&quot;\n %d&quot;,x); 
        } 
      } 
    } </div></pre>
      <p>Результат работы программы:
      <pre>   8 0
   2
   1
   1
   0
</pre>
<a href="1_4.exe">Выполнить</a>
      <p>Стандарт языка C предписывает
      размещение операторов декларации
      локальных объектов в блоке функции до
      первого исполняемого оператора, а
      выражения инициализации объектов могут
      включать лишь операнды-константы.<br>
      <p>Язык С++ позволяет описывать
      объекты в любом месте исходного текста,
      но вложенность определений функций не
      допускается. Выражения инициализации
      нестатических объектов могут содержать
      любые операнды и операции.
      <p>Статические объекты языка C
      инициализируются только константными
      выражениями.
      <p>Очевидно, что одно и тоже имя в
      пределах блока практически может
      использоваться для обращения к двум
      различным объектам:
        <pre><div class="code">	
   int x=111;        // глобальное x

   void f() { 
      int y=(x+1)%13; // глобальное x 
      x&amp;=0x00ff;
      // ... 
      int x=222; // переопределение имени x 
      y=x; // локальное x 
   }</div></pre>
<p>Здесь переменная y
      инициализируется значением глобального
      x=111, а затем ему присваивается значение
      локальной переменной x=222. Подобный стиль
      именования переменных затрудняет
      чтение программы.
      <p>Параметры функции считаются
      описанными в самом внешнем блоке
      функции. Например:
      <pre><div class="code">     
   void f(int x) {
      int x;     // ошибка, обнаруживаемая транслятором
      // ...
   }</div></pre>
      <p>Здесь x определено ошибочно
      дважды в одной и той же области действия.
      <p>
      <div class="header"><a name="REF_1_1_5"></a>1.5. Атрибуты типа
      const и volatile</div>
      <p>
      <dl>
        <p>В языке С имеется следующие
        виды объектов-констант:</p>
        <ul>
          <li>
            <p>самоопределенные значения
            символьных констант, целых констант
            и констант с плавающей точкой;
          <li>
            <p>элементы перечислений;
          <li>
            <p>имена массивов (векторов);
          <li>
            <p>имена функций.</li>
        </ul>
      </dl>
      <p>В языке С++ ключевое слово const,
      добавленное к описанию объекта,
      объявляет этот объект константой, а не
      переменной:
        <pre><div class="code">     
   const int status = 145;          // скалярная константа
   const int values[] = {1,2,3,4};  // массив констант</div></pre>
      <p>По определению, константе
      ничего нельзя присвоить, поэтому она
      должна быть инициализирована. Атрибут
      const гарантирует, что значение объекта в
      области его видимости не изменится:
        <pre><div class="code">     
   status=123; // ошибка - переопределение значения константы
   status++;   // ошибка - изменение значения константы</div></pre>
      <p>Слово const модифицирует тип
      объекта в смысле использования объекта,
      но не меняет способ размещения объекта в
      памяти. Контроль за сохранностью
      объекта возлагается на компилятор.
      Атрибут const означает наличие запрета на
      возможные попытки изменения объекта.
      Такой атрибут может иметь, в частности, и
      возвращаемое значение функции:
        <pre><div class="code">     
   const char* item();</div></pre>
      <p>В этом случае становятся
      недопустимыми выражения вида
        <pre><div class="code">     
   item()[i]='=';
   (*item())++;
</div></pre>
      <p>Здесь объект-константа не
      является статически определенным.
      <p>Последний пример показывает
      возможность работы с объектами без
      имени, что характерно для <strong>косвенной</strong>
      адресации. В левой части операций
      присваивания может находиться только
      прямая или косвенная ссылка на область
      объекта-переменной (объекты такого вида
      иногда называют lvalue). Атрибут const
      предписывает невозможность
      использования объекта в левой части
      оператора присваивания. Описание
      указателей имеет отношение к двум
      объектам - собственно указателю и
      адресуемому им объекту. Префикс
      описания указателя const объявляет
      константой только адресуемый объект:
      <pre><div class="code">     
   const char* p = &quot;0123456789&quot;;  // указатель на константу
   p[2] = 'a';                    // ошибка
   p = &quot;ghjk&quot;;                    // изменение указателя</div></pre>
      <p>Описание константного
      указателя производится в постфиксной
      форме:
        <pre><div class="code">     
   char *const q = &quot;abcdef&quot;;  // константный указатель
   q[3] = '_';                // изменение поля данных
   q = &quot;ghjk&quot;;                // ошибка</div></pre>
      <p>При необходимости объявления
      константами обоих связанных с
      указателем объектов модификатор const
      применяется дважды:
        <pre><div class="code">     
   const char *const
   r=&quot;0123456789abcdef&quot;; // константный указатель на константу
   r[3] = 'a';           // ошибка
   r = &quot;ghjk&quot;;           // ошибка</div></pre>
      <p>Указателю на константу можно
      присваивать адрес переменной ввиду
      безобидности последствий. Однако
      присвоить адрес константы указателю на
      переменную нельзя, так как это позволило
      бы изменить значение объекта:
        <pre><div class="code">
   int x = 1;

   const c = 2; // Здесь атрибут типа в описании опущен, 
   const *p1 = &amp;c; // так как по умолчанию предполагается 
   const *p2 = &amp;x; // тип int
	
   int *p3 = &amp;c; // ошибка 
   *p3 = 7; // ошибка</div></pre>
      <p>Атрибут const полезно
      использовать для указателей -
      параметров функции с целью установки
      запрета на изменение функцией
      адресуемого объекта:
        <pre><div class="code">     
   char* strcpy(char* p, const char* q);
</div></pre>
      <p>(здесь библиотечная функция
      копирования строк не может менять
      исходную строку). Введение атрибута const
      наряду с автоматизацией контроля за
      использованием объектов позволяет
      компилятору иногда оптимизировать
      программу с учетом процедуры
      инициализации и механизмов доступа к
      памяти. Изменение значения константы
      возможно посредством использования
      операции приведения типа:
        <pre><div class="code">     
   const int x = 123;   // инициализация константы
   *(int *)&amp;x = 256;    // принудительное изменение константы</div></pre>
      <p>Таким образом, объекты-константы
      не защищены от модификации, но эта
      модификация явно определяется
      программистом. Атрибут volatile уведомляет
      компилятор о том, что объект может
      использоваться одновременно многими
      процессами. Например, если переменная
      count разделяется фоновой программой и
      программой обработки прерываний, то ее
      описание может иметь вид:
        <pre><div class="code">    
   volatile int count; // счетчик прерываний</div></pre>
     <p>Значения таких переменных для
      вычисления выражений каждый раз будут
      выбираться из памяти, а сохранение копий
      переменных в регистрах не
      предусматривается.</p>
      <p>Сказанное ранее относительно
      описания указателей применительно к
      модификатору const можно отнести и к
      модификатору volatile. Например, оператор
        <pre><div class="code"> 
   volatile int * volatile varptr;
</div></pre>
      <p>объявляет доступность для
      разделяемого доступа указатель и
      адресуемых им данные.
      <p>Модификатор mutable указывает,
      что элемент константного объекта может
      быть модифицирован.
      <p>
      <div class="header"><a name="REF_1_1_6"></a>1.6. Ссылки (обращение
      по адресу)</div>
      <p>Единственным способом связи
      параметров и аргументов функций в языке
      С является передача значений параметров,
      а не их адресов. Это делает невозможным
      изменение параметров в вызывающей
      функции. При необходимости изменения
      функцией некоторых объектов
      программист вынужден использовать
      указатели этих объектов. В языке С++
      введен дополнительный модификатор типа,
      обозначаемый символом '&amp;', позволяющий
      ссылаться на объект по его адресу без
      применения указателя.</p>
      <p>Если type - некоторый тип
      объекта, то модифицированный тип type&amp;
      называют <strong>ссылкой</strong> на объекты
      типа type.</p>
      <p>Ссылка представляет собою
      константный указатель, определяемый на
      этапе компиляции и построения
      загрузочного модуля программы. Отсюда
      следует, что никакие действия над
      ссылками не могут быть явно
      запрограммированы. Использование
      ссылок в выражениях означает обращение
      к адресуемым этими ссылками объектам.
      Можно выделить два вида применений
      ссылочных типов:
      <ul>
        <li>
          <p>организация передачи
          значений параметров и возвращаемых
          результатов функций;</p>
        <li>
          <p>создание псевдонимов
          переменных и констант.</p>
        </li>
      </ul>
      <p></p>
      <p>Рассмотрим вначале
      использование ссылок для построения
      функций, изменяющих значение параметра.
      <p>Пусть записан фрагмент
      программы:
        <pre><div class="code">     
   int x = 1;
   void incr(int&amp; a) { a++; }
   // ...
   incr(x);                           // x = 2
</div></pre>
      <p>Здесь параметр a объявлен
      ссылкой на объект типа int, а оператор a++
      предписывает инкремент этого объекта.</p>
      <p>Представим эту же программу
      без использования понятия ссылки. С
      точки зрения удобочитаемости исходного
      текста программы предпочтительнее явно
      возвращать значение функции:
        <pre><div class="code">   
   int x = 2;
   int next(int p) { return p+1; }
   // ...
   x = next(x);                       // x = 3
</div></pre>
      <p>Аналогичный результат
      достигается при использовании в
      качестве параметра указателя на
      изменяемую переменную:
        <pre><div class="code">    
   int x = 3;
   void inc(int* p) { (*p)++; }
   // ...
   inc(&amp;x);                           // x = 4
</div></pre>
      <p>Последние два варианта
      программы теряют свою
      привлекательность, если параметр
      функции является массивом или
      структурой.</p>
      <p>Ссылки удобно применять для
      определения функций, которые могут
      использоваться как в левой, так и в
      правой части операции присваивания.
      Такая возможность реализуется
      посредством возврата функцией
      результата ссылочного типа
      <p>Например, определим
      ассоциативный массив, где строка
      символов имеет некоторое
      ассоциированное с ней целое значение.
      Элемент массива представим структурой
      <pre><div class="code">
   struct pair {
      struct pair *next; // Слово struct здесь не обязательно
      char* name;
      int val;
   };
</div></pre>
      <p>Пусть поиск целочисленного
      значения по заданному значению строки
      осуществляется функцией value(), которая
      отыскивает подходящий элемент, а в
      случае неудачного поиска расширяет
      текущий массив. Пример реализации
      функции поиска:
      <pre><div class="code">
   static struct pair *head=NULL;
   int&amp; value(char* p) { 
      for (struct pair *x=head; x; x=x-&gt;next) 
          if (!strcmp(x-&gt;name,p)) return x-&gt;val; 
          x=malloc(sizeof(struct pair)); 
          x-&gt;next=head, head=x; 
          x-&gt;name=malloc(strlen(p)+1); 
          strcpy(x-&gt;name,p);
          x-&gt;val = 0; 
          return x-&gt;val; 
   }</div></pre>
      <p>Представим программу
      подсчета количества повторений
      введенных с клавиатуры слов. Введенной
      строке здесь соответствует количество
      повторений ее содержимого.
<pre><div class="code"> 	
   void main() {
      char buf[80]; // Буфер ввода строк
   /* Создание ассоциативного массива */
      while (fgets(buf,sizeof(buf),cin)) value(buf)++;
   /* Вывод ассоциативного массива */
      for (struct pair *x=head; x; x=x-&gt;next) 
	printf(&quot;\n %s: %d&quot;,x-&gt;name,x-&gt;val); 
   } </div></pre> 
      <p>Результатом работы программы
      для исходной последовательности {aa bb bb aa
      сс aa bb aa aa} является
      <pre>  
   сс: 1
   bb: 3
   aa: 5
</pre>
      <p>Рассмотренный пример можно
      реализовать на языке С с использованием,
      например, указателей:
        <pre><div class="code">   
   int *value(char *); // другое определение функции
   //...
   (*value(buf))++;    // инкремент количества повторений</div></pre>
      <p>Таким образом, использование
      ссылок позволяет отказаться от операций
      над указателями и повысить лаконичность
      записи исходного текста программы.
      Передача параметров и возвращаемых
      результатов функций по ссылке
      оказывается весьма эффективным приемом
      исключения копирования больших по
      размеру структур. Если вызываемая
      функция не меняет значение параметра,
      передаваемого по ссылке, то легко
      запретить его модификацию добавлением
      атрибута const, например:
       <pre><div class="code">   
   void f(const Large_Object&amp; nonmodified_parameter) { /* ... */}
</div></pre>
      <p>Рассмотрим применение ссылок
      для назначения псевдонима или другого
      имени объекта.
       <pre><div class="code">
   int  i = 1;
   int&amp; r = i;    // r и i ссылаются на одно поле типа int
   int  x = r;    // x=1
     
   r = 2; // i=2 
   r++; // Значение i увеличивается на 1
</div></pre>
      <p>Здесь оператор r++ не
      увеличивает ссылку, а операция
      инкремента применяется к адресуемым ею
      данным типа int, которыми оказывается
      поле переменной i. Ссылка, определяющая
      псевдоним, обязательно должна быть
      инициализирована, т.е. должен
      существовать объект, которому
      назначается новое имя. Инициализация
      ссылки не обязательно требует обращения
      к объекту, к которому допустима операция
      определения адреса. Более того, тип
      данных такого объекта может не
      совпадать с типом данных ссылки. В таких
      случаях значением ссылки становится
      адрес временной переменной, куда после
      преобразования типа помещается
      инициализирующее значение. Например,
      описание псевдонима константы
       <pre><div class="code">
   float&amp; s = 1;
</div></pre>
      <p>интерпретируется
      компилятором следующим образом:
       <pre><div class="code"> 
   float* s;         // представление ссылки указателем
   float tmp;        // объявление временной переменной
   tmp = (float)1;   // инициализация временной переменной
   s = &amp;tmp;         // инициализация ссылки</div></pre>
     <p>Использование временной
      переменной исключает возможность
      изменения области объекта, который
      использовался для инициализации ссылки:
        <pre><div class="code">
   // ПРИМЕР НЕЖЕЛАТЕЛЬНЫХ ПОСЛЕДСТВИЙ ПРИМЕНЕНИЯ ПСЕВДОНИМА
   int ix = 1;
   char&amp; cx = i; // Типы cx и i не совпадают, поэтому будет
        // создана временная переменная типа char
        // с начальным значением (char)ix и имеющая
        // псевдоним cx
   cx=2; // Значение ix не меняется, меняется значение
        // временной переменной

   // ПРИМЕР НЕЖЕЛАТЕЛЬНЫХ ОСОБЕННОСТЕЙ СВЯЗИ ПАРАМЕТРОВ ПО ССЫЛКЕ
   void f(int&amp; ix) { ix=1992; } 
   // ... 
   char cx; 
   // ...
   f(cx); // Типы параметра и аргумента не совпадают, 
          // поэтому будет сформирована последовательность 
	  // {int temp=(int)cx; 
	  // f(temp); 
	  //} 
	  // В результате переменная cx останется 
	  // без изменения</div></pre>
      <p>Последние примеры должны
      служить предостережением программисту
      о том, что избежать недоразумений можно
      лишь тщательным учетом последствий
      интерпретации типа объекта
      транслятором</p>
      <div class="header"><a name="REF_1_1_7"></a>1.7. Набор и
      приоритет операций в языке С++</div>
      <p>
      <dl>
        <p>Введем обозначения:
        <dd>
          <p>cid - идентификатор структуры,
          объединения или класса;
        <dd>
          <p>id - идентификатор объекта в
          памяти;
        <dd>
          <p>ре - выражение-указатель;
        <dd>
          <p>e - выражение;
        <dd>
          <p>iе - целочисленное выражение;
        <dd>
          <p>el - список выражений (элементы
          списка разделены запятыми);
        <dd>
          <p>t - идентификатор типа
          объекта;
        <dd>
          <p>lv - выражение, обозначающее
          непостоянный объект, пригодный для
          использования в качестве левого
          операнда операции присваивания (lvalue).</dd>
      </dl>
      <p>Сведения о составе и
      приоритете операций языка С++
      представлены в табл. 1.
      <div align="justify">
        <pre>     Табл. 1. Список операций языка С++
==========T=====================================T===============
 Обозна-  ¦          Наименование               ¦     Схема
  чение   ¦            операции                 ¦   операции
==========+=====================================+===============
 ::       ¦ Привязка имени элемента класса      ¦       cid::id
 ::       ¦ Привязка глобального имени          ¦          ::id
----------+-------------------------------------+---------------
 .        ¦ Прямой выбор элемента класса        ¦        cid.id
 -&gt;       ¦ Выбор элемента по указателю класса  ¦        pe-&gt;id
 []       ¦ Индексация                          ¦         pe[e]
 ()       ¦ Вызов функции                       ¦         e(el)
 ()       ¦ Построение значения                 ¦         t(el)
 sizeof   ¦ Размер в байтах поля объекта или    ¦      sizeof e
          ¦ результата вычисления выражения     ¦
 sizeof   ¦ Размер в байтах поля объекта        ¦     sizeof(t)
          ¦ указанного типа                     ¦
----------+-------------------------------------+---------------
 ++       ¦ Приращение после использования      ¦          lv++
 ++       ¦ Приращение до использования         ¦          ++lv
 --       ¦ Уменьшение после использования      ¦          lv--
 --       ¦ Уменьшение до использования         ¦          --lv
 ~        ¦ Дополнение (побитовое НЕ)           ¦           ~ie
 !        ¦ Логическое НЕ                       ¦            !e
 -        ¦ Унарный минус                       ¦            -e
 +        ¦ Унарный плюс                        ¦            +e
 &amp;        ¦ Адрес объекта                       ¦           &amp;lv
 *        ¦ Косвенный выбор по указателю        ¦           *pe
 new      ¦ Создание объекта                    ¦         new t
 delete   ¦ Уничтожение объекта                 ¦     delete pe
 delete[] ¦ Уничтожение массива объектов        ¦ delete[ie] pe
 ()       ¦ Приведение (преобразование) типа    ¦          (t)e
----------+-------------------------------------+---------------
 .*       ¦ Косвенный выбор элемента класса     ¦       cid.*pe
 -&gt;*      ¦ Косвенный выбор элемента класса     ¦       pe-&gt;*pe
          ¦ для косвенно адресуемого объекта    ¦
----------+-------------------------------------+---------------
 *        ¦ Умножение                           ¦         e1*e2
 /        ¦ Деление                             ¦         e1/e2
 %        ¦ Деление по модулю (остаток)         ¦       ie1%ie2
----------+-------------------------------------+---------------
 +        ¦ Сложение                            ¦         e1+e2
 -        ¦ Вычитание                           ¦         e1-e2
----------+-------------------------------------+---------------
 &lt;&lt;       ¦ Сдвиг влево                         ¦      ie1&lt;&lt;ie2
 &gt;&gt;       ¦ Сдвиг вправо                        ¦      ie1&gt;&gt;ie2
----------+-------------------------------------+---------------
 &lt;        ¦ Меньше                              ¦         e1&lt;e2
 &lt;=       ¦ Меньше или равно                    ¦        e1&lt;=e2
 &gt;        ¦ Больше                              ¦         e1&gt;e2
 &gt;=       ¦ Больше или равно                    ¦        e1&gt;=e2
----------+-------------------------------------+---------------
 ==       ¦ Равно                               ¦        e1==e2
 !=       ¦ Не равно                            ¦        e1!=e2
----------+-------------------------------------+---------------
 &amp;        ¦ Побитовое И                         ¦         e1&amp;e2
----------+-------------------------------------+---------------
 ^        ¦ Побитовое исключающее ИЛИ           ¦       ie1^ie2
----------+-------------------------------------+---------------
  |        ¦ Побитовое включающее ИЛИ            ¦       ie1|ie2
----------+-------------------------------------+---------------
 &amp;&amp;       ¦ Логическое И                        ¦        e1&amp;&e2
----------+-------------------------------------+---------------
 ||       ¦ Логическое ИЛИ                      ¦        e1||e2
----------+-------------------------------------+---------------
 ? :      ¦ Условное вычисление                 ¦     e1? e2:e3
----------+-------------------------------------+---------------
 =        ¦ Простое присваивание                ¦          lv=e
 *=       ¦ Умножение и присваивание            ¦         lv*=e
 /=       ¦ Деление и присваивание              ¦         lv/=e
 %=       ¦ Деление по модулю и присваивание    ¦        lv%=ie
 +=       ¦ Сложение и присваивание             ¦         lv+=e
 -=       ¦ Вычитание и присваивание            ¦         lv-=e
 &lt;&lt;=      ¦ Сдвиг влево и присваивание          ¦       lv&lt;&lt;=ie
 &gt;&gt;=      ¦ Сдвиг вправо и присваивание         ¦       lv&gt;&gt;=ie
 &=       ¦ Побитовое И и присваивание          ¦        lv&=ie
 |=       ¦ Побитовое включающее ИЛИ и          ¦        lv|=ie
          ¦ присваивание                        ¦
 ^=       ¦ Побитовое исключающее ИЛИ и         ¦        lv^=ie
          ¦ присваивание                        ¦
----------+-------------------------------------+---------------
 ,        ¦ Следование                          ¦        e1, e2
----------+-------------------------------------+---------------
</pre></div>
      <p>В каждой отчерченной части
      находятся группа операции с одинаковым
      приоритетом. Приоритет
      нижерасположенных групп ниже
      вышерасположенных. Порядок выполнения
      операций можно регулировать круглыми
      скобками. Для объектов, определенных
      пользователем, содержание операции
      устанавливается функцией с атрибутом
      operator. Можно заметить, что набор операций
      языка C в языке C++ дополнен операциями ::, .*,
      -&gt;*, new, delete. Смысл таких операций
      рассматривается далее в разделах 1-3.
<p>
      <div class="header"><a name="REF_1_1_8"></a>1.8. Операция
      преобразования типа</div>
      <p>Операции над объектами разных
      типов порождают вопрос корректности и
      типа результата. В языках С и С++
      допустимы операции над любыми
      комбинациями арифметических типов (int,
      short, long, unsigned int, unsigned short, unsigned long, float, double).Символы
      (char, unsigned char) преобразуются к типу int.
      Результат арифметической операции в
      математическом отношении будет
      корректным в рамках конкретных
      аппаратных возможностей. Например:
        <pre><div class="code">    
   unsigned char x=150, y=128;
   unsigned char z=x+y;         // z!=150+128
   int  a=x+y;                  // a==150+128
</div></pre>
      <p>Корректными и
      прогнозируемыми являются операции
      сложения и вычитания над парами
      операндов (указатель_объекта_типа_X -
      арифметическое_значение), а также
      вычитания указателей объектов одного
      типа). Язык С предоставляет пользователю
      операцией приведения типа (тип)X явно
      указать требуемый вид преобразования
      объекта X:
<pre><div class="code">	
   #include &lt;stdio.h&gt;
   #include &lt;stdlib.h&gt;

   // ПРОЦЕДУРА ПЕЧАТИ 10 СЛУЧАЙНЫХ ЧИСЕЛ В ДИАПАЗОНЕ 0...1
 
   void main(void) { 
      static n=32767; 
      for (int i=0; i&lt;10; i++) 
          printf(&quot;\n %f&quot;,(float)random(n)/(float)n); 
   }</div></pre>
      <p>Потребность в операции
      приведения возникают в случае появления
      неопределенности типа операнда и при
      необходимости обхода запретов языка на
      комбинации операндов. Неопределенность
      типа операнда возникает, например, при
      передаче значения аргумента функции при
      отсутствии в ее описании описания
      списка параметров). Компилятор
      предупреждает программиста о подобных
      ситуациях, но иногда неопределенность
      порождена отсутствием достаточной
      информации. Рассмотрим пример программы
      с неопределенностью связи аргумент -
      параметр. <pre><div class="code">
#include &lt;stdio.h&gt;
      void main() {
      float f=125.0;

      printf(&quot;\n??? %f %d %x %f&quot;,f,f,f,f);

      printf(&quot;\n*** %f %d %x %f&quot;,f,(int)f,(int)f,f);
}</div></pre>
      <p>Результаты работы программы (Borland
      C++):
      <div align="justify">
        <pre>     ??? 125.000000 0 405f4000 125.000000
     *** 125.000000 125 7d 125.000000
</pre>
      </div>
<a href="1_8_1.exe">Выполнить</a>
      <p>Источником ошибок при
      вычислении выражения может быть
      неправильное представление
      промежуточных результатов.
      <p>Пусть необходимо установить способ
      представления в памяти конкретной
      вычислительной системы чисел типа long: <pre><div class="code">
   #include &lt;stdio.h&gt;

   void main() { 
      long lx=0;
      for (int i=0; i&lt;sizeof(lx); i++)
          lx|=((long)i)&lt;&lt;(i&lt;&lt;3); 

      unsigned char *x=(unsigned char *)&amp;lx; 
    
      printf(&quot;\n %d, %0*lx, &quot;, sizeof(lx),sizeof(lx)&lt;&lt;1,lx);
      for (i=0; i&lt;sizeof(lx); i++)
         printf(" %02x",x[i]);
   }      </div></pre>Результат работы программы на ПЭВМ
      класса IBM PC XT/AT:
      <pre>   Размер 4, значение 03020100, представление 00 01 02 03
</pre>
<a href="1_8_2.exe">Выполнить</a>
      <p>Примеры запрещенных видов
      операции присваивания:
      <pre>   указатель=арифметическое_значение;<br>   арифметическая_переменная=указатель;<br>   указатель_объекта_типа_1=указатель_объекта_типа_2,<br>   если (тип_1!=тип2)&amp;&amp;(тип_1!=void)&amp;&amp;(тип_2!=void).</pre>
      <p>Многие задачи системного и
      прикладного программирования вынуждают
      использовать перечисленные операции.
      При этом приходится непосредственно
      сталкиваться с особенностями
      реализации вычислительной среды, а
      программы легко теряют свойство
      мобильности. Например, пусть необходимо
      получить доступ к видеопамяти
      текстового режима работы дисплея по
      известному адресу 0xb8000 для
      видеоадаптеров CGA, EGA или VGA ПЭВМ класса IBM
      PC/XT/AT:
     <pre><div class="code">
   // Правильный вариант описания видеопамяти
   struct item { 
      char byte; // отображаемый символ 
      char attr; // атрибуты отображения 
   }
   *screen_pointer=(struct item far *)MK_FP(0xb800,0);
</div></pre>
      <dl>
        <p>Здесь учтены:
        <dd>
          <p>формат элемента
          видеопамяти;
        <dd>
          <p>невозможность
          относительной адресации видеопамяти
          в сегментах программы пользователя
          (&quot;близкими&quot; указателями с
          атрибутом near);
        <dd>
          <p>использование уникального
          способа представления &quot;далекого&quot;
          (far) указателя и т.д.</dd>
      </dl>
      <p>Игнорирование, например,
      последнего фактора приведено в
      синтаксически правильном операторе
        <pre><div class="code">     
   screen_pointer=(struct item far *)0xb8000l;
</div></pre>
      <p>Попытка после этого очистить
      поле экрана оператором
 <pre><div class="code">
   for (int i=0; i&lt;2000; screen_pointer[i++].byte=' ');
</div></pre>
      <p>наверняка закончится крахом
      системы. Способ представления далеких
      указателей в системах программирования
      С и С++ фирмы Borland определен
      макрокомандой
       <pre><div class="code">
   #define MK_FP(seg,ofs) \ ((void far *)(((unsigned long)(seg)&lt;&lt;16)|(unsigned)(ofs)))
</div></pre>
      <p>Результат преобразования
      объекта, не являющегося указателем, не
      может быть lvalue, поэтому значение ему
      присваивать нельзя. Для указателя же
      допустимым является выражение
        <pre><div class="code">
   // Правильный вариант установки указателя видеопамяти
   (unsigned long)screen_pointer=0xb8000000l;
</div></pre>
      <p>Подобные операции характерны
      для системного программирования, но при
      этом желательно максимально
      использовать высокоуровневые
      лингвистические средства (см.
      первоначальный вариант).
      <p>В языке С++ допустимы два
      способа записи операции явного
      преобразования типа:
      <dl>
        <dd>
          <p>а) традиционная для языка C
          запись операции приведения типа в
          форме (тип)выражение, например:
            <pre><div class="code">     
   (float)i - приведение простой переменной,
   (long)(x+y) - приведение значения выражения,
   (char *)&amp;x - приведение значения адреса;
   (int *)0x100 - приведение значения константы;
</div></pre>
          <dd>
          <p>б) функциональная запись
          операции приведения типа в форме тип(выражение),
          где &quot;тип&quot; должен обозначаться
          простым именем, например:
           <pre><div class="code">
   float(i),     // int i;
   long(x+y),    // int x,y;
   double(125);  // int z=125;
</div></pre>
        </dd>
      </dl>
      <p>Ограничение на имя типа легко
      преодолеть определением нового имени
      типа. Например, оператор декларации
        <pre><div class="code">     
   char *p=(char *)0777; // традиционное приведение</div></pre>
     <p>в функциональной форме записи
      операции приведения типа можно
      представить следующим образом:
     <pre><div class="code">     
   typedef char * string;  // идентификация типа char *
                           // новым именем string
   char* p = string(0777); // функциональное приведение 
		           // к типу string (либо обращение 
		           // к функции string?)
</div></pre>
      <p>Функциональная запись
      улучшает читаемость текста программы.
      Например, рассмотрим эквивалентные
      выражения:
      <pre><div class="code">     
   marker pn = base(xn-&gt;tp)-&gt;buf;   // функциональная запись
   marker pn = ((base)xn-&gt;tp)-&gt;buf; // традиционная запись
</div></pre>
      <p>Операция -&gt; имеет больший
      приоритет, чем приведение, поэтому
      последнее выражение интерпретируется
      как
        <pre><div class="code">
   marker pn = ((base)(xn-&gt;tp))-&gt;buf; // здесь 3 пары скобок!
</div></pre>
      <p>Функциональный стиль записи
      операции приведения особенно удобен в С++
      для определяемых пользователем типов (классов).
      Операция приведения в этом случае
      реализуется процедурой создания
      объекта - конструктором (имя процедуры
      совпадает с именем типа, а набор
      параметров характеризует исходное
      состояние объекта). Явное приведение
      типов указателей позволяет получить
      адрес объекта любого типа:
      <pre><div class="code">     
   any_type* p = (any_type*)&amp;some_object;
</div></pre>
      <p>Известное значение указателя
      p позволяет работать с некоторым
      объектом some_object как объектом типа any_type (см.
      пример программы вывода представления
      поля типа long). Явное преобразование
      типов рекомендуется использовать лишь в
      крайних случаях. Появление неожиданных
      результатов операций во внешне
      правильных выражениях и исходных данных
      - сигнал для анализа и коррекции хода
      преобразований.
<p>
      <div class="header"><a name="REF_1_1_9"></a>1.9. Объявление и
      переопределение функций</div>
      <p>В классическом языке С при
      описании функции достаточно объявить
      лишь тип возвращаемого значения. Язык С++
      требует полной определенности при
      объявлении функций. Объявление функции
      задается в виде ее описания и/или
      определения.</p>
      <p><strong>Описание</strong> функции
      задает имя функции, тип возвращаемого
      функцией значения (если такое есть), а
      также и число и типы используемых при
      вызове параметров.</p>
      <p>Примеры описания функций:</p>
      <pre><div class="code">     
   extern double sqrt(double);
   extern elem* next_elem();
   extern char* strcpy(char* to, const char* from);
   extern void exit(int);
</div></pre>
      <p>В описании функции для
      удобства чтения можно приводить имена
      аргументов, но компилятор их игнорирует.
      Описание иногда называют <strong>прототипом</strong>
      функции, подчеркивая его роль при
      конструировании компилятором
      элементарных операций обращения к
      функции (преобразование фактических
      параметров, формирование списка их
      значений, вызов функции по
      соответствующему имени адресу).</p>
      <p><strong>Определение</strong> функции
      - это полное описание функции, в котором
      представлено тело функции.
      <p>Пример описания и определения
      функции:
     <pre><div class="code">  
   extern void swap(int *, int *); // описание функции
   void swap(int *x, int *y) { // определение функции 
      int t=*x; 
      *x=*y, *y=t; 
   }
</div></pre>
      <p>(имена аргументов в
      определении функции обязательны).
      <p>Определение функции в
      исходном тексте программы может
      отсутствовать, но наличие до первого
      использования имени функции ее описания
      в этом случае обязательно. Появление в
      исходном тексте определения функции
      делает излишним ее описание в остатке
      текста до конца файла. Отсутствие
      определения в файле программы
      свидетельствует о том, что будет
      использован объектный модуль,
      получаемый на основе другого файла или
      из библиотеки. Описания функций
      рекомендуется помещать в заголовочные
      файлы.
      <p>В языке С++, в отличие от языка
      С, функции идентифицируются вектором
       <pre><div class="code">
   (имя_функции, имя_типа_парам_1, имя_типа_парам_2,...).
</div></pre>
      <p>Тип функции здесь не
      используется, так как возвращаемое
      функцией значение может быть
      преобразовано в любой требуемый и
      допустимый тип. Таким образом, разрешено
      использование в одной программе функций
      с одинаковыми именами, но
      различающимися списками аргументов по
      количеству и/или типу. Говорят, что такие
      функции являются <strong>переопределенными</strong>
      (иногда встречаются термины &quot;перезагрузка&quot;
      или &quot;повторная загрузка&quot; функций).
      <p>Переопределенные функции
      весьма практичны для программирования
      одинаковых в некотором смысле действий
      над объектами разных типов. 
<pre><div class="code">
   #include &lt;stdio.h&gt;
   int sum(int x, int y) { // Вариант 1 
      printf(&quot;\nInt - Int :&quot;); 
      return x+y; 
   } 
   
   char sum(char x, char y) { // Вариант 2 
      printf(&quot;\nChar - Char :&quot;); 
      return x+y; 
   } 

   float sum(float x, float y) { // Вариант 3 
      printf(&quot;\nFloat - Float :&quot;);
      return x+y; 
   } 
  
   int sum(int *x, int n) { // Вариант 4 
	printf(&quot;\nInt[]:&quot;); 
	for (int j=0, i=0; i&lt;n; j+=x[i++]); 
	  return j;
   }

   int sum(int *x, int *y, int n) {  // Вариант 5
      printf(&quot;\nInt[] - Int[] :&quot;);
      for (int j=0, i=0; i&lt;n; j+=x[i]+y[i], i++);
      return j;
   }

   void main() {
      int i=1, j=2;
      char x=3, y=4;
      float a=5.0, b=6.0;
      static int c[]={1,2,3,4,5}, d[]={1,2,3,4,5};

   // Примеры вызова переопределенных функций

      printf("%d (1)", sum(i,j));
      printf("%d (2)", sum(x,y));
      printf("%f (3)", sum(a,b));
      printf("%f (4)", sum(a,1));
      printf("%f (5)", sum(a,(float)1));
      printf("%d (6)", sum(c,sizeof(c)/sizeof(*c)));
      printf("%d (7)", sum(c,d,sizeof(c)/sizeof(*c)));
	
   // Инициализация указателя именем<br>   // переопределенной функции

      int (*act)(int,int)=sum;
      printf("%d (8)", (*act)(i,j));
      printf("%d (9)", (*act)(int(a),int(b)));
      printf("%d (10)", (*act)(a,b));
   }   </div></pre>
      <p>Результаты работы программы:
      <pre>
   Int - Int :3 (1)
   Char - Char :7 (2)
   Float - Float :11.000000 (3)
   Int - Int :0.000000 (4) // Ошибка, но возможно из-за формата
   Float - Float :6.000000 (5)
   Int[] :15 (6)
   Int[] - Int[] :30 (7)
   Int - Int :3 (8)
   Int - Int :11 (9)
   Int - Int :11 (10)
</pre>
<a href="1_9.exe">Выполнить</a>
      <p>
      <p>Имена переопределенных
      функций могут использоваться в любых
      операциях как имена других функций.
      Выбор компилятором подходящей версии
      функции производится поэтапно до
      выявления сопоставимости типов
      аргументов и параметров - вначале по
      условию точного совпадения, а затем по
      условию совпадения после применения
      стандартных преобразований. По
      отношению к объектам определяемых
      пользователем классов этот вопрос
      детально будет рассмотрен в <a href="#REF_1_3_3">подразделе
      3.3</a>. Возможность переопределения
      функций в языке С++ реализуется
      расширением транслятором имени функции
      символьной информацией о количестве и
      типе параметров. Такое расширение может
      оказаться нежелательным, например, при
      включении в программу на языке С++
      объектных модулей из файлов и/или
      библиотек, созданных транслятором языка
      С.</p>
      <p>Функции, подлежащие
      интерпретации в стиле языка С, следует
      описывать и/или определять со
      специальным модификатором типа extern &quot;C&quot;:
      <pre><div class="code">     
   extern &quot;C&quot; long f1(void); // отдельная функция
   extern &quot;C&quot; { // группа функций
      void f2(int); 
      double f3(double, int); 
   };
   
   extern &quot;C&quot; void f4(int z) { // определение функции 
      // ... 
   }</div></pre>
      <p>Определение функции f4 в
      приведенном виде позволяет
      использовать ее объектный модуль в
      системах программирования на языке С.
      Очевидно, что для использования
      библиотек стандартных программ,
      созданных на языке C и представленных в
      заголовочном файле, например, library.h,
      достаточно записать
      <pre><div class="code">
   extern &quot;C&quot; {
      #include &quot;library.h&quot;
   };</div>
</pre>
      <p>При описании и/или
      определении функции язык С++ позволяет
      задать <a href="#REF_1_1_10">значения
      параметров по умолчанию</a>, а также
      представить <a href="#REF_1_1_11">функции
      с переменным числом параметров</a>. Такие
      возможности обсуждаются в подразделах
      1.10 и 1.11. Кроме этого, в подразделе 1.12
      рассматривается возможность замены
      операции вызова функции <a href="#REF_1_1_12">подстановкой
      тела функции в точку вызова</a>.
<p>
      <div class="header"><a name="REF_1_1_10"></a>1.10. Установка
      умалчиваемых значений параметров
      функций</div>
      <p>Использование умалчиваемых
      значений параметров улучшает
      читаемость текста программы за счет
      исключения в операторе вызова функции
      предопределенных выражений.
      <p>Например, пусть определена
      функция
      <pre><div class="code">
   void f_name(int par1, int par2=1,int par3=2) { /* ... */ }
</div></pre>
      <p>Возможные операторы вызова
      функции f_name и их интерпретация в стиле
      языка С:
      <pre><div class="code">
   f_name(x)      &lt;=&gt;  f_name(x,1,2)
   f_name(x,y)    &lt;=&gt;  f_name(x,y,2)
   f_name(x,y,z)  &lt;=&gt;  f_name(x,y,z)
   _name()  // ошибка
</div></pre>
      <p>Значения параметров функции
      по умолчанию могут задаваться в ее
      определении и/или описании. Все
      параметры такого вида необходимо
      размещать в конце списка параметров.
      Умалчиваемое значение параметра
      устанавливается в списке параметров
      подобно оператору инициализации:
      <p>тип_параметра имя_параметра =
      выражение
      <p>(в операторе описания функции
      имя параметра не обязательно, но
      разделитель между элементом &quot;тип_параметра&quot;
      и символом '=' должен быть). Значение
      выражения вычисляется в момент вызова
      функции. Выражение может включать любые
      допустимые операции, в том числе и вызов
      функций. Имена глобальных объектов
      использовать можно, но имена из списка
      параметров нельзя (параметры являются
      локальными объектами блока функции).
      Возможность установки значений
      параметров в описании функции позволяет
      использовать в разных блоках
      различающиеся выражения и наборы
      умалчиваемых параметров (некоторые
      реализации систем С++ не допускают
      использование для этих целей вложенных
      блоков функции): <pre><div class="code">
   #include &lt;stdio.h&gt;
   #include &lt;string.h&gt;
   
   void test(char *p1=&quot;x1-?&quot;,char *p2=&quot;x2-?&quot;,char *p3=&quot;x3-?&quot;);
   void test(char *p1,char *p2,char *p3) { 
      printf(&quot;\n %s %s %s&quot;,p1,p2,p3); 
   }
   
   char *zx=&quot;P1 ???&quot;;
   char *dsprpl(int n=80) { 
      char *x=new char[(n&lt;40)? 40:n]; 
      sprintf(x,&quot;p3=empty, size=%d\0&quot;,n); 
      return x; 
   }
	
   void omega() { 
      void test(char *p1=zx, char *p2=&quot;q2-?&quot;, char *p3=dsprpl()); 
      test(); 
      test(&quot;e&quot;); 
   }

   void main () { 
      test(); 
      test(&quot;a&quot;); 
      test(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);
      void test(char *p1=zx, char *p2=&quot;p2-?&quot;, char *p3=&quot;p3-?&quot;);
      test(); 
      test(&quot;a&quot;,&quot;b&quot;); 
      omega(); 
   }</div>
      </pre>
      <p>Результаты работы программы:
            <pre>
    x1-? x2-? x3-?
    a x2-? x3-?
    a b c
    P1 ??? p2-? p3-?
    a b p3-?
    P1 ??? q2-? p3=empty, size=80
    e q2-? p3=empty, size=80
</pre>
<a href="1_10.exe">Выполнить</a>
<p>
      <div class="header"><a name="REF_1_1_11"></a>1.11. Функции с
      переменным числом параметров</div>
      <p>Переопределение функций или
      задание умалчиваемых параметров по
      умолчанию часто не позволяют определять
      функции с неопределенным количеством и
      типов параметров. В таких ситуациях
      приходится отказываться от контроля
      компилятором корректности обращения к
      функции, указывая лишь наличие
      переменного количества параметров.
      Ответственность за правильное
      использование параметров возлагается
      на программиста. Признаком функции с
      переменным количеством параметров
      является завершение списка ее
      параметров многоточием (...). Например,
      описание библиотечной функции
        <pre><div class="code">    
   int printf(char *,...);
</div></pre>
      <p>означает, что при вызове printf
      должен быть по меньшей мере один
      параметр типа char*, а остальные могут быть
      лишь по потребности:
        <pre><div class="code">     
   printf(&quot;СПИСОК СОТРУДНИКОВ\n&quot;);
   printf(&quot;КАФЕДРА %s, ФАКУЛЬТЕТ %s\n&quot;,k_n,f_n);
   printf(&quot;%d + %d = %d\n&quot;,2,3,5);
</div></pre>
      <p>Здесь количество и типы
      параметров должны соответствовать
      управляющим символам форматной строки,
      но компилятор этого учесть не может:
       <pre><div class="code">     
   char *format=&quot;ФАМИЛИЯ,И.О.: %40s Оклад: %6d&quot;;
   // Синтаксически правильные операторы
   printf(format);                         // ???
   printf(format,&quot;Иванов&quot;,1000);           // правильно
   printf(format,&quot;Иванов&quot;,&quot;Василий&quot;,1000); // ???
</div></pre>
      <p>Функции с переменным числом
      параметров должны иметь по крайней мере
      один аргумент для привязки стека
      значений параметров (в языке С параметры
      передаются по значениям). Доступ к
      значениям параметров переменной части
      списка можно организовать по указателям,
      начиная с последнего фиксированного
      параметра. Зная для любого параметра его
      адрес и тип, адрес следующего параметра
      определяется смещением на величину sizeof(тип).
      Однако действительное значение адреса
      следующего параметра в некоторых
      системах может быть скорректировано с
      учетом правил выравнивания. По
      последней причине рекомендуется
      строить механизм выборки параметров на
      основе системнонезависимых макрокоманд,
      определенных в библиотечном файле stdarg.h.
      Файл stdarg.h содержит содержит следующие
      макроопределения для организации
      доступа к списку значений параметров
      функции:
       <pre><div class="code">     
   void va_start(va_list ap, lastfix),
   type va_arg(va_list ap, type),
   void va_end(va_list ap),
</div></pre>
      <p>где lastfix - имя последнего
      фиксированного параметра; ap - указатель
      очередного параметра типа type.
      <p>Тип va_list указателя ap определен
      в файле stdarg.h оператором
        <pre><div class="code">    
   typedef void *va_list;
</div></pre>
      <p>Макрокоманда va_start
      инициализирует указатель ap значением
      адреса параметра, следующего за
      последним фиксированным параметром lastfix.
      Отсюда следует, что такая макрокоманда
      обязательно должна использоваться до
      вызова макрокоманд va_arg или va_end.
      <p>Примеры реализаций
      макрокоманды va_start:
       <pre><div class="code">
   // Turbo C++
   #define va_start(ap, lastfix) (ap=...)

   // Turbo C 

   #define va_start(ap, lastfix) ((void)((ap)=\
         \ (va_list)((char *)(&amp;lastfix)+((sizeof(lastfix)+1)&amp;0xFFFE))))
</div></pre>
      <p>Макрокоманда va_arg
      предназначена для выборки очередного
      параметра типа type и установки указателя
      ap на следующий параметр.
      <p>Примеры реализаций
      макрокоманды va_arg:
        <pre><div class="code">
   // Turbo C++
   #define va_arg(ap, type) (*((type *)(ap))++)

   // Turbo C  

   #define va_arg(ap, type)\ (*(type *)(((*(char **)&amp;(ap))+=\<br>                    \ ((sizeof(type)+1)&amp;0xFFFE))-(((sizeof(type)+1)&amp;0xFFFE))))
</div></pre>
      <p>Макрокоманда va_end выполняет
      &quot;закрытие&quot; списка аргументов для
      исключения возможности его
      использования без повторного
      использования команды va_start. Примеры
      реализаций макрокоманды va_arg:
       <pre><div class="code">
   // Turbo C++
   #define va_end(ap) ((void)0)

   // Turbo C 

   #define va_end(ap)
</div></pre>
      <p>Рассмотрим пример функции с
      переменным числом параметров целого
      типа: 
 <pre><div class="code">
   #include &lt;stdio.h&gt;
   #include &lt;stdlib.h&gt;
   #include &lt;starg.h&gt;
   
   int sum(int n,... ) {
      va_list a; // Указатель текущего параметра

      va_start(a,n);

      for (int i=0, b=0; i &lt; n; i++) b+=va_arg(a,int);

      va_end(a);
      return(b); 
   }

   void main () {  
      printf(&quot;\n1) %d&quot;,sum(5,1,2,3,4,5));
      printf(&quot;\n2) %d&quot;,sum(4,6,7,8,9)); 
      printf(&quot;\n3) %d&quot;,sum(4,6,7.0,8,9));

      printf(&quot;\n1) %d&quot;,sum(5)); 
   } </div></pre>
      Результаты работы программы:
      <pre>
   1) 15
   2) 30
   3) 6   &lt;---- Ошибка преобразования типа по вине программиста 
   4) 5
</pre>
      <p>Количество элементов списка
      здесь указывается фиксированным в
      полном списке аргументов параметром n.
      Возможны другие приемы пометки
      количества параметров (например,
      некоторое особое значение последнего
      параметра). Типы параметров переменной
      части списка могут быть в общем случае
      любыми. Рекомендуется минимизировать
      применение функций с переменным числом
      параметров ввиду отсутствия со стороны
      компилятора контроля за правильностью
      их преобразования.
<p>
      <div class="header"><a name="REF_1_1_12"></a>1.12. Встраиваемые
      функции</div>
      <p>Использование функций
      связано с потерями машинного времени на
      выполнение действий по сохранению и
      восстановлению регистров общего
      назначения, формированию списков
      параметров и т.д. (пролог и эпилог
      функции). Для относительно небольших
      функций величина таких потерь может
      оказаться соизмеримой с временем
      выполнения основных операций тела
      функции.
      <p>При программировании в стиле
      языка С небольшие, но часто используемые
      выражения обычно оформляют как
      макроопределения с параметрами. Однако
      использование механизма макросредств
      страдает двумя недостатками:
      <ul>
        <li>
          <p>отсутствие контроля типов
          параметров макрокоманд;
        <li>
          <p>наличие побочных эффектов в
          макрорасширениях.</li>
      </ul>
      <p>Пример проявления последнего
      недостатка:
        <pre><div class="code">
   // Макроопределение операции возведения в квадрат
   //
   #define SQUARE(X)  (X)*(X)
   // ...
   int x,y;
   // Пример макрокоманды
   y=SQUARE(x++);
   // ...
   // Полученное макрорасширение
   y=(x++)*(x++);
</div></pre>
      <p>Результат вычисления здесь
      будет неверным, так как естественно
      ожидаемое макрорасширение должно быть
      эквивалентно следующему:
      <pre><div class="code">        
   y=x*x, x++;
</div></pre>
      <p>В языке С++ дополнительным
      атрибутом inline в определении функции
      можно рекомендовать компилятору, по
      возможности, встроить код тела функции в
      место вызова. Компилятор игнорирует эту
      рекомендацию в следующих ситуациях:
      <ul>
        <li>
          <p>наличие операторов
          организации циклов (for, do, while),
          переключателей (switch) и безусловного
          перехода (goto) в функциях, возвращающих
          значения;</p>
        <li>
          <p>наличие оператора return в
          функциях, не возвращающих значения;</p>
        <li>
          <p>обнаружение рекурсивного
          вызова функции;</p>
        <li>
          <p>использование статических
          переменных (с атрибутом static).</p>
        </li>
      </ul>
      <p>Функции с атрибутом inline
      сохраняют общие свойства функций (локальные
      переменныые, возможность вычисления
      адреса, преобразование параметров и
      возвращаемых значений и т.п.).
      <p>Примеры использования
      встраиваемых функций: 
<pre><div class="code">
   #include &lt;stdio.h&gt;
   
   inline int maxint(int x, int y=4) { 
      return((x&gt;y)?x:y); 
   }
 
   inline void swap(int &amp;x, int &amp;y) { 
      int t=x; x=y, y=t; 
   }
   
   inline void swap(float &amp;x, float &amp;y) { 
      float t=x;
      x=y, y=t; 
   }

   void main () { 
      int x=1, y=2;  
      printf(&quot;\n %d %d %d&quot;,x,y,maxint(x,y)); 
      swap(x,y); 
      printf(&quot;\n %d %d %d&quot;,x,y,maxint(x,y)); 
      int (*act)(int ,int =3)=maxint; 
      printf(&quot;\n %d %d %d&quot;,x,y,(*act)(x)); 
      printf(&quot;\n %d %d %d&quot;,x,y,maxint(x)); 
      float a=1.0, b=2.0; swap(a,b); 
      printf(&quot;\n %.1f %.1f&quot;,a,b); 
   } </div> </pre>
      Результаты работы программы:
        <pre> 
   1 2 2
   2 1 2
   2 1 3
   2 1 4
   2.0 1.0
</pre>
<a href="1_12.exe">Выполнить</a>
      <p>Подобно макрорасширениям,
      встаиваемые функции увеличивают объем
      программы. При программировании на
      языке С++ рекомендуется вместо
      макросредств во всех возможных случаях
      отдавать предпочтение встраиваемым
      функциям. Возможность контроля типов
      параметров и автоматического
      преобразования значений аргументов
      упрощает процесс программирования.
<p>
      <div class="header"><a name="REF_1_1_13"></a>1.13. Управление
      размещением объектов в памяти</div>
      <p>Любой именованный объект
      программы размещается в статически либо
      автоматически распределяемой памяти.
      Статический объект размещается во время
      запуска программы и существует в
      течение всего времени ее выполнения.
      Автоматический объект размещается
      каждый раз при входе в его блок и
      существует только до момента выхода из
      блока. Часто возникает потребность
      управляемого размещения объектов в
      памяти в соответствии с алгоритмом
      решения задачи <strong>без привязки</strong> к
      блокам программы. В языках С и С++ такие
      объекты могут адресоваться только
      косвенно по значению указателя.
      Указатель может иметь при этом имя, но
      адресуемый им объект является
      безымянным. Управление размещением
      объектов осуществляется операциями
      захвата и освобождения памяти. В языке С
      для этих целей приходится пользоваться
      библиотечными функциями. Например, в
      файле alloc.h декларированы функции:
      <pre><div class="code">
   void *malloc(unsigned  nbytes) - возврат указателя на выделеную
      область размером nbytes 
   (NULL при  недостатке  памяти  или nbytes==0);
   
   void free(void *block_pointer) - освобождение захваченной памяти по
      заданному адресу.
</div></pre>
     <p>Операции захвата и
      освобождения памяти в стиле языка С
      имеют вид:
      <pre><div class="code">     
   указатель_на_объект=malloc(sizeof(атрибуты_типа_объекта));
   free(указатель_на_объект);
</div></pre>
      <p>В языке С++ операция захвата
      памяти записывается в следующих видах:
      <pre><div class="code">     
   указатель_на_объект = new атрибуты_типа_объекта;
</div></pre>
      <p>указатель_на_объект = new
      атрибуты_типа_объекта(значение); (здесь
      &quot;значение&quot; определяет начальное
      значение создаваемого объекта для
      некоторых типов данных). Результат
      операции захвата памяти - значение
      указателя на выделенную для размещения
      объекта указанного типа область памяти.
      Признак нехватки памяти - пустое
      значение указателя (0 или NULL).
      <p>Примеры программирования
      захвата памяти:
      <pre><div class="code">     
   int  *x;
   char *y;
   char *z=&quot;abcdef&quot;;
   ...
   x=new int;               // создание простого объекта
   y=new char[sizeof(z)+1]; // создание массива символов
   ...
   float *s=new float[n];  // создание массива из n элементов
   int *d=new int(-12345); // создание и инициализация объекта
</div></pre>
   <p>Схема выполнения последнего
      оператора:
      <pre><div class="code">     
   int *d=new int;  // создание объекта - захват памяти
   *d=int(-12345); // конструирование конкретного объекта
</div></pre>
      <p>Очевидно, что массивы
      объектов подобным инициализироваться
      не могут. Cозданный с помощью операции new
      объект существует до завершения
      программы, если не использована
      операция освобождения памяти delete (сказанное
      справедливо и для объектов, создаваемых
      библиотечными функциями). Виды записи
      операции освобождения памяти:
      <pre><div class="code">     
   delete указатель_на_объект;
   delete [размер] указатель_на_объект;
</div></pre>
      <p>(вторая форма применяется для
      определяемых пользователем векторных
      типов данных, а для остальных типов
      данных параметр &quot;размер&quot;
      игнорируется). Операция delete может
      применяться только к значению указателя,
      который был возвращен операцей new.
      Повторное освобождение памяти чревато
      аварийными последствиями. После
      освобождения памяти можно присвоить
      указателю нулевое значение, так как
      применение delete к нулю не вызывает
      никаких действий.
      <p>Пример программы считывания
      файлов в память: <pre><div class="code">
   #include &lt;stdio.h&gt;
   #include &lt;io.h&gt;

   void main(int na, char **la) { 
      FILE *inpfil; 
      char *buffer; 
      size_t number;
      if (na&gt;1) { 
         if ((inpfil=fopen(la[1],&quot;rb&quot;))!=NULL) { 
            long length=filelength(fileno(inpfil));
            buffer=new char[number=(size_t)length];
            if (buffer) {
               fread(buffer,sizeof(*buffer),number,inpfil); // Обработка данных
               delete buffer;
            }
            else printf(&quot;\nНет памяти&quot;); 
         }
         else printf(&quot;\nФайл %s не найден&quot;,la[1]);
      }
      else printf(&quot;\nВызов: %s имя_файла&quot;,la[0]); 
   }</div></pre>
      Операции управления памятью
      буфера в стиле языка С имели бы вид:
      <pre><div class="code">     
   buffer=malloc(number*sizeof(*buffer)); // захват памяти
   free(buffer); // освобождение памяти
</div></pre>
     <p>Стандартные библиотечные
      функции образуют достаточно гибкий
      набор средств управления памятью.
      Например, библиотечная функция
      <pre><div class="code">
   void *сalloc(unsigned n_elem, unsigned l_elem)
</div></pre>
      <p>наряду с захватом памяти для
      n_elen объектов размером l_elem байт
      заполняет ее нулями, а функция
      <pre><div class="code">     
   void *realloc(void *blk_ptr,unsigned nbytes)
</div></pre>
      <p>изменяет размер ранее
      распределенного по адресу blk_ptr блока на
      новое значение nbytes и копирует, при
      необходимости, содержимое блока в новую
      область памяти. Кажущийся недостаток
      гибкости операторов new и delete легко
      устраняется возможностью их <strong>переопределения</strong>.
      Механизм переопределения операторов в
      языке С++ базируется на переопределении
      функций и подробно рассматривается в 3.2.
      Поясним идею такого механизма. Операции
      управления размещением объектов в языке
      С++ реализуются функциями:
      <pre><div class="code">     
   void *operator new(size_t size);
   void operator delete(void *pointer,size_t size);
</div></pre>
      <p>(здесь size_t - тип данных для
      представления размера объекта в байтах).
      Можно переопределить эти функции с
      учетом потребностей пользователя:
      <pre><div class="code">     
   void *operator new(size_t size) {
     void *p=malloc(size);
     printf(&quot;\nЗапрос %d байт, адрес блока %p&quot;,size,p);
     return p;
   }
   
   void operator delete(void *pointer,size_t size) {
      printf(&quot;\nОсвобождение блока по адресу %p&quot;,pointer); 
      free(pointer); 
   }</div></pre>
      <p>(второй параметр функции delete
      для объектов базовых типов игнорируется,
      но формально должен присутствовать).
      Приведенные функции переопределяют
      операции new и delete глобально для объектов
      всех типов. В общем случае, в языке С++
      можно конкретизировать область
      применения функций, переопределяющих
      операторы для создаваемых
      программистом классов объектов.
      Напомним, что многомерные массивы в
      языке С рекурсивно представляются
      массивами указателей на массивы с
      уменьшенным на единицу количеством
      измерений. Захват памяти посредством
      использования библиотечных функций или
      оператора new не влечет построения
      соответствующих связей, так как это
      связано с необходимостью нетривиальной
      инициализации полей выделенной памяти.
      Отсюда следует, что управление
      размещением в памяти массивов с более,
      чем одним измерением при намерении
      последующего использования стандартных
      операций обращения к элементам массивов
      по индексам требует программирования
      процесса захвата и освобождения памяти
      элементарных одномерных массивов.
      Приведем пример программы с
      динамическим распределением двумерных
      массивов. <pre><div class="code">
   #include &lt;stdio.h&gt;

   typedef int type; // Определение типа элементов матрицы
   
   // Процедура создания прямоугольной матрицы
   
   type **matrixn(int m, int n) { 
      if ((m&lt;=0)||(n&lt;0))
         return NULL;

   // Создание массива указателей строк матрицы
   
      type **x=new type *[m];
      if (x!=NULL) {

   // Создание строк матрицы
     
         for (int i=0; i&lt;m; i++) 
            if ((x[i]=new type[n])==NULL) { 

   // Контроль наличия памяти 
 
                while (i) delete[n] x[--i]; 
                   delete[m] x; 
                x=NULL; 
                break; 
             } 
      } 
      return x; 
   }

   // Процедура уничтожения прямоугольной матрицы
   
   void matrixd(type **x, int m, int n) { 
      if (x!=NULL) {

   // Уничтожение строк матрицы
   
         for (int i=0; i &lt; m; i++) 
            delete[n] x[i];

   // Уничтожение массива указателей строк матрицы
         delete[m] x; 
      } 
   }

   // Процедура построчной печати прямоугольной матрицы
   
   void matrixp(type **x, int m, int n) { 
      if (x!=NULL) {
         for (int i=0; i &lt; m; i++) { 
            printf(&quot;\n%3d) &quot;,i); 
            for (int j=0; j &lt; n; j++) 
               printf(&quot; %6d&quot;,x[i][j]); 
         } 
      } 
   }
      
   void main() {
      int m=4, // Количество строк матрицы 
      n=5; // Количество столбцов матрицы
      type **x=matrixn(m,n); // Создание матрицы x[m][n]
      if (x!=NULL) {

   // Заполнение матрицы номерами ее элементов
         for (int k=0, i=0; i&lt;m; i++) { 
            for (int j=0; j&lt;n; j++) 
               x[i][j]=k++; 
         } 
         matrixp(x,m,n); // Печать матрицы x[m][n]
         matrixd(x,m,n); // Уничтожение матрицы x[m][n] 
      } 
   }</div>  </pre>
      <p>Результаты работы программы:
      <pre>  0)       0      1      2      3      4
  1)       5      6      7      8      9
  2)      10     11     12     13     14
  3)      15     16     17     18     19
</pre>
<a href="1_13.exe">Выполнить</a>
      <p>Оценка возможности
      размещения объектов в памяти может быть
      проведена библиотечной функцией coreleft().
      Следует учитывать, что в процессе
      захвата и освобождения памяти &quot;сборка
      мусора&quot; не производится. В
      большинстве систем программирования
      память выделяется из единого стека
      свободной памяти. Во избежание
      фрагментации памяти, возникающей при
      случайном характере освобождения
      захваченных областей, рекомендуется в
      критических по памяти программах
      создавать отдельные модули
      высокоуровневого управления памятью с
      учетом специфики конкретной задачи. Для
      сокращения расхода памяти на блоки
      управления памятью следует уменьшать
      количество захватываемых областей.
<p>
  <div class="header"><a name="REF_1_1_14">1.14 Пространства имён</div>
<p>
Пространство имён определяет область видимости имён объектов, которые не входят ни в один блок. Пространство имён не может быть определено внутри блока.
<p>
Синтаксис:
<pre>
namespace	имя_пространства_имён     
{
	область описания и определения объектов
}
</pre>
<p>
<pre><div class="code">
namespace	MyNames	// main.cpp
{
	int	m;
	int	add(int a, int b);
	{
		return(a+b);
	}
}
</pre>
<p>
Пространства имён открыты, то есть одно и то же пространство имён можно расширять в разных исходных файлах. 
<p>
<pre><div class="code">
namespace	MyNames	//  файл  function.h
{
	int 	n;
	int 	sub(int a, int b);
}
</pre>
<p>
Пространства имён могут быть вложены друг в друга.
<p>
<pre><div class="code">
namespace	PublicNames
{
	int 	n;
	namespace	MyNames
	{
		int	 add(int a, int b);
		{
			return(a+b);
		}
	}
}
</pre>
<p>
По умолчанию существует <b>анонимное пространство имён</b>, которое доступно во всех исходных файлах и которое не нужно объявлять. Это пространство имён называется <b>глобальным</b>. Можно сказать, что все пространства имён вложены в глобальное. Все имена, которые не входят ни в одно пространство имён, принадлежат глобальному. Имена файлов стандартных библиотек С и С++ (тип файлов – .h) принадлежат глобальному пространству имён.
<p>
В каждом исходном файле можно объявить <b>локальное анонимное пространство имён</b>, которое видно только в этом файле:
<p>
Синтаксис:
<p>
<pre><div class="code">
namespace
{
	.
	.
	.
}
</pre>
<p>
По умолчанию в С существует пространство имён std, которое называется <b>стандартным</b>. Имена из новых файлов из стандартных библиотек С и С++ находятся в этом пространстве.
<p>
<pre><div class="code">
&lt;cstdlib&gt;	// C
&lt;iostream&gt;	// C++
</pre>
<p>
Для доступа к именам пространства имён используется оператор разрешения области видимости ( :: ), перед которым указывается имя нужного пространства имён. Это имя называется квалификатором.
<p>
<pre><div class="code">
#include 	&lt;iostream&gt;
#include 	“function.h”	
namespace MyNames
{
	.
	.
	.
}
int	MyNames :: sub(int a, int b)
{
	return(a-b);
}
int	main()
{
	int	sum, diff;
	MyNames :: m = 2;
	MyNames :: n = 3;
	sum = MyNames :: add(MyNames :: m, MyNames :: n);
	diff = MyNames :: sub(MyNames :: m, MyNames :: n);
	std :: cout&lt;&lt;sum&lt;&lt;std :: endl;
	std :: cout&lt;&lt;diff&lt;&lt;std :: endl;
	return(1);
}
</pre>
<p>
<pre><div class="code">
#include 	&lt;iostream&gt;
namespace PublicNames
{
	.
	.
	.
}
int	main()
{
	int	n;
	PublicNames :: n = 10;
	n = PublicNames :: MyNames :: add(PublicNames :: n, 5);
	std :: cout&lt;&lt;n&lt;&lt;std :: endl;	// 15
 return(1);
}
</pre>
<p>
Для доступа к именам из глобального пространства имён используется оператор разрешения области видимости без квалификатора. Это необходимо в случае, если глобальные имена скрыты локальными именами из неглобальной области видимости.
<p>
<pre><div class="code">
int	n = 10;
namespace 	MyNames	
{
	int	add(int n);
	{
		return(n + :: n);
	}
}

int	main()
{
	int	n = MyNames :: add(s);
	std :: cout&lt;&lt;n&lt;&lt;std :: endl;	// 15
	return(1);
}	
</pre>
<p>
Для доступа к именам из локального анонимного пространства имён оператор разрешения области видимости не используется. Доступ к именам переменных, находящихся в локальном анонимном пространстве имён, невозможен, если это имя определено в глобальном анонимном пространстве.
<p>
<pre><div class="code">
int	n = 10;
namespace 		
{
	int	n = 1;	// доступ невозможен
	int	add(int n);
	{
		return(n + :: n);
	}
}

int	main()
{
	int	n = add(5);
	std :: cout&lt;&lt;n&lt;&lt;std :: endl;	// 15
	return(1);
}
</pre>
<p>
Замечание:
оператор разрешения области видимости	выполняется на этапе компиляции программы и не влияет на её производительность.	
<p>
Для объявления имени из некоторого пространства имён используется оператор-объявление <b>using</b>, которое может находиться как в глобальной области видимости, так и внутри блока, а также в области видимости любого пространства имён.
<p>
<pre><div class="code">
#include	&lt;iostream&gt;
using	std :: cout;	// для одной функции
int	main()
{
	cout&lt;&lt;10;
	return(1);
}
</pre>
<p>
Using-объявление может использоваться также для вложенных пространств имён. 
<p>
<pre><div class="code">
#include	&lt;iostream&gt;
using	std :: cout;	
namespace	PublicNames
{
	namespace	MyNames
	{
		int	add(int a, int b);
		{
			return(a+b);
		}
	}
}

int	main()
{
	using	PublicNames :: MyNames :: add;
	cout&lt;&lt;add(2,3);
	return(1);
}
</pre>
<p>
Для объявления сразу всех имён из некоторого пространства имён используется <b>директива using</b>. 
<p>
Синтаксис:
<p>
<pre>
using	namespace	имя_пространства_имён     
</pre>
<p>
<pre><div class="code">
#include	&lt;iostream&gt;
using	namespace	std;

int	main()
{
	cout&lt;&lt;”Hello”&lt;&lt;endl;
	return 1;
}
</pre>
<p>
Правило использования директив using совпадает с правилами использования using-объявлений.
В случае вложенных пространств имён директива using с именем вложенного пространства имён не объявляет имена из объемлющего пространства имён.
<p>
Чтобы избежать дублирования для пространства имён часто выбирается длинное имя. В этом случае для удобства записи длинному имени может быть назначен короткий псевдоним.
<p>
Синтаксис:
<p>
<pre>
using	namespace	псевдоним = имя_пространства_имён     
</pre>
<p>
<pre><div class="code">
namespace	International_Business_Machines
{
	.
	.
	.
}
namespace	IBM = International_Business_Machines;
</pre>
<p>
Псевдонимы можно определять и для вложенных пространств имён. Одно пространство имён может иметь несколько псевдонимов, которые могут определяться друг через друга. Псевдонимы пространств имён используются так же, как и имена этих пространств.
    <hr width="100%" size="3">
      <p><a href="#REF_1_C">Начало</a>
<p>
      <div class="header"><a name="REF_1_2"></a>2. КЛАССЫ ОБЪЕКТОВ</div>
      <div class="header"><a name="REF_1_2_1"></a>2.1. Понятие
      класса объектов</div>
      <p>Термин &quot;класс&quot; в языке С++
      употребляется для обозначения типов
      данных, определяемых пользователем с
      ориентацией на технологию объектно-ориентированного
      программирования. В отличие от
      определяемых в стиле языка С
      производных структурированных типов,
      таких как структур или объединений,
      объявление класса позволяет, наряду с
      описанием структуры данных
      представления объектов, указать и
      аспекты использования таких данных:</p>
      <ul>
        <li>
          <p>список функций доступа к
          объектам;
        <li>
          <p>правила наследования
          объектов производными классами;
        <li>
          <p>различную степень защиты
          элементов объектов.</li>
      </ul>
      <p>Функции доступа к объектам
      класса могут переопределять
      умалчиваемые операции создания и
      уничтожения объектов, а также позволить
      обозначать различные действия над
      объектами традиционными в языке С
      символами операций.
      <p>Основная цель введения класса
      - отделение частных деталей
      представления объектов класса (скрытых
      данных и вспомогательных функций) от
      элементов, присущих объекту при
      правильном его использовании (открытые
      данные и функции доступа к любым данным).
      Пользователь класса может оперировать в
      программе его высокоуровневым внешним
      представлением, а контроль за
      корректностью использования данных и
      функций возлагается на компилятор.
      <p>В языке С++ определение
      классов ведется посредством расширения
      понятий структуры (struct) и обьединения (union).
      Традиционная для языка С интерпретация
      таких понятий остается в силе, что
      позволяет использовать программы на
      языке С без изменения исходного текста.</p>
      <p>Синтаксис определения класса
      на языке С++ имеет вид
        <pre><div class="code">   вид_класса имя_класса {
      описание_элементов_класса
     };
</div></pre>
      <p>Определение класса
      представляет лишь описание некоторого
      типа объектов, имя которого &quot;вид_класса
      имя_класса&quot;. Между символами '}' и ';'
      можно разместить список имен
      определяемых объектов класса с
      использованием, при необходимости,
      операции инициализации. Вне оператора
      определения класса объекты
      определяются операторами декларации
      вида
        <pre><div class="code">   вид_класса имя_класса список_имен_объектов;
</div></pre>
      <p>В большинстве случаев
      наиболее целесообразно определение
      класса и его элементов поместить в
      отдельный заголовочный файл.
      <p>Рассмотрим подробнее
      элементы оператора определения класса.
      <p>Элемент &quot;вид_класса&quot;
      может принимать значения struct, union или class.
      Напомним, что различие между
      структурами и объединениями
      заключается в способе размещения их
      элементов в памяти - элементы структур
      располагаются последовательно, а
      элементы объединений размещаются от
      начального адреса одной и той же области,
      достаточной для размещения наибольшего
      из них.
      <p>Необязательный для классов
      вида struct и union элемент &quot;имя класса&quot;
      задается идентификатором. Ввиду
      однозначности соответствия имени
      класса его виду при ссылке на тип класса
      элемент &quot;вид класса&quot; в языке С++
      обычно опускается даже для структур и
      объединений. Например, пусть описана
      структура
        <pre><div class="code">     
   struct subject {
      char fio[80];
      int dolg;
   };</div>
     </pre>
     <p>Примеры ссылок на такой тип
      данных в стиле языка С:
<pre><div class="code">
   struct subject teacher, *student;
   student=(struct subject *)malloc(sizeof(struct subject));
      </div></pre>
      <p>В стиле языка С++ последние
      выражения допускается записывать в виде:
      <pre><div class="code">
   subject teacher, *student;
   student=(subject *)malloc(sizeof(subject));
</div></pre>
      <p>Описание элементов класса
      может в общем случае включать
      декларацию элементов данных
      представления объекта и/или функций
      доступа к данным с указанием атрибутов
      права доступа. Иногда элементами
      являются описания собственных типов
      класса (например, структурированных
      типов объектов и перечислений).
      Принципиально возможно использование
      вложенных классов.
      <p>Элементы класса могут иметь
      один из атрибутов права доступа:</p>
      <p>private (локальный) - доступ
      только из функций доступа внутри класса;
      <p>protected (защищенный) - доступ из
      функций доступа внутри класса и
      производных классов;
      <p>public (глобальный) - доступ из
      любых функций (элементы интерфейса
      пользователя класса).
      <p>Элементы класса вида union могут
      иметь только атрибут доступа public.
      Различие между классами видов struct и class
      лишь в значении по умолчанию атрибутов
      доступа: элементы класса вида struct имеют
      атрибут public, а класса вида class - private.
      <p>Явное назначение атрибута
      доступа к элементам класса оформляется
      записью перед описанием элементов
      ключевого слова private, protected или public и
      символа ':' (для последующих элементов с
      совпадающим атрибутом доступа
      повторение описания этого атрибута не
      обязательно):
      <pre><div class="code">
   class date {
 
   // Описание собственных типов класса
    
      enum date_month={ // по умолчанию атрибут доступа private 
          January=1, February, March, April, May, June, 
          July, August, September, October, November, December };

   // Декларация элементов данных класса

      int day, month, year; // private
   public: // изменение атрибута доступа

   // Описание функций-элементов

      void set(int, int, int); // public 
      void next(); // public 
   protected: // изменение атрибута доступа
      void print(); // protected 
   };
</div></pre>
Очевидно, что декларация структуры
<pre><div class="code">
   struct name { type xxx; .... }
</div></pre>
эквивалентна декларации класса
<pre><div class="code">	
   class name {
   public:
      type xxx;
      ....
   }</div>  </pre>
      <p>Элементы данных класса
      описываются обычным образом, но
      описание функций доступа может
      потребовать отражения их
      дополнительных свойств по отношению к
      классу.</p>
      <ul>
        <p>По отношению к праву доступа
        к защищенным элементам класса
        различают:</p>
        <li>
          <p><a href="#REF_1_2_2">функции-элементы</a>;</p>
        <li>
          <p><a href="#REF_1_2_4">дружественные
          функции</a> класса.</p>
        </li>
      </ul>
      <p>&nbsp;</p>
      <ul>
        <p>Среди функций, имеющих право
        доступа, можно выделить:</p>
        <li>
          <p><a href="#REF_1_2_5">функции-конструкторы</a>
          - создание объектов;</p>
        <li>
          <p><a href="#REF_1_2_5">функции-деструкторы</a>
          - уничтожение объектов;</p>
        <li>
          <p><a href="#REF_1_3_1">функции
          определения</a> операций над объектами.</p>
        </li>
      </ul>
      <p>&nbsp;</p>
      <p>Функции-элементы и
      дружественные функции, перечисленные в
      описании класса, имеют право доступа ко
      всем элементам класса и всем глобальным
      элементам вне класса. Функции-элементы
      находятся в области действия класса и
      вызываются с помощью операции выбора
      элемента структуры.
      <p>Дружественные функции не
      находятся в области действия класса и
      вызываются по общим правилам.
      <p>Внешние функции имеют право
      доступа только к открытым элементам
      класса.</p>
      <p>Особенности построения и
      использования функций доступа,ссылок на
      элементы класса и размещения их в памяти,
      а также правила построения производных
      классов рассматриваются ниже.
      <p>Определение класса должно
      быть глобальным. Иногда требуется
      упреждающая ссылка на имя некоторого
      класса class_name до его фактического
      определения. В исходном тексте можно
      использовать предварительное описание
        <pre><div class="code">
   class [__single_inheritance] class_name;
   class [__multiple_inheritance] class_name;
   class [__virtual_inheritance] class_name;</div> </pre>
        <pre><div class="code">
   class __single_inheritance S;
   int S::*p;
  </div></pre>
      <div class="header"><a name="REF_1_2_2"></a>2.2. Функции-элементы</h3>
      </div>
      <p>Функции, описания либо
      определения которых помещены в тело
      оператора определения класса, ранее
      названы функциями-элементами такого
      класса. Принципиальное отличие функций-элементов
      от обычных функций, декларированных вне
      какого-либо класса, состоит в том, что
      функции-элементы могут вызываться
      только для работы с объектами
      соответствующего месту их описания типа.
      Пусть понятие даты в стиле языка С
      задано структурой
        <pre><div class="code">     
   struct date { // дата:
      int   day,  //  день,
      month,  //  месяц,
      year;  //  год
   };</div> </pre>
      <p>Предположим, что для работы с
      объектами типа date используется
      множество функций:
        <pre><div class="code">
   void set_date(date *, int, int, int); // установка даты
   void next_date(date *); // получение даты следующего дня
   void print_date(date *); // печать даты
</div>   </pre>
      <p>Очевидно, что явной связи
      между функциями и типом данных,
      контролирумой транслятором, здесь нет.
      Элементы структуры типа date доступны
      любой функции. Перепишем определение
      структуры date, учитывая понятие класса в
      языке С++:
        <pre><div class="code">     
   struct date {
   // описание элементов данных
      int day, month, year;              // public
   // описание функций-элементов
      void set(int, int, int);           // public
      date&amp; next();                      // public
      void print();                      // public
   };
</div> </pre>
      <p>Здесь данные и функции по
      прежнему доступны из любой внешней
      функции, но использование перечисленных
      в блоке определения класса функций
      транслятор может контролировать.
      Приведем пример программы по оценке
      влияния наличия функций-элементов на
      размер структуры: 
<pre><div class="code">
   #include &lt;stdio.h&gt;
   
   struct c1 { // Структура без функций-элементов
      int x,y,z; 
   };
   
   struct c2 { // Структура с функциями-элементами
      int x,y,z; 
      void print(); 
      void set(); 
   };

   #define P(X) printf(&quot;\n Sizeof(%s)=%d&quot;,#X,sizeof(X))

   void main() { 
      P(c1); 
      P(c2); 
   } </div> </pre>
      Результаты работы программы:
      <pre> 
   Sizeof(c1)=12
   Sizeof(c2)=12
</pre>
<a href="2_2_1.exe">Выполнить</a>
      <p>Можно заметить, что наличие
      функций-элементов в рассмотренном
      простейшем варианте класса не вызывает
      увеличения размера объектов. Независимо
      от количества объектов некоторого
      класса, его функции-элементы в модуле
      программы присутствуют в единственном
      экземпляре (на механизм встраивания
      функций внимание можно не обращать).
      Перейдем к рассмотрению особенностей
      вызова и построения функций-элементов.
      Вызов функций-элементов реализуется
      использованием стандартного для языка С
      синтаксиса доступа к элементам
      структуры:
  <pre><div class="code">
   date today;
   date next_day;
   date *test_day=new date;
	
   void f() { // непосредственный выбор функций-элементов 
      today.set(1,9,1992); 
      next_day=today.next();
      today.print(); // косвенный выбор функции-элемента
      test_day-&gt;print(); 
   }</div>  </pre>
      <p>Обращения к функциям вида
        <pre><div class="code">
   set(19,01,1992);
</div> </pre>
      <p>без указания имени или
      косвенной ссылки на объект требуемого
      типа транслятор будет считать
      относящимися к внешне определенным
      функциям. Таким образом, использование
      функции-элемента становится возможным
      только после явного или косвенного
      определения объекта класса. Операция
      вызова функции-элемента оказывается
      привязанной к экземпляру объекта класса,
      но функция-элемент имеет доступ к любым
      открытым функциям и данным вне класса.
      Отсюда следует, что устанавливается
      ограничение доступа к элементам класса:
      функция-элемент может использовать
      любые данные и функции, но закрытые
      элементы класса доступны только
      функциям-элементам класса. Чаще всего
      интерфейс пользователя класса удобно
      определить набором функций-элементов с
      атрибутом доступа public, а элементы-данные
      и вспомогательные функции скрыть.
      Декларация функций-элементов допустима
      как в форме описания, так и в форме
      определения. Никаких ограничений на
      возможности декларации (переопределение,
      установка параметров по умолчанию и т.п.)
      нет. Определяемым в блоке любого класса
      функциям-элементам автоматически
      приписывается атрибут inline. Если
      некоторой функции-элементу атрибут inline
      не может быть назначен <a href="#REF_1_1_12">(см.
      1.12)</a>, то для исключения выдачи
      диагностических сообщений транслятора
      определение такой функции приходится
      размещать вне блока класса. Пример
      определения функции-элемента в описании
      объединения:
        <pre><div class="code">     
   union word {
   // декларация элементов данных
      int i;                   // public
      char b[2];               // public
// декларация функций-элементов
      void print();            // public, описание
      void set(int x) {i=x};   // public, определение
   };
</div></pre>
      <p>Поскольку разные классы могут
      иметь функции-элементы с одинаковыми
      именами, то при определении функции-элемента
      вне описания класса необходимо
      указывать имя класса:
        <pre><div class="code">     
   void date::print() {
      printf(&quot;%02d.%02d.%d&quot;,day,month,year);
   }
   void word::print() { printf(&quot;%04x&lt;==&gt;%02x%02x&quot;,i,b[0],b[1]); }
</div> </pre>
      <p>Символы &quot;::&quot; здесь
      обозначают бинарную операцию привязки
      имени к элементам класса или, как иногда
      говорят, разрешения его видимости в
      некотором классе. Синтаксис бинарной
      операции привязки:
        <pre><div class="code">   &lt;имя_класса&gt;::&lt;имя_члена_класса&gt;
</div>  </pre>
      <p>Отсутствие имени класса
      означает обращение к имени глобального
      объекта программы <a href="#REF_1_1_4">(см.
      1.4)</a>. В теле функции-элемента имена
      элементов класса могут использоваться
      без явной ссылки на объект. В этом случае
      имя относится к элементу того объекта,
      для которого функция была вызвана (например,
      функции word::set, date::print, word::print). В случае же
      использования при определении функции-элемента
      имен локальных объектов, совпадающих с
      именами элементов класса необходимо
      явно применить операцию привязки
      &quot;::&quot;. Пример использования операции
      привязки: 
<pre><div class="code"> 
   #include &lt;stdio.h&gt;
   
   int n=-1; // глобальная переменная
   class x { 
      int m; 
   public: 
      void set_m(int m=::n) { // использование глобального n 
         x::m=m; // m - имя элемента класса и параметра функции 
      }; 
      int readm() { 
         return m; // m - имя элемента класса
      } 
   };
   
   x a, b;
   
   void main() { 
      a.set_m(); // инициализация a.m
      b.set_m(0); // инициализация b.m 
      int a = ::a.readm(); // a=::a.m; 
      int b = ::b.readm(); // b=::b.m -?; // ... 
      printf(&quot;\n a=%d, b=%d&quot;,a,b); 
   }</div> </pre>
   Результаты работы программы:
        <pre> a=-1, b=0
</pre>
<a href="2_2_2.exe">Выполнить</a>
      <p>Таким образом, в операторном
      блоке тела функции-элемента имена
      нелокальных объектов по умолчанию
      считаются дополненными справа именем
      соответствующего класса и парой
      двоеточий. Операция привязки может
      применяться для ссылок на определения
      любых объектов класса, например:
        <pre><div class="code">     
   class abc {
   public:
      enum { // множество кодов ошибок
      overflow, underflow, zerodivide
      };
      // ...
   };
   // ...
   void f(int e) { // функция обработки ошибок
      switch (e) {
         case abc::overflow:   /* ... */
         case abc::underflow:  /* ... */
         case abc::zerodivide: /* ... */
      }
   }</div> </pre>
      <p>Рассмотренный способ
      привязки имен элементов класса основан
      на понятии типа объекта. Кроме этого,
      язык С++ предоставляет возможность
      привязки имен на основе понятия
      экземпляра объекта.
      <p>В каждую нестатическую
      функцию-элемент класса X неявно
      передается скрытый параметр X *const this,
      ссылающийся на объект, для которого
      выполнена операция вызова (переопределить
      идентификатор this нельзя, так как это
      ключевое слово языка С++).</p>
      <p>Приведем другое определение
      класса x:
        <pre><div class="code">     
   class x {
      int m;
   public:
      void set_m(int m=::n) {  // использование глобального n
         this-&gt;m=m;  // m - имя параметра и элемента класса
      };
      int readm() { return this-&gt;m; }
   };</div> </pre>
      <p>Cсылка на элементы класса с
      использованием указателя this - другая
      альтернатива устранения коллизии имен.
      Реальная потребность обращения к this
      возникает лишь при необходимости работы
      непосредственно с указателями объектов.
      Пример использования указателя this при
      построении симметричного (двухсвязного)
      списка:
<pre><div class="code">
   // Определение класса элементов симметричного списка
   class double_list { 
      // ... 
      double_list *prec; // указатель предшествующего элемента
      double_list *next; // указатель следующего элемента 
      // ... 
   public: 
      void append(double_list *); 
      // ... 
   };

   // Определение функции включения элемента 
   // симметричного списка

   void double_list::append(double_list *p) { 
      p-&gt;next = next; // p-&gt;next = this-&gt;next 
      p-&gt;prec = this; 
      next-&gt;prec = p; // this-&gt;next-&gt;prec = p 
      next = p; // this-&gt;next = p 
   }

   // Определение указателя симметричного списка
 
   double_list* head; // глобальная переменная

   // Пример функции создания симметричного списка

   void f() { 
      double_list x1, x2; 
      // ... 
      head-&gt;append(&amp;x1); // включить x1 
      head-&gt;append(&amp;x2); // включить x2 
   } </div></pre>
      <p>Здесь следует отметить, что
      единицей защиты в C++ является класс, а не
      отдельный объект класса. Обьекты,
      адресуемые указателями this, prec и next,
      относятся к классу double_list, поэтому
      функции double_list::append() одновременно
      доступен любой из них. В последнем
      примере указатель списка head не может
      быть модифицирован, поэтому при пустом
      списке, когда (head==NULL), функция double_list::append
      будет работать неверно. Возникает
      потребность в использовании общих
      элементов данных, относящихся ко всем
      объектам класса. Такими элементами
      могут быть либо глобальные переменные
      либо статические элементы класса <a href="#REF_1_2_3">(см.
      2.3)</a>. Изменение указателя this как
      указателя-константы функцией-элементом
      не допускается. Если объект, адресуемый
      указателем this, также не должен
      изменяться при вызове некоторой функции-элемента,
      то такую функцию следует описать с
      ключевым словом const после списка
      параметров. Это приведет к построению
      описания указателя объекта класса X в
      виде
        <pre><div class="code">     
   const X *const this;
</div> </pre>
      <p>Пример программы с запретом
      изменения объекта:
        <pre><div class="code">     
   class X {
      int x;
   public:
   // функция с запретом изменения объекта
      int read() const {
         return x;
      }
   // функция без запрета изменения объекта
      void write(int i) {
         x=i;
      }
   };
   
   X var; // декларация объекта-переменной
   const X fix; // декларация объекта-константы

   void main() { 
      // ... 
      var.read(); // разрешенное действие 
      var.write(1); // разрешенное действие 
      fix.read(); // разрешенное действие 
      fix.write(1); // ошибка - попытка изменения объекта 
      // ... 
   }</div> </pre>
      <p>Если некоторая функция-элемент
      представлена в блоке класса описанием,
      то обсуждаемый здесь модификатор const
      должен использоваться как в определении,
      так и в описании функции. В противном
      случае декларируемые функции будут
      считаться переопределенными. Обсудим
      возможность использования указателей
      на функции-элементы. Указатели-переменные
      на элементы класса X должны иметь
      модификатор описания вида X::* вместо
      обычно используемого при декларации
      указателя символа '*'. Значение указателю-переменной
      можно присвоить оператором определения
      адреса &amp; по имени элемента класса с
      привязкой к имени класса. Установка
      связи указателя на элемент класса с
      объектом возможна посредством
      специфичных для языка С++ операций .* и -&gt;*
      (косвенная адресация элемента класса
      при прямой или косвенной адресации
      объекта). Пример программы с
      использованием указателей на элементы
      класса: 
<pre><div class="code">
   #include &lt;stdio.h&gt;
   class alpha { 
      int x, y; 
   public: 
      void set(int i) { y=x=i; } 
      void print(char *s) { printf(&quot;\n%s: x=%d y=%d&quot;,s,x,y); } 
   };

   void main() { 
      alpha obj; // определение объекта
      obj.set(1); 
      obj.print(&quot;Вариант 1:&quot;); // Прямой вызов функции-элемента
 
   // Декларация указателя-переменной func на функцию-элемент

      void (alpha::*func)(char *);

      func=& alpha::print; // func указывает на функцию alpha::print 
      obj.set(2); 
      (obj.*func)(&quot;Вариант 2:&quot;); // Косвенный вызов функции-элемента
           
      alpha *p=&obj; // Декларация указателя на объект 
      obj.set(3); 
      (p-&gt;*func)(&quot;Вариант 3:&quot;); // Косвенный вызов функции-элемента
               
   // Декларация указателя-переменной dptr на элемент данных класса alpha

      typedef int alpha::* Int; // Введение имени сложного типа

      Int dptr=(Int)&obj.y; // Приведение типа требует компилятор?!

      (*dptr)++; 
      (p-&gt;*func)(&quot;Вариант 4&quot;);
      printf(&quot; (*dptr=%d)&quot;,*dptr);

   // Декларация указателя-переменной dint на элемент данных типа int

      int *dint=(int *)&obj.y; // Приведение типа требует компилятор... 
      (*dint)++; 
      (p-&gt;*func)(&quot;Вариант 5&quot;); 
      printf(&quot; (*dint=%d)&quot;,*dint); 
   }</div> </pre>
      <p>Результаты работы программы:
        <pre>   Вариант 1: x=1, y=1
   Вариант 2: x=2, y=2
   Вариант 3: x=3, y=3
   Вариант 4: x=3, y=4 (*dptr=4)
   Вариант 5: x=3, y=5 (*dint=5)
</pre>
      <p>Элементы объекта класса
      оказались модифицированными, но после
      явного приведения типов.
      <p>
      <div class="header"><a name="REF_1_2_3"></a>2.3. Статические
      элементы класса</div>
      <p>Элементы класса (функции и
      данные), объявляемые с дополнительным
      атрибутом static, называются статическими.
      Статический элемент данных, независимо
      от количества объектов, будет размещен в
      единственном экземпляре в статической
      памяти и инициализирован один раз (по
      умолчанию, поле статического элемента
      заполняется нулями). Таким образом,
      предоставляется возможность
      использования общих переменных для всех
      объектов класса, а потребность в
      глобальных переменных сокращается.
      Статическая функция-элемент не
      привязана к объектам класса. Указатель
      this ей непередается, поэтому она имеет
      доступ только к статическим элементам
      класса. Такая функция может быть вызвана
      при отсутствии объектов класса. В любых
      функциях-элементах класса именование
      статических элементов ведется обычным
      образом, но для обращения к открытым
      элементам такого вида извне их имена
      дополняются слева именем класса и
      символами операции привязки &quot;::&quot;.
      Рассмотрим пример использования
      статических элементов: 
<pre><div class="code">
   #include &lt;stdio.h&gt;
   #include &lt;string.h&gt;
   class list { // список строк: 
      static list *head; // указатель списка 
      static int size; // размер буфера строк 
      list *next; // указатель следующего элемента 
      char *data; // указатель поля данных 
   public: 
      void append(char *item) { // добавление строки 
         int n=strlen(item)+1; 
         next=head, head=this;
         data=new char[n]; 
         strcpy(data,item); 
         if (size&gt;n) size=n; 
      } 
      static void print() { // вывод списка строк 
         int i=0; 
         for (list *item=head;item!=NULL; item=item-&gt;next) 
            printf(&quot;\n %4d) %*s&quot;,++i,size,item-&gt;data);
      } 
      static int isempty() { // проверка наличия списка строк 
         return (head==NULL); 
      } 
   }; 
   
   list *list::head = NULL; 
   int list::size = 0; 
   
   void main () { 
      (new list)-&gt;append(&quot;КАФЕДРА&quot;);
      (new list)-&gt;append(&quot;ФАКУЛЬТЕТ&quot;); 
      (new list)-&gt;append(&quot;ВУЗ&quot;);
      if (!list::isempty()) { 
         printf(&quot;\nСПИСОК ПОДРАЗДЕЛЕНИЙ:\n&quot;); 
         list::print(); 
      } 
   }</div> </pre>
      <p>Результаты работы программы:
        <pre>   СПИСОК ПОДРАЗДЕЛЕНИЙ:
   1) ВУЗ 2) ФАКУЛЬТЕТ 3) КАФЕДРА</pre>
<a href="2_3.exe">Выполнить</a>
      <p>Можно еще раз обратить
      внимание на использование функции-элемента
      list::append - указатель this получается в
      результате операции захвата памяти.
      <p>Статические элементы данных -
      средство контроля за количеством
      объектов.
      <p>
      <div class="header"><a name="REF_1_2_4"></a>2.4. Дружественные
      функции класса</div>
      <p><strong>Дружественной</strong>
      называется объявленная в классе функция
      с атрибутом friend, которая, не являясь
      элементом класса, может использовать
      его любые элементы. Декларация
      дружественной функции может
      проводиться в любом месте описания
      класса. Декларация может проводиться в
      форме описания и/или определения с
      использованием всех возможностей языка
      С++. При определении дружественной
      функции в классе ей автоматически
      приписывается атрибут inline.
      Дружественная функция не привязана к
      объектам класса. Указатель this ей, как и
      статическим функциям-элементам, не
      передается. Операция вызова
      дружественной функции не использует
      синтаксис выбора элемента структуры, а
      записывается в обычной форме.
      Иллюстрация различия между функцией-элементом
      и дружественной функцией класса:
      <pre><div class="code">
   class example {
      int a;
   
   // Описание дружественной функции (может быть в любом месте)
	
      friend void friend_set (example *, int); 
   public: 
      void member_set (int); 
   };
      
   // Определение дружественной функции

   void friend_set(example *p,int i) { p-&gt;a = i; }

   // Определение функции-элемента

   void example::member_set(int i) { 
      a = i; // example::a=i; &lt;===&gt; this-&gt;a=i; 
   }

   example object; // декларация объекта
   void f() {

   // Эквивалентные по действию операторы

      friend_set(&amp;object,1992); // вызов дружественной функции 
      object.member_set(1992); // вызов функции-элемента 
   }</div> </pre>
      <p>Функция-элемент одного класса
      может быть дружественной другому классу:
      <pre><div class="code">
   class x {
      // ...
      void f(); // любой атрибут доступа
   };

   class y { 
      // ...
      friend void x::f(); // разрешение доступа к любым  
                          // элементам класса y функции x::f()
   };      </div></pre>
      <p>Если все функции класса X
      дружественны классy Y, то можно
      использовать сокращение вида
        <pre><div class="code">        
   class Y {
      friend X;
      // ...
   };</div> </pre>
      <p>Таким образом, дружественные
      функции могут использоваться для связи
      элементов разных классов.
      Принципиальное различие между
      функциями-элементами и дружественными
      функциями лишь в синтаксисе доступа к
      элементам класса. Предпочтение в
      использовании того или иного вида
      функций чаще всего определяется
      контекстом их использования. Лишь
      некоторые виды функций доступа (например,
      конструкторы и деструкторы) обязательно
      должны быть элементами класса.
<p>
      <div class="header"><a name="REF_1_2_5"></a>2.5. Конструкторы
      и деструкторы объектов</div>
      <p>Существование в программе
      объекта любого типа определяется по
      отношению к его наличию и доступности в
      памяти:</p>
      <ul>
        <li>
          <p>автоматический объект -
          создается каждый раз при выполнении
          программы в точке объявления и
          уничтожается при выходе из блока, в
          котором он используется;
        <li>
          <p>статический объект -
          создается один раз при запуске
          программы и уничтожается один раз при
          ее завершении;
        <li>
          <p>объект в свободной памяти -
          создается с помощью операции new и
          уничтожается с помощью операции delete
          либо при завершении программы.</li>
      </ul>
      <p>Строго говоря, автоматический
      объект может быть создан в любом
      выражении при явном либо неявном
      применении операции приведения типа, а
      также в момент формирования элемента
      списка параметров и возвращаемого
      значения функции.
      <p>Создание объекта, по крайней
      мере, включает операцию выделения
      памяти и, при необходимости, операцию
      инициализации полей данных. Уничтожение
      объекта означает отказ от использования
      занимаемой им памяти. В современном
      языке C++ интервал существования объекта
      класса в памяти ассоциируется с вызовом
      функций, называемых конструкторами и
      деструкторами. Вызов таких функций
      организуется компилятором в местах
      декларации объекта, конца блока или
      операции приведения типа, а также при
      выполнении операций new и delete. Говорят,
      что конструктор и деструктор создают
      функциональное замыкание интервала
      существования объекта класса в памяти. В
      языке С++ конструкторы и деструкторы
      объектов определяемых пользователем
      классов <strong>могут</strong> объявляться явно
      в описании класса.
      <p>
      <p><strong>Конструктор</strong> -
      функция-элемент класса, имя которой
      совпадает с именем класса. Конструкторы
      могут быть переопределенными, иметь
      параметры по умолчанию, но не должны
      возвращать результат.</p>
      <p><strong>Деструктор</strong> - функция-элемент
      класса, имя которой совпадает с именем
      класса, но дополнено слева символом '~' (символ
      '~' не является допустимым для создания
      идентификатора объекта другого
      назначения). Деструктор не может быть
      переопределен, не должен иметь
      параметры и возвращать результат.</p>
      <p>Пример использования
      конструктора и деструктора: <pre><div class="code">
   #include &lt;stdio.h&gt;
   #include &lt;string.h&gt;
   class simple { 
      char *name; 
   public: 
      void print() { // отображение объекта 
         printf(&quot;\n*** Обьект \&quot;%s\&quot; существует&quot;,name); 
      } 
      simple(char *x) { // конструктор 
         printf(&quot;\nСоздание объекта \&quot;%s\&quot;&quot;,x);
         name=new char[strlen(x)+1]; 
         strcpy(name,x); 
      } 
      ~simple() { // деструктор 
         printf(&quot;\nУничтожение объекта \&quot;%s\&quot;&quot;,name); 
         delete name; 
      } 
   };
   
   simple global(&quot;global&quot;);
   
   void main () { 
      printf(&quot;\n* Начало основного блока&quot;); 
      global.print(); 
      simple local_1(&quot;local_1&quot;); 
      local_1.print(); 
      simple *plocal_2=new simple(&quot;local_2&quot;);
      (*plocal_2).print(); 
     { 
        printf(&quot;\n* Начало вложенного блока&quot;); 
        simple local_3(&quot;local_3&quot;); 
        local_3.print(); 
     }
     delete plocal_2; 
     local_1.print(); 
   }</div> </pre>
      Результаты работы программы:
      <pre>   Создание объекта &quot;global&quot;
   * Начало основного блока
   *** Обьект &quot;global&quot; существует
   Создание объекта &quot;local_1&quot;
   *** Обьект &quot;local_1&quot; существует
   Создание объекта &quot;local_2&quot;
   *** Обьект &quot;local_2&quot; существует
   * Начало вложенного блока
   Создание объекта &quot;local_3&quot;
   *** Обьект &quot;local_3&quot; существует
   Уничтожение объекта &quot;local_3&quot;
   Уничтожение объекта &quot;local_2&quot;
   *** Обьект &quot;local_1&quot; существует
   Уничтожение объекта &quot;local_1&quot;
   Уничтожение объекта &quot;global&quot;
</pre>
<a href="2_5_1.exe">Выполнить</a>
      <p>Отметим, что вызов
      конструктором и деструктором в
      рассмотренном примере функций вывода
      использован лишь для пояснения их
      сущности. Наиболее часто на практике
      такие функции используются для
      управления нетривиальным
      распределением памяти и инициализации
      сложных объектов (см. элемент name). Другим
      полезным их применением может быть
      программирование неявно определяемого
      контекста среды выполнения функций и
      блоков, где декларируются объекты
      класса. Рассмотрим пример программы со
      слежением за процессом ее выполнения во
      времени на уровне выделяемых блоков.
      <p>Идея построения механизма
      слежения:</p>
      <ul>
        <li>
          <p>ввести класс agent, объекты
          которого декларируются в выделяемых
          блоках;
        <li>
          <p>предписать конструктору и
          деструктору класса agent решение задачи
          формирования отчета о существовании
          объекта такого класса во времени в
          виде линейного списка объектов класса
          report;
        <li>
          <p>ввести класс shief, объект
          которого декларируется в управляющем
          блоке программы и существует во время
          выполнения выделенных блоков, а
          деструктор ~shief отображает список
          отчета.</li>
      </ul>
      <pre><div class="code">
   // ПРИМЕР ИСПОЛЬЗОВАНИЯ КОНСТРУКТОРОВ И ДЕСТРУКТОРОВ
   
   #include &lt;stdlib.h&gt;
   #include &lt;stdio.h&gt;
   #include &lt;string.h&gt; 
   #include &lt;time.h&gt;
   #include &lt;windows.h&gt;
   class report { // отчет работы агента
      static report *head; // указатель списка 
      char *name; // имя агента 
      clock_t start, finish; // начало и конец существования агента 
      report *next; // указатель следующего отчета 
      friend class agent;
      friend class shief;
   public:
      report(char *x) { // конструктор 
         start=clock();
         name=new char[strlen(x)+1]; 
         strcpy(name,x); 
         next=head, head=this; 
      } // деструктор не использован 
   };
      
   class agent { // описание агента 
      report *link; // указатель протокола 
   public: 
      agent(char *x) {  // конструктор 
         link=new report(x); 
      } 
      ~agent() { //  деструктор 
         link-&gt;finish=clock(); 
      }
   };
   
   class shief { // описание шефа 
   public: 
      ~shief() { // деструктор 
         for (report *x=report::head; x!=NULL; x=x-&gt;next)
            printf(&quot;\n %s: S=%d, F=%d, L=%d&quot;,x-&gt;name,
               (int)x-&gt;start,(int)x-&gt;finish,
               (int)(x-&gt;finish-x-&gt;start)); 
      } 
   } Shief;
   report *report::head = 0;
   
   void main () { 
      void f1(), f2(); 
      agent  a0(&quot;A0&quot;); 
      f1(); 
      f2(); 
   }
    
   void f1() { 
      agent a1(&quot;A1&quot;); 
      sleep(1);  //  задержка на 1 сек (18 тиков) 
   } 
   
   void f2() { 
      agent a2(&quot;A2&quot;); 
      sleep(2); // задержка на 2 сек (36  тиков)  
   } </div>  </pre>
      Результаты работы программы:
      <pre>   A2: S=0, F=1492, L=1492
   A1: S=0, F=0, L=0
   A0: S=0, F=1492, L=1492
</pre>
<a href="2_5_2.exe">Выполнить</a>
      <p>Примечательно, что прикладная
      программа дополняется лишь декларацией
      объектов требуемых классов. Вызов
      функций класса в таких случаях неявным
      образом планируется компилятором.</p>
      <p>Варианты синтаксиса неявного
      вызова конструктора при декларации
      объекта:
        <pre><div class="code">
   имя_класса имя_объекта;
   имя_класса имя_объекта(параметры_конструктора);
   имя_класса имя_объекта=имя_объекта_того_же_класса;
</div> </pre>
      <p>(здесь &quot;имя_класса&quot;
      совпадает с именем конструктора).
      <p>Выбор подходящего
      конструктора среди имеющихся в классе
      производится по правилам использования
      переопределенных функций:
        <pre><div class="code">
   class X {
      // ...
      X(); // конструктор по умолчанию
      X(какие_нибудь_параметры); // конструктор общего вида
      X(X&amp;); // конструктор копирования
   };</div> </pre>
      <p>Конструктор вида X() иногда
      называют конструктором по умолчанию, а
      конструктор X(X&amp;) - конструктором
      копирования. При отсутствии таких
      конструкторов в определении класса
      автоматически создается их стандартный
      аналог.
      <p>Рассмотрим примеры
      использования конструкторов. 
<pre><div class="code">
   #include &lt;stdio.h&gt;
   #include &lt;string.h&gt;
   class complex { 
      double re, im;
      void display(int i) { 
         print(); 
         printf(&quot; [%d]&quot;,i);
      }
   public:
      complex() { // конструктор по умолчанию 
         re=im=0; 
         display(0); 
      } 
      complex(complex &amp;x) { // конструктор копирования 
         re=x.re, im=x.im; 
         display(1);
      } 
      complex(int rei, int imi) { 
         re=rei, im=imi; 
         display(2); 
      } 
      complex(int rei) { 
         re=rei, im=0; 
         display(3); 
      } // ... 
      void print() { 
         printf(&quot;\n (%.0lf, %.0lf)&quot;,re,im); 
      } 
   };
   void main () { 
      complex a;  // complex() 
      complex b=complex(1,2); // complex(int,int) 
      complex c(b);  // complex(complex &amp;) 
      complex d=b;  // complex(complex &amp;) 
      complex e(5);  // complex(int)
      a.print(); 
      b.print(); 
      c.print(); 
      d.print(); 
      e.print();
      a=d;  // операция присваивания 
      d=complex(3,4);  // присваивание complex(int,int) 
      a.print(); 
      d.print(); 
   } </div> </pre>
      Результаты работы программы:
      <pre>   (0, 0) [0]
   (1, 2) [2]
   (1, 2) [1]
   (1, 2) [1]
   (5, 0) [3]
   (0, 0)
   (1, 2)
   (1, 2)
   (1, 2)
   (5, 0)
   (3, 4) [2]
   (1, 2)
   (3, 4)</pre>
<a href="2_5_3.exe">Выполнить</a>
     <p>Явный вызов конструктора соответствует операции приведения типа в функциональной форме записи.
<p>
      <div class="header"><a name="REF_1_2_6"></a>2.6. Конструкторы
      вложенных классов</div>
      <p>Обьект любого класса может
      быть элементом другого класса. В таких
      случаях иногда возникает необходимость
      задания конструктором включающего
      класса параметров конструкторов
      элементов включаемых классов. Cхема
      описания связи параметров
      конструкторов:
      <pre><div class="code">
   class X { // описание включаемого класса
      // ...
      X (par_X); // конструктор с параметром
   };

   class Y { // описание включающего класса 
      // ... 
      // описание элементов включаемых классов 
      X elem_1; // параметры здесь указать нельзя, 
      X elem_2; // так как это только описание класса, а 
      // ... // параметры относятся к определяемым объектам 
      // определение конструктора включающего класса 
      Y (par_Y_1):elem_1(par_X_1), elem_2(par_X_2) { // ... } 
   };</div></pre>
      </div>
      <p>В <strong>определении</strong>
      конструктора включающего класса после
      символа ':' записывается в произвольном
      порядке список элементов включаемых
      классов с указанием в круглых скобках
      параметров их конструкторов.
      Конструкторы включаемых элементов
      будут вызваны перед конструктором
      включающего класса. Порядок вызова
      конструкторов элементов не определен,
      поэтому список параметровне должен
      содержать взаимосвязанные выражения
      присваивания.
      <p>Пример программы: 
<pre><div class="code">
   #include &lt;stdio.h&gt;
   #include &lt;string.h&gt;
   class string { 
      char *buffer; int length;
   public:
      string(int n=80) {
         buffer=new char[length=n]; 
         buffer[0]=0;
      } 
      ~string() {
         delete buffer; 
      } 
      void status(char *x) { 
         printf(&quot;\n%s: B=\&quot;%s\&quot;, L=%d&quot;,x,buffer,length); 
      } 
   };
   class primer { 
      string s1; string s2;
   public: 
      primer(int, int);
      void test() { 
         s1.status(&quot;s1&quot;);
         s2.status(&quot;s2&quot;); 
      } 
   };
   primer::primer(int l1, int l2): s1(l1), s2(l2) { 
      printf(&quot;\n* %d %d&quot;,l1,l2); 
   }
   
   void main () { 
      primer exam(10,20); 
      exam.test(); 
   }</div> </pre>
      Результаты работы программы:
      <pre>   * 10 20
   s1: B=&quot;&quot;, L=10
   s2: B=&quot;&quot;, L=20
</pre>
<a href="2_6.exe">Выполнить</a>
      <p>В качестве представителей
      вложенных классов могут
      рассматриваться элементы базовых типов,
      поэтому определение конструктора в
      классе
      <pre><div class="code">     
   class alpha {
      int i;
      clock_t s;
   public:
      alpha():i(0),s(clock()) { printf(&quot;\n i=%d, s=%d&quot;,i,s); }
      ~alpha() { printf(&quot;\n l=%d&quot;,clock()-s); }
   };</div></pre>
      <p>эквивалентно следующему
      варианту с операторами присваивания
      <pre><div class="code">     
   alpha() {
      i=0;
      s=clock();
      printf(&quot;\n i=%d, s=%d&quot;,i,s);
   }</div></pre>
      <p>Этим обстоятельством можно
      воспользоваться для повышения
      лаконичности исходного текста
      программы.
      <p>
      <div class="header"><a name="REF_1_2_7"></a>2.7.
      Конструирование массивов объектов</div>
      <p>Особенность создания
      массивов объектов любого класса -
      раздельный вызов конструктора для
      каждого элемента массива. При
      необходимости декларации массива
      объектов класса с конструктором
      конструктор не должен иметь список
      параметров. Используемые в подобных
      ситуациях параметры приходится
      передавать через глобальные переменные
      либо элементы данных класса. Деструктор
      также должен быть вызван для каждого
      элемента массива. Для массивов,
      размещенных без использования
      оператора new, это делается неявно. Однако
      для массивов в свободной памяти неявный
      вызов невозможен - компилятор не
      отличает указатель на один объект от
      указателя на первый элемент массива
      объектов. Уничтожение объектов массива
      в свободной памяти должно проводиться
      оператором delete с явным указанием
      размерности массива. Пример работы с
      массивами объектов класса: 
<pre><div class="code">
   #include &lt;stdio.h&gt;
   #include &lt;string.h&gt;
   class simple { 
      char *name;
   public:
      simple(); // описание конструктора по умолчанию
      simple(char *x) { // конструктор с параметром 
         printf(&quot;\nСоздание объекта \&quot;%s\&quot;&quot;,x);
         name=new char[strlen(x)+1]; 
         strcpy(name,x); 
      }
          	
      ~simple() { // деструктор 
         printf(&quot;\nУничтожение объекта \&quot;%s\&quot;&quot;,name); 
         delete name; 
      }
	
      void print() { // отображение объекта
         printf(&quot;\n*** Обьект \&quot;%s\&quot; существует&quot;,name);
      } 
   };

   simple::simple() { // определение конструктора по умолчанию 
      static int i=0; 
      if ((name=new char[80])!=NULL) { 
         sprintf(name,&quot;Элемент %d&quot;,i++); 
         printf(&quot;\n %s создан&quot;,name); 
      } 
   }
      
   simple global(&quot;global&quot;);
      
   void main () { 
      printf(&quot;\n* Начало блока программы&quot;);
 
   // Работа с массивом фиксированной размерности
      
      simple a[3]; // размерность массива должна быть 
                   // задана константным выражением
      for (int i=0; i&lt;SIZEOF(A)/sizeof(*a); a[i++].print())

   // Работа с массивом переменной размерности

      int n=2; // значение размерности массива 
      simple *b=new simple[n]; 
      for (i=0;  i&lt;N; b[i++].print()); 
      delete[n] b;
   }</div> </pre>
      Результаты работы программы:
      <pre>   Создание объекта &quot;global&quot;
   * Начало блока программы
   Элемент 0 создан
   Элемент 1 создан
   Элемент 2 создан
   *** Обьект &quot;Элемент 0&quot; существует
   *** Обьект &quot;Элемент 1&quot; существует
   *** Обьект &quot;Элемент 2&quot; существует
   Элемент 3 создан
   Элемент 4 создан
   *** Обьект &quot;Элемент 3&quot; существует
   *** Обьект &quot;Элемент 4&quot; существует
   Уничтожение объекта &quot;Элемент 3&quot;
   Уничтожение объекта &quot;Элемент 4&quot;
   Уничтожение объекта &quot;Элемент 0&quot;
   Уничтожение объекта &quot;Элемент 1&quot;
   Уничтожение объекта &quot;Элемент 2&quot;
   Уничтожение объекта &quot;global&quot;
</pre> 
<a href="2_7.exe">Выполнить</a>
      <p>Можно заметить, что элементы массива обрабатываются <strong>последовательно</strong>.
      <p>
<div class="header"><a name="REF_1_2_8"></a>2.8.
      Конструирование статических объектов</div>
      <p>Конструкторы глобальных
      статических объектов вызываются в
      порядке определения объектов перед
      выполнением программы, а их деструкторы
      - в обратной последовательности при
      завершении программ. Конструкторы
      локальных статических объектов
      вызываются всегда после конструкторов
      глобальных объектов, но порядок их
      вызова зависит от порядка активизации
      блоков. При неоднократной активизации
      блока с локальным статическим объектом
      его конструктор вызывается только при
      первой активизации. Пример
      использования статических объектов: 
<pre><div class="code">
   #include &lt;stdio.h&gt;
   class x { 
      int i; 
   public: 
      x(int j=0) { 
         printf(&quot;\nСоздание: %d&quot;,i=j); 
      } 
      ~x() { 
         printf(&quot;\nУничтожение: %d&quot;,i);
      } 
   };
   void f1() { 
      static x a(1); 
      x aa(11); // ... 
   }
   void f2(int n) { 
      static x a(n&gt;&gt;1); // конструктор будет вызван один раз! 
      x aa(22); // ... 
   }
   x c;
   
   void main () { 
      x b(3); 
      f2(10); 
      f2(20); 
   }</div>  </pre>
      Результаты работы программы:
      <pre>   Создание: 0
   Создание: 3
   Создание: 5
   Создание: 22
   Уничтожение: 22
   Создание: 22
   Уничтожение: 22
   Уничтожение: 3
   Уничтожение: 0
   Уничтожение: 5
</pre>
<a href="2_8.exe">Выполнить</a>
      <p>Следует учитывать, что
      аварийное завершение программы, а также
      вызов библиотечных функций типа abort()
      подавляют вызов деструкторов.
      Рекомендуется использовать для
      нормального завершения программы в
      любой точке функцию exit().
      <hr width="100%" size="3">
      <p><a href="#REF_1_C">Начало</a>
<p>
      <div class="header"><a name="REF_1_3"></a>3. ОПРЕДЕЛЕНИЕ
      ОПЕРАЦИЙ НАД ОБЪЕКТАМИ КЛАССОВ</div>
      <div class="header"><a name="REF_1_3_1"></a>3.1. Схема
      определения операций над объектами</div>
      <p>Декларация объектов класса
      означает появление в программе
      возможности отображения некоторых
      сущностей реального мира. Конструкторы
      и деструкторы позволяют управлять
      созданием и уничтожением таких объектов.
      Любой доступ к объектам класса требует
      записи выражений, составляемых из
      символических обозначений операндов и
      символов операций над ними. В языке С++
      наряду с обычными возможностями
      конструирования выражений над
      операндами базовых типов имеется
      возможность определения операций для
      определенных пользователей типов -
      классов. В результате конструирование
      выражений может проводиться на уровне
      операций над объектами, а не на уровне
      операций над их элементами. По умолчанию,
      для объектов класса определены лишь
      операции присваивания &quot;=&quot; и
      определения адреса &quot;&amp;&quot;.
      Определение любой операции @ для
      некоторого класса реализуется
      объявлением функции с именем operator@.
      Такая функция должна иметь
      соответствующие смыслу операции набор и
      типы параметров и, как любая функция,
      может быть переопределенной. Рассмотрим
      пример:
      <pre><div class="code">     
   class complex {
      double re, im;
   public:
      complex(double r, double i) { re=r; im=i; }
      friend complex operator+(complex, complex);
      friend complex operator*(complex, complex);
   };</div> </pre>
      <p>Здесь функции с именами operator+
      и operator* определяют новый смысл
      операторов '+' и '*'. Такие функции можно
      вызывать явно, например:
      <pre><div class="code">     
   complex x,y,z;
   ...
   z=operator+(x,y);
   x=operator+(operator*(x,z),complex(1.34,2.52));
</div> </pre>
      <p>Важнейшие последствия
      декларации подобных функций -
      возможность сокращения записи операций
      в выражениях:
      <pre><div class="code">     
   complex x,y,z;
   ...
   z=x+y;
   x=x*z+complex(1.34,2.52);
</div></pre>
      <p>Приведенные выражения
      приближаются в рамках синтаксических
      возможностей языка С к общепринятой
      записи комплексных выражений. При этом
      действуют стандартные в языке С понятия
      приоритета и порядка выполнения
      операций. Последнее выражение
      эквивалентно следующему:
      <pre><div class="code">     
   x=(x*z)+complex(1.34,2.52);
</div></pre>
      <p>Определение операций должно
      вестись в рамках их синтаксиса для
      базовых типов объектов с учетом
      следующих ограничений:
      <ul>
        <li>
          <p>не допускается
          переопределение некоторых операций (например,в
          системах программирования на языке С++,
          созданных фирмой Borland, запрещенными
          являются операции &quot;.&quot;, &quot;::&quot;,
          &quot;.*&quot;, &quot;?:&quot;;
        <li>
          <p>приоритет операций и
          синтаксис их использования в
          выражениях (например, арность)
          изменить нельзя;
        <li>
          <p>определение всех операций,
          кроме операции &quot;=&quot;, действительно
          для производных классов.</li>
      </ul>
      <p>В конкретных реализациях
      системы программирования С++
      приведенные ограничения могут быть
      модифицированы. Например, в системе
      программирования Turbo C++ переопределение
      операций &quot;=&quot;, &quot;()&quot;, &quot;[]&quot; и
      &quot;-&gt;&quot; может быть реализовано только
      функцией-элементом.
      <p>Нехватка символических
      конструкций для обозначения операций
      легко преодолевается введением набора
      функций.
      <p>Очевидно, что определяемыми
      могут быть только унарные или бинарные
      операции. Операции вызова функции
      &quot;()&quot; и обращения по индексу &quot;[]&quot;
      являются бинарными:
      <pre><div class="code">     
   fun_ptr(arg_list) &lt;=&gt; <a href="#REF_1_3_6">operator()(fun_ptr,arg_list);</a>
   array_ptr[index]  &lt;=&gt; <a href="#REF_1_3_7">operator[](array_ptr,index).</a>
</div> </pre>
      <div class="header"><a name="REF_1_3_2"></a>3.2. Особенности
      определения операций</div>
      <p>Имя функции operator@ не может
      быть идентификатором обычной функции по
      правилам языка C++. Компилятор на этапе
      синтаксического анализа текста
      программы по значению символов @
      выделяет типы и имена операндов
      соответствующей операции. Организация
      вызова подходящей с учетом правил
      переопределения функции-оператора
      планируется только при использовании в
      качестве одного из параметров
      некоторого класса - типа вида struct, union или
      class, определенного пользователем (ислючение
      - операции new и delete).
      <p>Декларация функций-операторов
      возможна как вне класса, так и в классе.
      Разница между этими вариантами:
      <p>
      <ul>
        <li>
          <p>возможности доступа к
          элементам класса - функциям вне класса
          доступны только открытые элементы;
        <li>
          <p>время создания текста
          функции-оператора и определения
          класса - функция вне класса может быть
          создана позже (естественно требование
          отсутствия конфликтов
          переопределения функций).</li>
      </ul>
      <p>
<pre><div class="code">
   // Пример определения функции-оператора вне класса

   #include &lt;stdio.h&gt;
   class a { // Класс без функций-операторов
      int i;
   public:
      a(int j):i(j) {}
      int value() { return i; }
   };
   
   class b { // Класс без функций-операторов
      int i;
   public:
      b(int j):i(j) {}
      int value() { return i; }
   };

   // Функции-операторы вне класса a

   void operator+=(a &amp;x, b &amp;y) { // Вариант 1 
      printf(&quot;\n x=%d y=%d&quot;,x.value(),y.value()); 
   }
   
   void operator+=(a &amp;x, int y) { // Вариант 2
      printf(&quot;\n x=%d int y=%d&quot;,x.value(),y); 
   }
   
   void operator+=(int x, a &amp;y) { // Вариант 3
      printf(&quot;\n int x=%d y=%d&quot;,x, y.value()); 
   }
   
   void main() { 
      a x(2); 
      b y(5);
      x+=y; // Вариант 1 
      x+=3; // Вариант 2 
      6+=x; // Вариант 3 - константа слева! 
      4+=y; // Вариант ? 
   }</div></pre>
      Результаты работы программы:
      <pre>   x=2 y=5
   x=2 int y=3
   int x=6 y=2
   x=4 y=5
</pre>
      <p>Вопросы <a href="#REF_1_3_3">согласования
      типов</a> подробно обсуждаются в 3.3.</p>
      <p>Функции-операторы вне класса -
      основа определения операций ввода-вывода
      в стандартные потоки C++ для классов
      пользователя.</p>
      <p>Операция над объектами любых
      классов может быть <strong>определена в
      классе</strong> как функцией-элементом, так
      и <a href="#REF_1_2_4">дружественной</a>
      функцией. Ранее отмечалось, что функция-элемент
      получает неявный параметр - указатель
      объекта this. При определении операций
      этот параметр считается указателем на
      первый операнд.
      <p>Отсюда следует, что унарная
      операция @ может быть определена
      функцией-элементом без параметров или
      дружественной функцией с одним
      параметром. Постфиксное выражение a@ или
      префиксное выражение @a может
      интерпретироваться одним из
      взаимоисключающих вариантов:
      <pre><div class="code">   a.operator@() - operator@ - функция-элемент;
   operator@(a) - operator@ - друженственная функция.
</div> </pre>
      <p>Одинаковая интерпретация
      префиксной и постфиксной форм выражений
      приводит к тому, что для операций &quot;++&quot;
      и &quot;--&quot; формально отсутствует
      различие между их префиксными и
      постфиксными формами записи (для
      объектов базовых типов такое различие
      существенно с точки зрения результата
      операции). В последних версиях C++ это
      обстоятельство учтено следующим
      приемом:
      <p>Бинарная операция @ может быть
      <strong>определена в классе</strong> функцией-элементом
      с одним параметром или дружественной
      функцией с двумя параметрами. В
      результате выражение a@b может
      интерпретироваться одним из
      взаимоисключающих вариантов:
      <pre><div class="code">   a.operator@(b) - operator@ - функция-элемент;
   operator@(a,b) - operator@ - друженственная функция.
</div> </pre>
      <p>Heкоторые символы операций @
      относятся к унарным, так и бинарным
      операциям:
      <pre><div class="code">
   class X {
      //...

   // Описание дружественных функций

      friend X operator-(X); // унарный минус
      friend X operator-(X,X); // бинарный минус 
      friend X operator-(); // ошибка: нет операндов 
      friend X operator-(X,X,X); // ошибка: тернарная операция
   
   // Описание функций-элементов (с неявным первым параметром this)
	
      X* operator&amp;(); // унарный &amp; (определение адреса) 
      X operator&amp;(X); // бинарный &amp; (поразрядная коньюнкция) 
      X operator&amp;(X,X); // ошибка: тернарная операция };</div></pre>
      <p>Смысл определяемых операций,
      в том числе и результат, должен быть
      полностью задан пользователем. Например,
      при переопределении операции
      присваивания проверка того, что первый
      операнд является переменной, не
      выполняется. Разработчик класса должен
      учесть подобные особенности подбором
      подходящего варианта функции и типов ее
      параметров: 
<pre><div class="code"> 
   #include &lt;stdio.h&gt;
   class x { 
      int i;
   public:
      x(int j) { 
         printf(&quot;\nC %d&quot;,i=j); 
      } 
      ~x() {
         printf(&quot;\nY %d&quot;,i); 
      }
   // Ассоциативное присваивание объектов класса x
   
      x&amp; operator=(x&amp; b) { 
         if (i==b.i) printf(&quot;\n %d==%d !!&quot;,i,i); 
         else printf(&quot;\n %d &lt;== %d ?&quot;,i,b.i), i=b.i;
         return *this; 
      }
   // Ассоциативное присваивание целых чисел объектам класса x
      x&amp; operator=(int i) { 
         if (this-&gt;i==i) printf(&quot;\n %d==%d !?&quot;,i,i); 
         else printf(&quot;\n %d &lt;&lt;= %d ?&quot;,this-&gt;i,i), this-&gt;i=i; 
         return *this; 
      }
      // Неассоциативное присваивание чисел с плаваюшей точкой 
      // объектам класса x
      void operator=(float f) { 
         if (this-&gt;i==f) printf(&quot;\n %d==%f !?&quot;,i,f); 
         else printf(&quot;\n %d &lt;&lt;= %f ?&quot;,this-&gt;i,f), this-&gt;i=f; 
      } 
   };
   
   void main () {
      x a(0); 
      x b(1); 
      x c(2);
      a=b=c=x(3)=4; // ассоциативное присваивание 
      x(4)=a; 
      x(5)=3;
      a=float(6.0); // неассоциативное присваивание 
   } </div> </pre>
      Результаты работы программы:
      <pre>   C 0
   C 1
   C 2
   C 3
   3 &lt;&lt;= 4 ?
   2 &lt;== 4 ?
   1 &lt;== 4 ?
   0 &lt;== 4 ?
   C 4
   4==4 !!
   C 5
   5 &lt;&lt;= 3 ?
   4 &lt;&lt;= 6.000000 ?
   Y 3
   Y 4
   Y 4
   Y 4
   Y 4
   Y 6</pre>
<a href="3_2_2.exe">Выполнить</a>
      <p>Функция operator@ должна быть
      элементом класса или иметь хотя бы один
      параметр - объект класса (исключение -
      функции, переопределяющие операции new и
      delete). Дополнительное ограничение -
      нельзя определить функцию оператора,
      которая оперирует исключительно с
      указателями. Отсюда следует:
      <ul>
        <li>
          <p>защита любых выражений с
          символом операции @ от неуместного
          применения функций вида operator@
          гарантируется правилами
          переопределения функций;
        <li>
          <p>если первый операнд
          операции в классе не является
          объектом класса, то определить такую
          операцию можно только дружественной
          функцией.</li>
      </ul>
      <p>Интерпретации операций над
      объектами класса не предполагает учет
      фундаментальных свойств базовых типов.
      Например, коммутативность операции '*'
      влечет эквивалентность выражений obj_1*obj_2
      и obj_2*obj_1, но, как в приведенном ранее
      примере определения операции
      присваивания, к объектам определенного
      пользователем класса это не относится.
      Аналогичным образом не учитывается
      взаимозависимость некоторых операций
      языка С. Например, выражение obj_1*=obj_2 для
      объектов класса не эквивалентно
      выражению obj_1=obj_1*obj_2.
      <p>Пример программы с
      определением операций: 
<pre><div class="code">
   #include &lt;stdio.h&gt;
   struct integer { 
      int i;
      integer operator=(int j) { 
         i=j; 
         return *this; 
      } 
      friend  integer operator*(integer, int); 
      friend integer operator*(int, integer);
      friend integer&amp; operator*=(integer&amp;, int); 
   };
   integer operator*(integer x, int j) { 
      integer y; 
      y.i=x.i*j;
      return y; 
   }
   integer operator*(int j, integer x) { 
      return operator*(x,j);
   }
   integer&amp; operator*=(integer&amp; x, int j) { 
      x.i*=j;
      return x; 
   }
   
   void main() { 
      integer a, b, c, d; 
      a=1; 
      b=2; 
      c=b*2; 
      d=3*c;
      printf(&quot;\n a=%d b=%d c=%d d=%d&quot;,a.i,b.i,c.i,d.i); 
      d*=4; 
      printf(&quot;\n d=%d&quot;,d.i); (a*=4)*=2; 
      printf(&quot;\n a=%d&quot;,a.i); 
   } </div></pre>
      Результаты работы программы:
      <pre>   a=1 b=2 c=4 d=12
   d=48
   a=8</pre>
<a href="3_2_3.exe">Выполнить</a>
      <p>Функции-операторы не могут
      иметь параметры по умолчанию.
      <p>Определение операций над
      объектами класса и объектов базовых
      типов может проводиться с учетом явных и
      неявных преобразований типа.</p>
      <div class="header"><a name="REF_1_3_3"></a>3.3. Способы
      согласования типов</div>
      <p>Определение операций над
      объектами разных классов часто связано
      с необходимостью преобразования типов.
      Например, для коммутативных по
      характеру операций над арифметическими
      объектами прямолинейное определение
      функций -операторов для всех возможных
      комбинаций операндов не только
      обременительно, но и неэффективно -
      можно сократить объем программ за счет
      использования неявных преобразований.
      Неявными преобразованиями удобно
      пользоваться в операциях присваивания,
      операторах инициализации, а также для
      преобразования фактических параметров
      и возвращаемых значений функций.
      <ul>
        <p>Имеется два пути
        согласования типов объектов:</p>
        <li>
          <p>создание из объектов других
          типов объекта класса явным либо
          неявным вызовом его конструктора (неявно
          может вызываться только конструктор с
          единственным параметром);</p>
        <li>
          <p>определение в классе
          операции приведения к другому типу.</p>
        </li>
      </ul>
      <p>Например, определим фрагмент
      класса complex, предусматривающий операции
      и с данными типа double:
      <pre><div class="code">     
   class complex {
      double re, im;
   public:
      complex(double r, double i) { re=r; im=i; }
		
      friend complex operator+(complex, complex); 
      friend complex operator+(complex, double); 
      friend complex operator+(double, complex);
   	
      friend complex operator-(complex, complex); 
      friend complex operator-(complex, double); 
      friend complex operator-(double, complex);

      friend complex operator*(complex, complex); 
      friend complex operator*(complex, double); 
      friend complex operator*(double, complex); 
		
      // ... 
   };</div></pre>
      <p>Исключить потребность в
      определении нескольких функций можно
      определением конструктора, который по
      заданному объекту типа double создает
      объект типа complex. Здесь это можно
      осуществить двумя способами: а) явное
      определение двух конструкторов
      <pre><div class="code">   
   ...
   complex(double r, double i) { re=r; im=i; }
   complex(double r) { re=r; im=0; }
</div></pre>
      <p>б) определение конструктора с
      параметром по умолчанию
      <pre><div class="code">   
   ...
   complex(double r, double i = 0) { re=r; im=i; }
   ...
</div></pre>
      <p>Используя второй способ,
      можно представить ранее записанный
      фрагмент класса complex в виде:
      <pre><div class="code">     
   class complex {
      double re, im;
   public:
      complex(double r, double i=0) { re=r; im=i; }

      friend complex operator+(complex, complex); 
      friend complex operator-(complex, complex); 
      friend complex operator*(complex, complex); 
      
      // ... 
   };</div> </pre>
      <p>Конструктор вызывается при
      возможности построения объекта своего
      класса из определенных его параметрами
      объектов. Такая возможность
      определяется последовательным
      сопоставлением типов фактических
      параметров объектов и формальных
      параметров конструктора (правилами
      использования переопределенных функций):</p>
      <ol>
        <li>
          <p>точное совпадение типов;</p>
        <li>
          <p>совпадения после
          применения стандартных
          преобразований;</p>
        <li>
          <p>уникальное совпадение
          после применения явно определенных
          преобразований.</p>
        </li>
      </ol>
      <p>Неудача сопоставления влечет
      выдачу компилятором сообщения о
      необходимости явного вызова
      конструктора.
      <p>Отсюда следует, что последний
      вариант класса complex допускает
      конструирование объектов для любых
      сочетаний арифметических данных:
      <pre><div class="code">     
   complex x1 = complex(123,456); // явный вызов конструктора
   complex x2 = 234.6; // неявный вызов конструктора
   //...
   void f(complex);
   //...
   f(10);   // f(complex(10));
   x1=x2*5; // x1=operator*(x2,complex(double(5),double(0)))
</div> </pre>
      <p>Попытки подбора других
      конструкторов для преобразования
      параметров в промежуточные типы,
      приемлемые для некоторых имеющихся
      конструкторов, не предпринимаются:
      <pre><div class="code">     
   class X { /* ... */ X(int); }
   class Y { /* ... */ Y(X); }
   // ...
   Y z=23; // ошибка: Y(X(23)) не планируется
   Y z=X(23); // правильный явный вызов конструктора
</div></pre>
      <p>Пример нарушения
      уникальности совпадения типов
      параметров:
      <pre><div class="code">     
   class x { /* ... */ x(int); x(char*); };
   class y { /* ... */ y(int); };
   class z { /* ... */ z(x); };
   void f(x);
   void f(y);
     
   f(1); // неоднозначность: f(x(1)) или f(y(1)) ? 
   f(x(1)); // правильный явный вызов конструктора 
   f(y(1)); // правильный явный sвызов конструктора
</div> </pre>
      <p>Преобразование типа
      конструктором характеризуется
      следующими очевидными ограничениями:
      <ul>
        <li>
          <p>невозможно преобразование
          объекта определенного пользователем
          класса в объект базового типа (такие
          типы не являются классами);
        <li>
          <p>описание преобразования из
          нового типа в старый требует
          изменения описания старого типа.</li>
      </ul>
      <p>Указанные ограничения
      снимаются определением в классе X
      функции-элемента вида operator type(),
      выполняющей преобразование объекта
      класса X в объекты типа type. Здесь type - имя
      типа без модификаторов &quot;[]&quot; или
      &quot;()&quot;. Схема введения функции
      преобразования:
      <pre><div class="code">     
   class X {
      //...
      operator int();
   };
     
   X a,b; int i;

   // Эквивалентные выражения
	
   i=int(b); // явное функциональное приведение типа 
   i=(int)b; // явное традиционное приведение типа 
   i=b; // неявное приведение типа

   // Другие примеры неявного приведения типа

   i=(a)? a+1:0; 
   while (a||b) { /* ... */ }
</div> </pre>
      <p>Таким образом, подобно
      конструктору, функция преобразования
      X::operator type() может вызываться неявно.
      Явный ее вызов возможен посредством
      записи операции приведения типа в
      синтаксических формах type(e) или (type)e, где e
      - выражение типа X. Преобразования
      объектов в базовые типы данных
      позволяют воспользоваться управляющими
      операторами языка С++ в следующем стиле:
      <pre><div class="code">     
   while (cin&gt;&gt;x) cout&lt;&lt;x;
</div> </pre>
      <p>Здесь cin - стандартный поток
      ввода - объект класса istream, cout -
      стандартный поток вывода - объект класса
      ostream, &quot;&gt;&gt;&quot; и &quot;&lt;&lt;&quot; -
      обозначения операций ввода и вывода.
      Операция ввода cin&gt;&gt;x возвращает объект
      istream&amp;, который неявно преобразуется к
      целому значению, отражающему результат
      ввода. Определение преобразование из
      одного типа в другой подобным образом
      может быть связано с потерей информации,
      но позволяет получать укрупненную
      оценку состояния объекта. Использование
      конструктора, наоборот, означает
      детальное представление состояния
      объекта по входным параметрам.
      Рассмотрим пример с явным определением
      операций преобразования типов. 
<pre><div class="code">
   #include &lt;stdio.h&gt;
   class cx { 
      friend class cy;
      double re, im; 
   public: 
      cx(double r=0, double i=0) { re=r, im=i; }
      void print() { 
         printf(&quot;\n R=%lf, I=%lf&quot;,re,im);
      } 
      int nonzero() { 
         return(re||im); 
      } 
   };
   
   class cy { 
      double re, im; 
   public: 
      cy(double r, double i=0) { 
         re=r, im=i; 
   } 
   
      cy(cx x) { 
         this-&gt;re=x.re, this-&gt;im=x.im; 
      }
   
      operator cx() { 
         printf(&quot;\n***&quot;); 
         cx x; 
         x.re=re,
         x.im=im; 
         return x; 
      }
   
      operator int() { 
         return(re||im); 
      } 
      
      void print() {
         printf(&quot;\n R=%lf, I=%lf&quot;,re,im); 
      } 
   };
   
   void main() { 
      cx a=1; 
      cx b=1.13; 
      cx c(' '); 
      cy d(a);
      a=d; 
      a.print(); 
      if (a.nonzero()) printf(&quot;\n a!=0...&quot;);
      b.print(); 
      c.print(); 
      d.print(); 
      if (d) printf(&quot;\n d!=0...&quot;); 
   }</div> </pre>
      Результаты работы программы:
      <pre>   ***
    R=1.000000, I=0.000000
    a!=0...
    R=1.130000, I=0.000000
    R=32.000000, I=0.000000
    R=1.000000, I=0.000000
    d!=0...
 </pre>
<a href="3_3.exe">Выполнить</a>
      <p>
      <div class="header"><a name="REF_1_3_4"></a>3.4. Особенности
      использования ссылочных типов</div>
      <p>Опеределение бинарных
      операций для относительно больших
      объектов целесообразно выполнить с
      назначением операндам ссылочных типов.
      Это позволит избежать бесполезных
      пересылок полей операндов. Традиционные
      для языка С указатели использовать
      нельзя из-за запрета определения
      операций над указателями.
      <p>Рассмотрим пример класса:
      <pre><div class="code">     
   class matrix {
      double m[10][256];
   public:
      matrix();
      friend matrix operator+(matrix&amp;, matrix&amp;);
      friend matrix operator*(matrix&amp;, matrix&amp;);
      //...
  };</div> </pre>
      <p>Операцию сложения можно
      определить так:
      <pre><div class="code">     
   matrix operator+(matrix&amp; x, matrix&amp; y) {
      matrix sum;
      for (int i=0; i&lt;10; i++)
         for (int j=0; j&lt;256; j++)
            sum.m[i][j]=y.m[i][j]+y.m[i][j];
      return sum;
   }</div></pre>
      <p>Функция operator+() обращается к
      операндам через ссылки, но результат
      возвращает посредством копирования
      поля объекта. Принципиально возможна
      ссылочная схема передачи результата:
      <pre><div class="code">     
   class matrix {
      // ...
      friend matrix&amp; operator+(matrix&amp;, matrix&amp;);
      friend matrix&amp; operator*(matrix&amp;, matrix&amp;);
   };</div></pre>
      <p>Здесь возникают сложности с
      выделением памяти для результата:</p>
      <ul>
        <li>
          <p>поле результата не может
          иметь атрибут auto, так как ссылка на
          него будет возвращена вызывающей
          функции;
        <li>
          <p>результат нежелательно
          размещать и в статической памяти, так
          операция сложения в выражении может
          использоваться неоднократно;
        <li>
          <p>размещение результата в
          свободной памяти потребует отдельной
          операции её освобождения.</li>
      </ul>
      <p>С учетом отмеченных
      сложностей в большинстве случаев
      копирование результата оказывается
      приемлемым решением по времени
      выполнения, размеру программы и
      простоте программирования. Тем не менее,
      в некоторых ситуациях по смыслу
      операции можно возвратить ссылку на
      известный объект, например, один из
      операндов (см. пример определения
      операции ассоциативного присваивания).
      <p>
      <div class="header"><a name="REF_1_3_5"></a>3.5. Особенности
      операций присваивания и инициализации</div>
      <p>Рассматриваемые операции
      практически всегда неизбежны в любой
      программе, где объявляются объекты
      класса. Особого внимания здесь требуют
      объекты с нетривиальным распределением
      памяти, для которых имеющееся по
      умолчанию побитовое копирование полей
      данных существенно искажает
      отображение &quot;объект-память&quot;.
      Например, рассмотрим простейший класс
      строковых данных:
      <pre><div class="code">     
   struct string {
      char* p;  // указатель строки
      int size; // размер поля строки
      string(int number) { p = new char[size=number]; }
      ~string() { delete p; }
   };</div></pre>
      <p>Пример программы с
      неприятностями:
      <pre><div class="code">     
   void f1() {
      string s1(10);
      string s2(20);
      //...
      s1 = s2;
   }</div></pre>
      <p>Здесь будет создано две
      строки, но присваивание s1=s2 будет
      приведет к дублированию указателя на
      буфер строки s2. При выходе из функции f1()
      для объектов s1 и s2 автоматически будет
      вызываться деструктор, который будет
      уничтожать один и тот массив символов с
      непредсказуемо аварийными
      последствиями. Правильным решением
      здесь является явное определение
      операции присваивания объектов типа string:
      <pre><div class="code">     
   struct string {
      char* p;  // указатель строки
      int size; // размер поля строки
      string(int number) { p = new char[size=number]; }
      ~string() { delete p; }

   // Определение операции неассоциативного присваивания

      void operator=(string&amp; y) { 
         if (this!=&amp;y) { // защита от излишней операции 
            delete p; // удаление буфера левого операнда 
            p=new char[size=y.size]; 
            strcpy(p,y.p); 
         } 
      }
   }</div></pre>
      <p>Предыдущий пример будет
      работать правильно, но неприятности
      предвосхищены еще не полностью:
      <pre><div class="code">    
   void f2() {
      string s1(10);
      string s2=s1;  // инициализация побитовым копированием
      //...
   }</div></pre>
      <p>Операция присваивания
      применяется только для созданных
      объектов, а здесь требуется наличие
      конструктора копирования, учитывающего
      особенности распределения памяти:
      <pre><div class="code">     
   struct string {
      char* p;  // указатель строки
      int size; // размер поля строки
      string(int number) { p = new char[size=number]; }
      ~string() { delete p; }
      
      void operator=(string&amp;); // неассоциативное присваивание
      string(string&amp; y) { // конструктор копирования 
         p=new char[size=y.size]; 
         strcpy(p,y.p); 
      } 
   };</div></pre>
      <p>Таким образом, если класс X
      использует нетривиальное управление
      памятью, то в общем случае должен быть
      определен полный комплект функций для
      гарантированного исключения побитового
      копирования объектов:
     <pre><div class="code">     
   class X {
      // ...
      X(something);  // конструктор - создание объекта
      X(X&amp;);         // конструктор копирования
      
      operator=(X&amp;); // переопределение операции присваивания
      
      ~X(); // деструктор 
   };</div></pre>
      <p>Класс с подобным набором
      функций-элементов иногда называют п о л
      н ы м. Кроме операции инициализации,
      конструктор копирования может
      использоваться в общем случае при
      передаче фактических параметров и
      возвращаемого результата функции.
      <p>
      <div class="header"><a name="REF_1_3_6"></a>3.6. Пример
      переопределения операции индексации</div>
      <p>Смысл индексов для объектов
      класса можно переопределить функцией
      operator[]. Индекс, задаваемый вторым
      параметром функции operator[], может иметь
      любой тип. Операция индексации удобна
      для определения ассоциативных связей
      между объектами разных типов. Перепишем
      пример программы для подсчета числа
      вхождений строк в ассоциативный массив <a href="#REF_1_1_6">(см.
      1.6)</a>.
      <pre><div class="code">
   #include &lt;string.h&gt;
   #include &lt;stdio.h&gt;
   struct pair { 
      char* name; // указатель строки 
      int val; // количество повторений строки 
   };
   
   class list { 
      pair* vec; // указатель массива строк 
      int max; // текущий размер массива 
      int free; // индекс свободного элемента 
   public: 
      list(int size=16) { // конструктор
         free=0; 
         vec=new pair[max=(size&lt;16)? 16:size]; 
      }
      int&amp; operator[](char*); 
      void print_all(); 
   };
      
   int&amp; list::operator[](char* p) { 
      pair* q;
      for (q=vec+free; vec!=q--; ) 
         if (!strcmp(p,q-&gt;name))
            return q-&gt;val;
      if (free==max) { // переполнение: вектор увеличивается 
         pair* nvec = new pair[max&lt;&lt;1];
         for (int i=0; i&lt;max; i++) *(nvec+i)=*(vec+i); 
            delete vec; 
         vec=nvec; 
         max&lt;&lt;=1;
      } 
      q=vec+free++; 
      q-&gt;name = new char[strlen(p)+1]; 
      strcpy(q-&gt;name,p);
      q-&gt;val=0; // начальное значение: 0 
      return q-&gt; val;
   }
   
   void list::print_all() { // Вывод ассоц. массива 
      for (int i=0; i &lt; free; i++) 
         printf(&quot;\n %s %d&quot;,vec[i].name,vec[i].val); 
   }
   
   // Подсчет количества повторения вводимых строк

   void main() { 
      char buf[256]; // Буфер ввода строки 
      list vector; // Список введенных строк
      
   // Ввод списка строк
   
      while (printf(&quot;\n?? &quot;), scanf(&quot;%s&quot;,buf)&gt;0)
      vector[buf]++;
      
   // Отображение списка строк
   
      vector.print_all(); 
   } </div> </pre>
      <p>В приведенной программе
      размер вектора увеличивается в два раза
      при обнаружении ситуации переполнения
      текущего буферного массива.
<p>
        <div class="header"><a name="REF_1_3_7"></a>3.7. Пример
        переопределения операции вызова
        функции</div>
        <p>Операция вызова функции в
        форме записи fun_ptr(arg_list) рассматривается
        как бинарная операция, которую можно
        переопределить функцией operator(). Список
        параметров этой функции формируется по
        общим правилам передачи параметров, а
        тип результата определяется смыслом
        операции. Например, пусть имеем класс
        <pre><div class="code">     
   class X {
      void operator()() { /* .... */ }
      //...
   };</div></pre>
        <p>Здесь операция вызова
        функции переопределена функцией без
        параметров и возвращаемого значения. В
        результате после определения
        множества объектов класса X, например,
        оператором
        <pre><div class="code">     X x1, x2, x2;
</div></pre>
        <p>имеется возможность записи
        выражений вида
        <pre><div class="code">   x1();
   x2();
   x3();</div> </pre>
        <p>Внешне эти выражения
        напоминают традиционный вызов трех
        функций, но транслятор интерпретирует
        их следующим образом:
        <pre><div class="code">     
   x1.operator()();
   x2.operator()();
   x3.operator()(); </div></pre>
        Операции вызова функции
        могут быть переопределены:
<pre><div class="code">
   #include &lt;iostream.h&gt;
   #include &lt;alloc.h&gt;
   class X { 
   public: 
      X() {} 
      ~X() {} 
      void operator()(int x) { 
         cout&lt;&lt;endl&lt;&lt;"x="&lt;&lt;x; 
      }
      void operator()(char *x) {
         cout&lt;&lt;endl&lt;&lt;"x=\""&lt;&lt;x&lt;&lt;"\"";
      }
      void operator()(int x,char *y) {
         cout&lt;&lt;endl&lt;&lt;"x="&lt;&lt;x&lt;&lt;", y=\""&lt;&lt;y&lt;&lt;"\"";
      }
   };
	
   void main() {
      X x1,x2,x3;
      x1(1);
      x1("?");
      x1(1,"x=1 ?");
      x2(2);
      x2("??");
      x2(2,"x=2 ??");
      x3(3);
      x3("???");
      x3(3,"x=3 ???");
   }</div> </pre>
        Результаты работы программы:
        <pre>   x=1
   x=&quot;?&quot;
   x=1, y=&quot;x=1 ?&quot;
   x=2
   x=&quot;??&quot;
   x=2, y=&quot;x=2 ??&quot;
   x=3
   x=&quot;???&quot;
   x=3, y=&quot;x=3 ???&quot; </pre>
<a href="3_7.exe">Выполнить</a>
        <p>Переопределение операции
        вызова функции часто полезно для
        классов с единственной операцией.
        Типичный пример таких классов - <strong>итераторы</strong>
        - вспомогательные классы для
        организации выборки в заданном порядке
        элементов некоторого множества.
        <p>Приведем пример построения
        итератора iterator для ранее
        рассмотренного класса list. Наличие
        итератора здесь позволит отказаться от
        функии-элемента print_all, что обеспечит
        большую гибкость в форме вывода.
        Очевидно, что для доступа итератора к
        данным класса list требуется модификация
        декларации этого класса:
        <pre><div class="code">     
   class list {
      friend class iterator; // разрешение доступа
      pair* vec;
      int max, free;
   public:
      list(int);
      int&amp; operator[](char*);
   }; </div> </pre>
        <p>Определение итератора:
        <pre><div class="code">
   class iterator {
      list *base;      // текущий массив list
      int   index;     // текущий индекс
   public:
      iterator(list&amp; owner) { // конструктор
         base=&amp;owner, index=0;
      }
        
   // Определение операции вызова функции
      
      pair* operator()() { 
         return (index&lt;base-&gt;free)? &amp;base-&gt;vec[index++]: 0; 
      } 
   };</div> </pre>
        <p>Создание объекта класса iterator
        для некоторого объекта класса list
        позволит далее операцией вызова
        функции получать указатели
        последовательно на все элементы типа
        pair. Конец последовательности
        индицируется вызвратом пустого
        указателя. Перепишем программу из
        предыдущего подраздела, используя
        класс iterator.
        <pre><div class="code">     
   // Модифицированная программа подсчета
   // количества повторения вводимых строк
    
   void main() { 
      char buf[256]; // Буфер ввода строки 
      list strings; // Список введенных строк
        
   // Ввод списка строк
        
      while (printf(&quot;\n?? &quot;), scanf(&quot;%s&quot;,buf)&gt;0)
         strings[buf]++;
        
   // Определение итератора для существующего списка строк
        
      iterator next(strings); // next - имя объекта 
        
   // Отображение списка строк
        
      pair* p; // указатель выбранного объекта
        
      while ((p=next())!=0) printf(&quot;\n %s %d&quot;,p-&gt;name,p-&gt;val);
   }</div></pre>
        <p>Итераторы, реализованные
        подобным образом, предназначены для
        сохранения закрытых описаний
        состояния процесса выборки объектов.
        Это позволяет порождать без особых
        усилий требуемое количество
        независимых итерационных процессов.
        Такие процессы естественно
        связываются с блоками программы
        автоматическим вызовом конструкторов
        и деструкторов итераторов. В последней
        функции main итератор next создан после
        формирования списка строк и будет
        существовать до конца программы.
        Очевидно, что после завершения выборки
        объектов активный итератор должен до
        уничтожения возвращать
        соответствующий этому состоянию
        признак.
        <hr width="100%" SIZE="1">
        <a href="#REF_1_C">Начало</a>
<p>
        <div class="header"><a name="REF_1_4"></a>4. ПРОИЗВОДНЫЕ КЛАССЫ</div>
        <div class="header"><a name="REF_1_4_1"></a>4.1. Понятие производного
        класса</div>
        <p>Производный класс -
        расширение существующих классов,
        называемых в этом случае <strong>базовыми</strong>.
        Любой класс, не являющийся
        объединением (union), может служить
        базовым. В отличие от вложенных классов,
        производный класс определяется
        независимо от его базовых классов,
        включая и этап компиляции. Вспомним
        синтаксис декларации класса в языке С++:
          <pre><div class="code">     
   вид_класса имя_класса {
      декларация_элементов_класса
   };</div></pre>
        <p>(между символами '}' и ';' может
        размещаться список имен определяемых
        объектов класса с использованием, по
        необходимости, операции инициализации;
        элемент &quot;вид_класса&quot; может
        принимать значения struct, union или class).
        Синтаксис декларации производного
        класса:
        <pre><div class="code">     
   вид_класса имя_производного_класса:список_базовых_классов {
      декларация_элементов_производного_класса
   };</div></pre>
        <p>Отличие описания
        производного класса от обычного
        состоит в дополнительном элементе &quot;список_базовых_классов&quot;,
        размещаемом после имени
        декларируемого производного класса и
        символа ':'. Элемент &quot;список_базовых_классов&quot;
        содержит разделенные запятыми
        описания атрибутов доступа и имена
        базовых классов. <strong>Атрибут доступа к
        базовому классу </strong>задается ключевыми
        словами <strong>public, protected или private</strong>. Он может быть
        опущен при учете умалчиваемого
        атрибута доступа для соответствующего
        производному классу атрибута &quot;вид_класса&quot;
        (struct - public, class - private). Пример декларации
        иерархии производных классов:
        <pre><div class="code">     
   class b1 { /* ... */ };
   
   class b2 { /* ... */ };

   class d0: public b1,b2 { // class d0: public b1, private b2 
          //...
   };

   struct d1: d0 { // struct d1: public d0
          //... 
   }; </div> </pre>
        <p>Говорят, что производный
        класс наследует все элементы базовых
        классов, т.е. определение объекта
        такого класса означает создание и
        соответствующих ему элементов базовых
        классов. Однако право функций доступа
        производного класса на использование
        элементов его базовых классов зависит
        от атрибута доступа базового класса (табл.
        2).
        <div align="justify">
          <pre>     Табл. 2. Схема изменения атрибутов доступа к элементам
              базового класса в производном классе
=======================+=================+======================
    Атрибут доступа    ¦   Модификатор   ¦   Атрибут доступа
   в базовом классе    ¦     доступа     ¦ в производном классе
=======================+=================+======================
       public          ¦    public       ¦      public
       protected       ¦    public       ¦      protected
       private         ¦    public      ¦         -
=======================+=================+======================
       public          ¦    protected    ¦      protected
       protected       ¦    protected    ¦      protected
       private         ¦    protected     ¦         -
=======================+=================+======================
       public          ¦    private      ¦      private
       protected       ¦    private      ¦      private
       private         ¦    private      ¦         -
=======================+=================+======================
 </pre>
        </div>
        <p>Из приведенной схемы следует,
        что производный класс с атрибутом
        базового класса private ограничивает
        свободу доступа к элементам базового
        класса. Комбинируя атрибуты элементов
        и базовых классов, можно получать
        разные степени защиты наследуемых
        элементов класса. Скрытые элементы
        базовых классов остаютс скрытыми.
        <p>Пусть данные o студентах в
        представляются виде
        <pre><div class="code">     
   struct student {  // описание студента
      char   *name;     // фамилия, имя, отчество
      char     sex;     // пол
      char   *address;  // адрес
      //...
   };</div></pre>
        <p>Понятие учебной группы может
        быть определено линейным списком,
        элементы которого представлены
        классом
        <pre><div class="code">     
   class group_member: student {
      student *next;   // указатель следующего студента
      //...
   }; </div> </pre>
        <p>Здесь отражено только
        простейшее отношение вложенности
        раздельно определенных понятий student и
        group_member. Производный класс может
        отражать сложные неоднородные
        отношения между объектами разных
        классов.</p>
        <p>В зависимости от количества
        базовых классов, использованных при
        определении производного класса,
        различают <strong>простое и множественное
        наследование</strong>. Простое наследование
        соответствует случаю единственного
        базового класса. Множественное
        наследование формально разрешено, но в
        некоторых реальных системах классов,
        использующих механизм динамической
        идентификации типа, не допускается.</p>
        <p>
<div class="header"><a name="REF_1_4_2"></a>4.2. Виртуальные базовые
        классы</div>
        <p>Производный класс может быть
        базовым классом, что означает
        возможность рекурсивного определения
        иерархии классов. При этом любой
        базовый класс присутствует в
        производном классе один раз. Более
        общая сетевая структура прямолинейно
        не может быть задана. Например,
        следующее определение синтаксически
        неверно:
        <pre><div class="code">     
   class BASE { /* ... */ };
   class DERIVED: BASE, BASE { /* ... */ }; </div></pre>
        <p>Однако имеется косвенная
        возможность неоднократного включения
        некоторого базового класса в
        производный:
        <pre><div class="code">     
   class DERIVE_1: public BASE { /* ... */ }; 

   class DERIVE_2: public BASE { /* ... */ };

   class DERIVE12: public DERIVE_1, 
                   public DERIVE_2 { /* ... */ };</div> </pre>
        <p>Обьект класса DERIVE12 будет
        включать два экземпляра объекта класса
        BASE. Для обращения к таким объектам
        придется использовать операцию
        привязки (разрешения области видимости)&quot;::&quot;.
        Если по некоторым соображениям
        желательно иметь всего один экземпляр
        объекта базового класса, то можно
        объявить такие базовые классы <strong>виртуальными</strong>:
        <pre><div class="code"> 
   class Derive_1: virtual public BASE { /* ... */ };
   class Derive_2: virtual public BASE { /* ... */ };</div></pre>
        <p>Обьект производного класса
        следующего уровня, например,
        <pre><div class="code">  
   class Derive12: public Derive_1,
                   public Derive_2 { /* ... */ };</div> </pre>
        <p>будет включать по одному
        экземпляру объекта виртуального
        базового класса BASE. В результате
        открывается возможность отражения
        сложных сетевых отношений между
        объектами (рис. 1). Наследование
        виртуальных базовых классов
        реализуется включением в объект
        производного класса скрытого для
        пользователя указателя на объект
        виртуального базового класса.
       <p align="center">Графическая интерпретация
        класса Derive12
         Графическая интерпретация класса Derive12
<P>
<pre>
                           ========== 
               -----------¦ Derive12 ¦-----------
              ¦            ==========            ¦
         ===========                        =========== 
        ¦  Derive_1 ¦                      ¦  Derive_2 ¦
         ===========                        ===========
              ¦            ==========            ¦
               -----------¦   BASE   ¦-----------
                           ==========
<P>
                            Рис. 1.
</PRE><P>
        <p>Атрибут virtual не мешает
        независимому объявлению объектов
        классов Derive_1 и Derive_2 (для каждого из них
        объект базового класса BASE также
        требуется в одном экземпляре). К
        элементам виртуального базового
        класса можно обращаться без указания
        имени его производного класса.</p>
        <p>
        <div class="header"><a name="REF_1_4_3"></a>4.3. Конструкторы и
        деструкторы производных классов</div>
        <p>Производные классы могут
        иметь конструкторы и деструкторы. Если
        базовые классы имеют конструкторы, то
        они должны, в общем случае, вызываться
        при конструировании объектов
        производного класса. Семантически это
        подобно ранее рассмотренной схеме
        взаимодействия конструкторов
        вложенных классов. Связь конструктора
        производного класса с конструкторами
        базовых классов выполняется по
        следующей схеме:</p>
        <pre><div class="code">
   class B1 { // описание базового класса 
      // ... 
      B1 (par_B1); // конструктор с параметром 
   };
   
   class B2 { // описание базового класса 
      // ... 
      B2 (par_B2); // конструктор с параметром 
   }; 
   
   //... 
    
   class BN { // описание базового класса 
      // ... 
      BN (par_BN); // конструктор с параметром 
   };
 
   // Описание производного класса
   
   class D_1_N: B1, B2,... BN { 
      // ... 
   // Определение конструктора производного класса
   
      D_1_N (par_D_1_N):B1(arg_B1), B2(arg_B2),...BN(arg_BN) { 
         // ... 
      } 
      // ... 
   };</div></pre>
        <p>В <strong>определении</strong>
        конструктора производного класса
        после символа ':' записывается в
        произвольном порядке список операций
        вызова конструкторов базовых классов (будем
        назовать такой список списком
        конструктора). Элементы списка
        разделяются запятыми. Конструкторы
        объектов базовых классов будут вызваны
        перед конструктором производного
        класса. Порядок вызова таких
        конструкторов не определен, поэтому в
        списках их аргументов не рекомендуется
        использовать взаимосвязанные
        выражения присваивания. В общем случае
        списки аргументов конструкторов
        базовых классов могут включать
        константы, глобальные параметры и/или
        параметры из списка аргументов
        конструктора производного класса. Если
        производный класс включает другие
        классы, то список его конструктора
        дополняется обращением к
        конструкторам элементов включаемых
        классов <a href="#REF_1_2_6">(см. 2.6)</a>.
        Рассмотрим пример производного класса
        с включением класса:
        <p><pre><div class="code">
   #include &lt;string.h&gt;
   #include &lt;stdio.h&gt;
   class base_1 { 
      int a; 
   protected: 
      int b; 
   public: 
      base_1(int x, int y) { // конструктор base_1 
         a=x, b=y; 
         printf(&quot;\nbase_1: %d%d&quot;,a,b); 
      }
      ~base_1() { // деструктор base_1 
         printf(&quot;\n~base_1 (%d,%d)&quot;,a,b); 
      }
       
      void print_1() { // отображение объекта класса base_1 
         printf(&quot;\nbase_1: a=%d b=%d !&quot;,a,b); 
      } 
   };
      
   class base_2 { 
   protected: 
      int c; 
   public: 
      base_2(int x) { // конструктор base_2 
         c=x; 
         printf(&quot;\nbase_2: %d&quot;,c); 
      }
      ~base_2() { // деструктор base_2 
         printf(&quot;\n~base_2 (%d)&quot;,c); 
      }
      
      void print_2() { // отображение объекта класса base_2 
         printf(&quot;\nbase_2: c=%d !&quot;,c); 
      } 
   };
       
   class derive: public base_1, private base_2 { 
      int d; 
      base_1 e; // элемент вложенного класса 
   public: 
      derive(int x, int y, int z): // конструктор derive 
      base_1(x,y), // связь с конструктором base_1
      base_2(z), // связь с конструктором base_2 
      e(x+1,y+1) { // связь с конструктором элемента &quot;e&quot; 
         d=x;
         printf(&quot;\nderive: %d %d %d&quot;,d,b,c); 
      }
      
      ~derive() { // деструктор derive 
         printf(&quot;\n~derive (%d)&quot;,d); 
      } 
      
      void print_d() { // отображение объекта класса derive 
         e.print_1(); 
         printf(&quot; - derive: d=%d !&quot;,d); 
      } 
   };

   void main() { 
      derive D(1,2,3); // определение объекта класса derive
      D.print_1();
      D.print_2();
      D.print_d(); 
   } </div> </pre>
        Результаты работы программы:
        <pre>   base_1: 1 2
   base_2: 3
   base_1: 2 3
   derive: 1 2 3
   base_1: a=1 b=2 !
   base_2: c=3 !
   base_1: a=2 b=3 ! - derive: d=1 !
   ~derive (1)
   ~base_1 (2,3)
   ~base_2 (3)
   ~base_1 (1,2)</pre>
        <p>Таким образом, объекты
        производного класса конструируются
        снизу вверх - сначала объекты базовых
        классов, затем элементы вложенных
        классов, и, наконец, собственно
        производный класс. Уничтожение
        объектов производится в обратном
        порядке.
        <p>Связь конструктора
        производного класса с конструкторами
        виртуальных базовых классов
        описывается таким же образом:
        <pre><div class="code">   class BASE { /* ... */ };

   class D__1: virtual public BASE { /* ... */ };
        
   class D__2: virtual public BASE { /* ... */ };
        
   class D_12: public D__1, public D__2 { 
      // ... 
      D12( /* ... */ ): D__1( /* ... */ ), 
                        D__2( /* ... */ ),
                        BASE( /* ... */ ) { /* ... */ } 
   };</div></pre>
        <p>Список конструктора
        производного класса здесь дополняется
        обращением к конструктору
        виртуального базового класса.
        Особенность языка С++ - конструкторы
        виртуальных базовых классов
        вызываются перед остальными
        конструкторами.</p>
        <p>Рассмотрим простой пример
        использования виртуальных базовых
        классов в задаче представления данных
        о стоимости товара в упаковке. Пусть
        набор базовых классов отражает понятия:
        <p>price - стоимость(цена, единица
        измерения);
        <p>unit - товар(наименование,
        стоимость);
        <p>box - упаковка(наименование,
        стоимость).
        <p>Образуем производный класс
        <p>unit_box - товар в упаковке(наименование,
        стоимость),
        <p>где стоимость отражает общую
        цену, а ее разделение на составляющие
        не требуется по условию задачи.
        Обьявление класса price виртуальным для
        классов unit и box позволит объединить его
        экземпляры в классе unit_box.
        <p>Пример программы
        представления сведений о товарах: 
<pre><div class="code">
   #include &lt;string.h&gt;
   #include &lt;stdio.h&gt;
   struct price { // описание стоимости 
      int val; // стоимость 
      char type; // единица измерения 
      price(int vx, char v) { 
         val=vx, type=v; 
      } 
   };

   struct unit: virtual public price { // описание устройства 
      char name[20]; // наименование 
      unit(char *x, int vx=0, char v=' '):price(vx,v) { 
         strcpy(name,x); 
      } 
      void print() {
         printf(&quot;\nUnit %s %d %c&quot;,name,val,type); 
      }
   };

   struct box: virtual public price { // описание упаковки 
      char name[20]; // наименование 
      box(char *x, int vx=0, char v=' '):price(vx,v) { 
         strcpy(name,x); 
      } 
      void print() {
         printf(&quot;\nBox %s %d %c&quot;,name,val,type); 
      } 
   };
   
   // Описание устройства в упаковке с полной стоимостью

   struct unit_box: public unit, public box { 
      char name[40]; // наименование товара в упаковке 
      unit_box(char *x, int vx, // наименование и цена товара 
               char *y, int vy, // наименование и цена упаковки 
               char *z, // общее наименование товара в упаковке
               char v): // единица измерения цены 
         unit(x), box(y), price(vx+vy,v) 
      { strcpy(name,z); }
      void print() { 
         printf(&quot;\nUNIT_BOX %s,&quot;,name); 
         printf(&quot;\nBOX %s,\nUNIT %s,&quot;,box::name,unit::name); 
         printf(&quot;\nPRICE %d %d %d %c&quot;, box::val,unit::val,val,type); 
      } 
   };

   void main() { 
      unit_box tv_set(&quot;телевизор&quot;,1000, &quot;упаковка&quot;,
                       10, &quot;телевизор в упаковке&quot;,'p'); 
      tv_set.print(); 
      box b(&quot;b-111&quot;,111,'$');
      unit u(&quot;u-222&quot;,222,'Y'); 
      b.print(); 
      u.print(); 
   }</div> </pre>
        Результаты работы программы:
<pre>   UNIT_BOX телевизор в упаковке,
   BOX упаковка,
   UNIT телевизор,
   PRICE 1010 1010 1010 p
   Box b-111 111 $
   Unit u-222 222 Y</pre>
<a href="4_3_2.exe">Выполнить</a>
        <p>Если список конструктора
        производного класса не содержит
        операций вызова конструкторов
        некоторых базовых классов, то
        автоматически будут вызываться
        конструкторы таких классов по
        умолчанию (без параметров).
        <p>
        <div class="header"><a name="REF_1_4_4"></a>4.4. Динамическая
        взаимосвязь компонент производного
        и базовых классов</div>
        <p>Пусть определен производный
        класс derived на основе базового класса base:
        <pre><div class="code">
   class base { /* ... */ };
   class derived : public base { /* ... */ };
</div></pre>
        <p>Обьект класса derived включает
        на уровне хранения в памяти компоненту
        класса base. Непосредственный доступ к
        элементам класса по их именам не
        позволяет на этапе исполнения
        программы учесть взаимосвязь
        компонент на уровне класса. Если не
        использовать такую взаимосвязь, то
        производный класс может
        рассматриваться лишь как средство
        сокращения записи описания объектов.
        <p>Наиболее конструктивным
        применением производного класса
        является возможность решения во время
        выполнения программы двух задач:</p>
        <ul>
          <li>
            <p>выделение объекта
            базового класса из объекта
            производного класса;
          <li>
            <p>выделение объекта
            производного класса по его объекту
            базового класса.</li>
        </ul>
        <p>Перечисленные задачи
        решаются <strong>косвенным</strong>
        обращением к компонентам класса по
        указателям (ссылкам) с учетом следующих
        правил:</p>
        <ul>
          <li>
            <p>указатель на объект класса
            derived можно присваивать указателю на
            объект класса base без явного
            преобразования типа;
          <li>
            <p>преобразование указателя
            на объект класса base в указатель на
            объект класса derived должно быть явным.</li>
        </ul>
        <p>Пример применения этих
        правил:
       <pre><div class="code">   derived D;
   base* pb = &amp;D;      // неявное преобразование указателя
   derived* pd = pb;   // ошибка: base* не есть derived*
   pd = (derived *)pb; // явное преобразование
   base &amp;rb = D;       // неявное преобразование ссылки
</div> </pre>
        <p>Рассмотрим результаты
        эксперимента над указателями в системе
        программирования Turbo-C++: 
<pre><div class="code">
   #include &lt;stdio.h&gt;
   class base_1 { 
      int x; 
   public: 
      int y; 
   }; 

   class base_2 { 
      char x[13];
   public: 
      long y; 
   }; 

   class base_3 { 
      long x; 
   public: 
      long y; 
   };

   class derive: public base_1, private base_2, base_3 { 
      long z; 
   public:
      long d; 
   };

   void main() { // Model SMALL
      printf(&quot;\nРазмеры объектов базовых и производного класса\n&quot;);

      printf(&quot;\n|base_1|=%d&quot;,sizeof(base_1)); 
      printf(&quot;\n|base_2|=%d&quot;,sizeof(base_2));
      printf(&quot;\n|base_3|=%d&quot;,sizeof(base_3)); 

      printf(&quot;\n|derive|=%d&quot;,sizeof(derive));
	
     derive objd, *p_d=&amp;objd;

      base_1 *pb1=&amp;objd; // Указателю на базовый класс 
      base_2 *pb2=&amp;objd; // можно присвоить значение указателя 
      base_3 *pb3=&amp;objd; // производного класса
	
      printf(&quot;\n\nВыделение объектов базовых классов\n&quot;);
      printf(&quot;\np_d: %u, %u&quot;,p_d,p_d+1); 
      printf(&quot;\npb1: %u, %u&quot;,pb1,pb1+1); 
      printf(&quot;\npb2: %u, %u&quot;,pb2,pb2+1); 
      printf(&quot;\npb3: %u, %u&quot;,pb3,pb3+1);
        
      printf(&quot;\n\nПолучение адреса производного класса\n&quot;);
   
      p_d=(derive *)pb1; 
      printf(&quot;\np_d==pb1? %u - %u&quot;,p_d,pb1);
      p_d=(derive *)pb2; 
      printf(&quot;\np_d==pb2? %u - %u&quot;,p_d,pb2); 
      p_d=(derive *)pb3; 
      printf(&quot;\np_d==pb3? %u - %u&quot;,p_d,pb3); 
   } </div></pre>
        Результаты работы программы:
          <pre>   Размеры объектов базовых и производного класса
   base_1|=4 |base_2|=17 |base_3|=8 |derive|=37
   Выделение объектов базовых классов
   p_d: 65484, 65521 pb1: 65484, 65488 pb2: 65488, 65505
   pb3: 65505, 65513
   Получение адреса производного класса
   p_d==pb1? 65484 - 65484 p_d==pb2? 65484 - 65488 p_d==pb3?
   65484 - 65505</pre>
        <p>Таким образом, по адресу
        объекта производного класса можно
        непосредственно получить адрес любого
        его объекта базового класса. Обратная
        операция возможна, но требует явного
        использования операции приведения
        типа. Операции инкремента или
        декремента указателей на объекты
        базовых классов по отношению их
        вложенности в объект производного
        класса выполнять бессмысленно -
        значение указателя базового класса не
        будет адресовать объект такого класса
        в смежных объектах производного класса.
        <p>
        <div class="header"><a name="REF_1_4_5"></a>4.5. Виртуальные функции</div>
        <p>Определение связанных
        совокупностей объектов не обязательно
        одинаковых классов приходится
        проводить посредством использования
        указателей. Косвенная адресация
        объектов обеспечивает максимальную
        гибкость программы как по отношению к
        набору связываемых объектов, так и
        времени связывания.
        <p>Сочетание понятий указателя
        и производного класса в языке С++
        позволяет обеспечить возможность
        связывания объектов классов как по
        данным, так и функциям доступа вне
        зависимости от времени компиляции и/или
        выполнения. Ранее отмечалось, что между
        объектами базового и производного
        классов по указателям может быть
        установлено симметричное отношение.
        Отсюда следует, например, что функции
        базовых классов могут применяться к
        компонентам таких классов в объектах
        позднее определяемых производных
        классов. В результате, используя
        возможность переопределения функций,
        легко построить альтернативный
        интерфейс доступа к базовому классу.
        <p>Построение программ на
        основе использования связей между
        классами порождает проблему
        определения типа производного класса
        по известному указателю на объект
        базового класса.</p>
        <dl>
          <p>Возможны три основных
          способа решения этой проблемы:</p>
          <dd>
            <p>1) адресация объектов
            единственного типа;
          <dd>
            <p>2) включение в базовый
            класс поля признака типа;
          <dd>
            <p>3) использование <strong>виртуальных</strong>
            функций.</dd>
        </dl>
        <p>Обычно указатели на базовые
        классы используются при разработке так
        называемых контейнерных (вмещающих)
        классов. Примеры контейнерных классов:
        множества, векторы, списки, таблицы и т.п.</p>
        <p>В этом случае решение 1 дает
        однородные списки объектов одного типа.
        Решения 2 и 3 можно использовать для
        построения неоднородных списков
        списков объектов различных типов.
        Решение 3 - специальный вариант решения
        2, когда классификационным признаком
        выступает контролируемый компилятором
        тип объектов.</p>
        <p><strong>Виртуальными</strong>
        называют функции-элементы базового
        класса, объявляемые с атрибутом virtual,
        которые переопределены в производных
        классах. Атрибут virtual предписывает при
        вызове подобных функций через
        указатель выбирать экземпляр функции,
        соответствующий <strong>типу</strong>
        адресуемого объекта. Обычные
        переопределенные функции базового и
        производного классов выбираются при
        вызове через указатель по <strong>типу
        указателя</strong>.
        <p>Пример использования
        виртуальных функций: 
<pre><div class="code"> 
   #include &lt;stdio.h&gt;
   #define P(X) printf(&quot;\n\n* %s\n&quot;,X)

   struct base { 
      int n; 
      base(int x=0) { n=x; }

      virtual void f() { // определение виртуальной функции 
         printf(&quot;\nbase %d&quot;,n); 
      } 
   };

   struct de_1: base { 
      de_1(int x=0):base(x) { } // пустое тело допустимо ! 
      void f() { // переопределение виртуальной функции
         printf(&quot;\nde_1 %d&quot;,n); 
      } 
   };
        
   struct de_2: base { 
      de_2(int x=0):base(x) { } // пустое тело допустимо ! 
      void f() { // переопределение виртуальной функции
         printf(&quot;\nde_2 %d&quot;,n); 
      } 
   };
        
   void main() { 
      de_1 D1(1); 
      de_2 D2(2); 
      base B1(0);
   
      P(&quot;Неявный выбор функции по типу объекта&quot;); 
      B1.f(); 
      D1.f(); 
      D2.f();
   
      P(&quot;Явный выбор функции по типу объекта&quot;); 
      B1.base::f(); 
      D1.de_1::f(); 
      D2.de_2::f(); 
   
      P(&quot;Явный выбор функции базового класса&quot;);
      B1.base::f(); 
      D1.base::f(); 
      D2.base::f();
   
      P(&quot;Косвенный выбор по указателю на базовый класс (1)&quot;); 
      base *p; // указатель на базовый класс 
      p=&amp;B1; p-&gt;f(); 
      p=&amp;D1; p-&gt;f();
      p=&amp;D2; p-&gt;f();
        
      P(&quot;Косвенный выбор по указателю на базовый класс (2)&quot;); 
      ((base *)&amp;B1)-&gt;f(); 
      ((base *)&amp;D1)-&gt;f(); 
      ((base *)&amp;D2)-&gt;f(); 
   } </div> </pre>
        Результаты работы программы:
        <pre>   * Неявный выбор функции по типу объекта
   base 0 de_1 1 de_2 2
   * Явный выбор функции по типу  объекта
   base 0 de_1 1 de_2 2
   * Явный выбор функции базового класса
   base 0 base 1 base 2
   * Косвенный выбор по указателю на базовый класс (1)
   base 0 de_1 1 de_2 2
   * Косвенный выбор по указателю на базовый класс (2)
   base 0 de_1 1 de_2 2</pre>
<a href="4_5_1.exe">Выполнить</a>
        <p>Следующий пример программы
        демонстрирует применение виртуальных
        функций для классификации объектов,
        помещаемых в контейнер: 
<pre><div class="code">
   #include &lt;stdio.h&gt;

   class base { 
   public: 
      virtual void print() { 
          printf(&quot;\n base&quot;);
      } 
   }; 
   void print_set(base **x, int n) { 
      for (int i=0; i&lt;n; i++) {
         x[i]->print(); 
      } 
   } 

   class der_1: public base { 
   public: 
      void print() { 
         printf(&quot;\n der_1&quot;);
      } 
   }; 

   class der_2: public base { 
   public: 
      void print() { 
         printf(&quot;\n der_2&quot;);
      } 
   }; 

   class der_3: public base { 
   public: 
      void print() { 
         printf(&quot;\n der_3&quot;);
      } 
   }; 

   void main() { 
      base *x[5]; 
      x[0]=new base; 
      x[1]=new der_1; 
      x[2]=new der_2; 
      x[3]=new der_3; 
      x[4]=new der_1; 
	
      print_set(x,sizeof(x)/sizeof(*x));
   } </div></pre>
        Результаты работы программы:;
          <pre>   base
   der_1
   der_2
   der_3
   der_1</pre>
<a href="4_5_2.exe">Выполнить</a>
        <p>Таким образом, виртуальные
        функции позволяют автоматизировать
        процесс классификации объектов в
        неоднородной иерархии классов.
        Существенно, что базовые классы и их
        виртуальные функции-элементы могут
        быть созданы и откомпилированы до
        определения производных классов.
        Предоставляемая тем самым возможность
        эволюционного развития программы в
        большинстве случаев оказывается
        важнейшей ее качественной
        характеристикой. 
<pre><div class="code"> 
   #include &lt;stdio.h&gt;
   class base { 
   public: 
      int i; 
      base(int j):i(j) {}; 
      virtual void print(base &amp;x) { 
         printf(&quot;\nbase(%d)&quot;,x.i); 
      } 

      void operator!() { 
         print(*this);
      } 
   }; 

   class deri: public base { 
   public: 
      deri(int j):base(j) {} 
      void print(base &amp;x) { 
         printf(&quot;\nderi(%d)&quot;,x.i); 
      } 
   }; 

   void main() { 
      deri x(5);
      x.print(x); 
      !x; 
   } </div></pre>
        Результаты работы программы:
        <pre>   deri(5)
   deri(5) </pre>
<a href="4_5_3.exe">Выполнить</a>
        <p>Проведем эксперимент по
        оценке влияния атрибута virtual на размер
        объекта: 
<pre><div class="code"> 
   #include &lt;stdio.h&gt;
   struct b1 { // базовый класс с виртуальной функцией 
      int i; 
      virtual void f() { i=0; } 
   }; 
        
   class d1: b1 { 
   public: 
      void f() { i=0; } 
   };
        
   struct b2 { // базовый класс без виртуальной функции 
      int i; 
      void f() { i=0; } 
   };
        
   class d2: b2 { 
   public: 
      void f() { i=0; } 
   };

   #define P(X,Y) printf(&quot;\n sizeof(%s)=%d&quot;,X,sizeof(Y));
        
   void main() { 
      P(&quot;b1&quot;,b1); 
      P(&quot;d1&quot;,d1); 
      P(&quot;b2&quot;,b2);
      P(&quot;d2&quot;,d2); 
   } </div> </pre>
        Результаты работы программы:
        <pre>   sizeof(b1)=8
   sizeof(d1)=8
   sizeof(b2)=4
   sizeof(d2)=4 </pre>
<a href="4_5_4.exe">Выполнить</a>
        <ul>
          <p>Недостатки использования
          виртуальных функций:
          <li>
            <p>увеличение размера
            объекта из-за необходимости хранения
            указателя функции;
          <li>
            <p>обращение к виртуальным
            функциям через указатель фактически
            означает отказ от возможности
            встраивания функции, что снижает
            быстродействие программы.</li>
        </ul>
        <p>Явное указание имени класса
        при обращении к функции посредством
        операции &quot;::&quot; подавляет действие
        атрибута virtual. Этим можно
        воспользоваться для программирования
        задач с вызовом одной виртуальной
        функции из другой. Явное указание имени
        класса позволяет отказаться от
        накладных расходов на динамическое
        определениe типа объекта в ситуациях,
        когда между базовыми классами по сути
        задачи существует жесткая взаимосвязь.
        Последнее особенно важно в критических
        по быстродействию программах, когда
        желательно использовать механизм
        встраивания функции.
        <p>Обязательным требованием
        для работы механизма виртуальности
        является совпадение типа
        возвращаемого значения, числа и типов
        параметров виртуальной функции, const в
        базовом классе и во всех производных
        классах. В противном случае функция
        рассматривается как переопределенная.
        <p>Рассмотрим пример
        практического применения виртуальных
        функций в задаче формирования
        неоднородного списка студентов
        некоторой группы (рис.2)
        <div align="justify">
          <pre>              Графическая модель группы студентов

        ГРУППА СТУДЕНТОВ
          --------------------------------------¬
          ¦      г======================¬       ¦
          ¦      ¦ идентификатор группы ¦----¬  ¦
          ¦      L======================-    ¦  ¦
          ¦                                  ¦  ¦
          ¦          Список студентов группы ¦  ¦
          ¦                                  ¦  ¦
          ¦      г======================¬    ¦  ¦
          ¦      ¦      член группы     ¦-----  ¦
          ¦      L===T==============T===-       ¦
          L----------¦--------------¦------------
                     ¦              ¦
                     ¦              ¦     СТУДЕНТ-АКТИВИСТ
  СТУДЕНТ            ¦         -----+---------------------¬
 г===================¦==¬      ¦ г======================¬ ¦
 ¦     Фамилия, И.О.    ¦      ¦ ¦     Фамилия, И.О.    ¦ ¦
 L======================-      ¦ L==========T===========- ¦
                               ¦            ¦             ¦
                               ¦ г==========¦===========¬ ¦
                               ¦ ¦ Функция или должность¦ ¦
                               ¦ L======================- ¦
                               L---------------------------
<P>
                            Рис. 2.
</PRE><P>
        <p>Пример программы
        формирования списка студентов: 
<pre><div class="code">
   #include &lt;stdio.h&gt;
   #include &lt;string.h&gt;
   class student { // описание студента 
      char *name; // имя студента 
   public: 
      student(char *x) { // конструктор 
         name=new char[strlen(x)+1]; 
         strcpy(name,x); 
      } 
      ~student() { delete name; } // деструктор
        
      virtual void f() { // отображение объекта 
         printf(&quot;\n%s&quot;,name);
      } 
   };

   class lider: public student { // описание активиста
      char titul[10]; // наименование должности 
   public:
      lider(char *x, char *y):student(x) { // конструктор 
         strcpy(titul,y);
      }
      void f() { // отображение объекта 
         student::f(); // Явное обращение к объекту по его типу
         printf(&quot; - %s&quot;,titul); 
      } 
   };
        
   struct list; // вспомогательная декларация структуры
   struct list { // описание спискового класса
      list *next; // указатель следующего элемента
      void *item; // указатель поля данных
      void include(list **head, void *x) { // расширение списка 
         list *y=new list; 
         y-&gt;next=*head, *head=y, y-&gt;item=x;
      } 
   };
        
   class group { // описание группы студентов (контейнерный класс) 
      char ident[7]; // идентификатор группы
      list *head; // указатель списка студентов 
   public:
      group(char *x) { // конструктор группы 
         strcpy(ident,x);
         head=0; 
      }
        
      void operator+=(void *x) { // операция включения в группу 
         head-&gt;include(&amp;head,x); 
      }
        
      void operator()(); // описание операции вызова функции 
      ~group(); // описание деструктора 
   };
        
   void group::operator()() { // операция отображения группы 
      printf(&quot;\nСписок группы \&quot;%s\&quot;\n&quot;,ident);
      for (list *x=head; x!=0; x=x-&gt;next) ((student *)x-&gt;item)-&gt;f();
       // Косвенное обращение к объекту 
   }
        
   group::~group() { // деструктор 
      list *temp; while (head!=0)
      { // уничтожение элементов списка 
         head=(temp=head)-&gt;next;
         delete temp; 
      } 
   }
        
   void main() {
      group acs(&quot;Team-1&quot;); // Определение группы
   
    // Включение в группу рядовых студентов

      acs+=new student(&quot;st1&quot;); 
      acs+=new student(&quot;st2&quot;);
      acs+=new student(&quot;st3&quot;); 
      acs+=new student(&quot;st4&quot;);
       
    // Включение в группу студентов-активистов
        
      acs+=new lider(&quot;sh1&quot;,&quot;shief&quot;); 
      acs+=new lider(&quot;sh2&quot;,&quot;viceshief&quot;);
      acs+=new lider(&quot;sh3&quot;,&quot;profboss&quot;);
        
    // Отображение состава группы
        
      acs(); 
   } </div> </pre>
        Результаты работы программы:
        <pre>   Список группы &quot;Team-1&quot;
   sh3 - profboss 
   sh2 - viceshief 
   sh1 - shief 
   st4 
   st3
   st2 
   st1</pre>
<a href="4_5_5.exe">Выполнить</a>
        <p>Виртуальные функции
        позволяют достичь гибкости привязки
        функций к объектам за счет потерь
        памяти и быстродействия. Виртуальной
        может объявляться любая функция-элемент
        класса, за исключением конструктора.
        <p>
<pre><div class="code"> 
   // Применение виртуальных функций для реализации полиморфизма 
   // в иерархии классов 

   #include &lt;stdio.h&gt;
   #include &lt;stdlib.h&gt;

   // Иерархия без виртуальных функций 
   class base { 
   public: 
      int func(int x) { return x*x; } 
      int test(int x) { return func(x)&lt;&lt;1; } 
   }; 

   class derive: public base { 
   public: 
      int func(int x) { return x*x*x; } 
   }; 

   // Иерархия с виртуальными функциями 

   class Base { 
   public: 
      virtual int func(int x) { return x*x; } 
      int test(int x) { 
         return func(x)&lt;&lt;1; // return (this-&gt;func(x))&lt;&lt;1;
      } 
      int work(int x) { return Base::func(x)&lt;&lt;1; } 
   }; 
	
   class Derive: public Base { 
   public: 
      int func(int x) { return x*x*x; } 
   }; 
	
   void main() {
      derive d; 
      Derive D; 
      printf(&quot;\n %d&quot;,d.test(3)); 
      printf(&quot;\n %d&quot;,D.test(3)); 
      printf(&quot;\n %d&quot;,D.work(3)); 
   } </div></pre>
        Результаты работы программы:
        <pre>   18
   54
   18</pre>
<a href="4_5_6.exe">Выполнить</a>
<p>
        <div class="header"><a name="REF_1_4_6"></a>4.6. Понятие абстрактного
        класса</div>
        <p>Производный класс может не
        иметь функции, определенной в базовом
        классе как виртуальная. Версия функции
        базового класса доступна по
        определению производного класса с
        учетом правил защиты. В некоторых
        случаях возникают ситуации, когда при
        отсутствии виртуальной функции в
        производном классе использование ее
        версии из базового класса недопустимо.
        В таких случаях в базовом классе
        достаточно объявить строго или чисто
        (pure) виртуальную функцию, используя
        синтаксис:
          <pre><div class="code">   virtual тип_результата имя_функции(список_параметров)=0;
</div> </pre>
        <p>Версия функции с подобным
        прототипом должна обязательно
        определяться в производном классе.
        Любой класс, где объявлена хотя бы одна
        строго виртуальная функция, называется
        <strong>абстрактным.</strong> Определение
        объектов абстрактного класса
        невозможно. Абстрактный класс можно
        использовать только в качестве
        базового для наследования
        невиртуальных элементов в производных
        классах.
        <p>Иллюстрация использования
        абстрактного класса: 
<pre><div class="code">
   #include &lt;stdio.h&gt;
   class base { // абстрактный класс 
   public: 
      virtual void f()=0; // строго виртуальная функция 
   };

   class derive_1: public base { 
   public: 
      void f() { printf(&quot;\nderive_1&quot;); } 
   };

   class derive_2: public base { 
   public: 
      void f() { printf(&quot;\nderive_2&quot;); } 
   };

   class derive12: public derive_1 { 
   public: 
      void f() { printf(&quot;\nderive12&quot;); } 
   };

   void main() {
      derive_1 D_1; 
      derive_2 D_2; 
      derive12 D12; 
      base *pb;
  		
      pb=&amp;D_1; 
      pb-&gt;f(); // Выбор функции класса derive_1
      pb=&amp;D_2; 
      pb-&gt;f(); // Выбор функции класса derive_2
      pb=&amp;D12; 
      pb-&gt;f(); // Выбор функции класса derive12 
   } </div></pre>
        Результаты работы программы:
        <pre>   derive_1
   derive_2
   derive12 </pre>
<a href="4_6_1.exe">Выполнить</a>
        <p>Следующий пример
        демонстрирует возможность
        эволюционного процесса создания
        программы:
<pre><div class="code"> 
   #include &lt;stdio.h&gt;
   class base { 
   protected: 
      int width; 
   public: 
      base(int n=0):width(n) {}
      virtual void print()=0; 
   }; 
	
   class line { 
      int i; 
   public: 
      line(int j=0):i(j) {} 
      void operator=(int j) { i=j; } 
      void operator&lt;&lt;(base &amp;x) { 
         printf(&quot;\n%d) &quot;,++i); 
         x.print(); 
      } 
   }; 

   class dw1: public base { 
      int value; 
   public: 
         virtual void print() { printf(&quot;%*d&quot;,width,value); } 
         dw1(int x, int w=0):base(w),value(x) {} 
   }; 

   class dw2: public base { 
      int value; 
   public:
      virtual void print(); 
      dw2(int x, int w=0):base(w),value(x) {} 
   }; 

   void dw2::print() { 
      printf(&quot;%d &quot;,value); 
      for (int i=0; i&lt;width; i++)
         printf("?");
   }

   void main() {
      line out;
      for (int i=0; i&lt;5; i++) {
         out&lt;&lt;dw1(i,i);
      }
      out=0;
      for (i=0; i&lt;5; i++) {
         out&lt;&lt;dw2(i,i+1);
      }
   }</div> </pre>
        Результаты работы программы:
        <pre>   1) 0
   2) 1
   3)  2
   4)   3
   5)    4
   1) 0 ?
   2) 1 ??
   3) 2 ???
   4) 3 ????
   5) 4 ????? </pre>
<a href="4_6_2.exe">Выполнить</a>
        <p>Понятие абстрактного класса
        оказывается весьма полезным средством
        отражения общих свойств некоторых
        сущностей реального мира. Создаваемая
        на основе абстрактного класса иерархия
        производных классов может оперировать
        с объектами, которые определяются
        независимо от состава операций.
        Например, в библиотечных классах
        системы Turbo-C++ определена сложная
        иерархия классов абстрактных структур
        данных, отражающая понятия стека,
        очереди, дека, массива и т.п. Функции
        манипуляции соответствующими этим
        понятиям объектами определены в
        производных классах, откомпилированы и
        помещены в библиотеку объектных
        модулей. Пользователь может определить
        производный класс конкретных объектов
        на основе базового абстрактного класса
        таких структур данных, после чего
        открывается возможность работы с
        любыми объектами иерархии.
        <hr width="100%" SIZE="1">
        <a href="#REF_1_C">Начало</a>
<p>
        <div class="header"><a name="REF_1_5"></a>5. ОБЪЕКТНО-ОРИЕНТИРОВАННЫЙ
        ВВОД-ВЫВОД НА ЯЗЫКЕ С++</div>
        <div class="header"><a name="REF_1_5_1"></a>5.1. Классы и потоки ввода-вывода</div>
        <p>В языках С и С++ нет
        собственных лингвистических
        конструкций ввода-вывода. Система
        ввода-вывода создается средствами
        языка в конкретной вычислительной
        среде. В языке С для этих целей
        используется процедурный подход,
        реализуемый библиотеками функций
        ввода-вывода. В языке С++ наряду с этим
        обычно реализуется объектно-ориентированный
        подход на основе библиотек классов
        ввода-вывода. Очевидно, что оба подхода
        оказываются системно-зависимыми, хотя
        наблюдается тенденция к
        стандартизации имен функций и/или
        классов ввода-вывода. Один из
        характерных принципов построения
        подобных систем - преемственность для
        совместимости старых программ с новыми
        системами программирования.
        Рассмотрим пример объектно-ориентированного
        подхода к построению средств ввода-вывода
        в системах С++ фирмы BORLAND. Схема иерархии
        классов ввода-вывода в Borland C++
        соответствует следующему фрагменту
        описания:
        <pre><div class="code">
   // Классы потокового ввода-вывода
   //
   class ios { /* ... */ };
   class istream : virtual public ios { /* ... */ };
   class ostream : virtual public ios { /* ... */ };
   class iostream : public istream, public ostream { /* ... */ };
   //
   // Классы предопределенных стандартных потоков ввода-вывода
   //
   class istream_withassign : public istream { /* ... */ };
   class ostream_withassign : public ostream { /* ... */ };
   class iostream_withassign : public iostream { /* ... */ };
   //
   // Классы файлового ввода-вывода
   //
   class fstreambase : virtual public ios { /* ... */ };
   class ifstream : public fstreambase, public istream {/* ... */ }; 
   class ofstream : public fstreambase, public ostream { /* ... */ }; 
   class fstream : public fstreambase, public iostream { /* ... */ }; 
   // 
   // Классы строкоориентированного ввода-вывода 
   //
   class strstreambase : public virtual ios { /* ... */ }; 
   class istrstream : public strstreambase, public istream { /* ... */ }; 
   class ostrstream : public strstreambase, public ostream { /* ... */ }; 
   class strstream : public strstreambase, public iostream { /* ... */ }; 
   // 
   // Классы буферов ввода-вывода 
   // 
   class streambuf { /* ... */ };
   class filebuf : public streambuf { /* ... */ }; 
   class strstreambuf : public streambuf { /* ... */ };</div></pre>
        <dl>
          <p>Исходный базовый класс ios, а
          также большинство производных
          классов определены в файле iostream.h.
          Класс ios предназначен для отображения
          состояния процесса ввода-вывода.
          Производные классы отражают:
          <dd>
            <p>направление передачи
            данных (i - ввод, o - вывод, io - ввод-вывод);
          <dd>
            <p>вид источника данных (f -
            файл, str - строка символов);
          <dd>
            <p>способ организации
            процесса обмена (буферизация,
            форматирование) и др.</dd>
        </dl>
        <dl>
          <p>Операции ввода-вывода
          рассматриваются на двух уровнях:
          <dd>
            <p>нижний или файловый
            уровень - файл как именованная
            последовательность байтов, имеющая
            начало и конец;
          <dd>
            <p>верхний уровень -
            последовательный <strong>поток</strong>
            объектов разных типов, отображаемый
            на файл.</dd>
        </dl>
        <p>Функции ввода-вывода
        выполняют прямое и/или обратное
        преобразование между уровнями. Понятие
        потока соответствует объекту класса с
        именем ...stream. Манипулирование потоками
        требует определения объекта
        соответствующего класса.</p>
        <p>В системе С++ имеется четыре
        определенные по умолчанию потока:
        <div align="justify">
          <pre>---------------T--------------------T---------------------------
   Имя объекта ¦     Имя класса     ¦  Аналог потока в языке С
---------------+--------------------+---------------------------
     cin       ¦ istream_withassign ¦         stdin
     cout      ¦ ostream_withassign ¦         stdout
     cerr      ¦ ostream_withassign ¦  stderr (без буфера)
     clog      ¦ ostream_withassign ¦  stderr (с буфером)
</pre>
        </div>
        <p>При небходимости работы с
        файлами требуется явное определение
        объектов соответствующих классов.
        <p>
        <div class="header"><a name="REF_1_5_2"></a>5.2. Ввод-вывод
        данных базовых типов</div>
        <p>Для любых потоков определены
        две операции:
        <dl>
          <dd>
            <p>&gt;&gt; - извлечение (extraction)
            данных из потока;
          <dd>
            <p>&lt;&lt; - запись (insertion) данных
            в поток.</dd>
        </dl>
        <p>Функции-элементы,
        определяющие перечисленные операции,
        многократно переопределены для приема
        всех основных типов данных. Пример
        декларации операций вывода в Тurbo-C++:
        <pre><div class="code">     
   class ostream {
      // ...
   public:
      ostream&amp; operator&lt;&lt; (  signed char);
      ostream&amp; operator&lt;&lt; (unsigned char);
      ostream&amp; operator&lt;&lt; (short);
      ostream&amp; operator&lt;&lt; (unsigned short);
      ostream&amp; operator&lt;&lt; (int);
      ostream&amp; operator&lt;&lt; (unsigned int);
      ostream&amp; operator&lt;&lt; (long);
      ostream&amp; operator&lt;&lt; (unsigned long);
      ostream&amp; operator&lt;&lt; (float);
      ostream&amp; operator&lt;&lt; (double);
      ostream&amp; operator&lt;&lt; (long double);
      ostream&amp; operator&lt;&lt; (const   signed char*);
      ostream&amp; operator&lt;&lt; (const unsigned char*);
      ostream&amp; operator&lt;&lt; (void*);
      // ...
   };</div></pre>
        <p>Пример декларации операций
        ввода в Turbo-C++:
        <pre><div class="code"> 
   class istream {
      // ...
   public:
      istream&amp; operator&gt;&gt; (  signed char*);
      istream&amp; operator&gt;&gt; (unsigned char*);
      istream&amp; operator&gt;&gt; (unsigned char&amp;);
      istream&amp; operator&gt;&gt; (  signed char&amp;);
      istream&amp; operator&gt;&gt; (short&amp;);
      istream&amp; operator&gt;&gt; (int&amp;);
      istream&amp; operator&gt;&gt; (long&amp;);
      istream&amp; operator&gt;&gt; (unsigned short&amp;);
      istream&amp; operator&gt;&gt; (unsigned int&amp;);
      istream&amp; operator&gt;&gt; (unsigned long&amp;);
      istream&amp; operator&gt;&gt; (float&amp;);
      istream&amp; operator&gt;&gt; (double&amp;);
      istream&amp; operator&gt;&gt; (long double&amp;);
      // ...
   };</div></pre>
        <p>Функции определения
        операторов ввода-вывода здесь имеют
        первый неявный операнд - указатель на
        объект класса ostream или istream и возвращают
        ссылку на объект того же класса. Это
        позволяет использовать ассоциативные
        операции ввода-вывода: 
<pre><div class="code"> 
   #include &lt;iostream.h&gt;
   void main() { 
      int x,y,z;
      cout&lt;&lt;&quot;\n\a* x,y,z-?&quot;;
      cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; // последовательный ввод x,y,z 
      cout&lt;&lt;&quot;\n data is&quot;&lt;&lt;x&lt;&lt;y&lt;&lt;z; // последовательный вывод
   }  </div></pre>
	Результаты работы программы:
        <pre>   * x,y,z-? 1 2 3
   data is 123 </pre>
<a href="5_2.exe">Выполнить</a>
        <p>Здесь возникают вопросы
        управления форматом ввода-вывода и
        контроля исключительных ситуаций.
        Классический вариант языка С++
        предполагает наличие библиотечной
        функции обобщенного форматирования
        <pre><div class="code">  
   char *form(char *format,...);</div> </pre>
        <p>Выражение form(format, params)
        эквивалентно выражению
        <pre><div class="code">  
   (sprintf(s, format, params), s); </div></pre>
        <p>(предполагается, что s -
        строка символов). В результате
        форматирование выводимых данных
        реализуется в стиле функций языка С:
        <pre><div class="code">  
   cout&lt;&lt;form(&quot;\n data is %d %d %d&quot;,x,y,z);</div>  </pre>
        <p>В современных версиях С++
        средства форматирования представлены
        элементами классов ввода-вывода.
        <p>
        <div class="header"><a name="REF_1_5_3"></a>5.3. Ввод-вывод
        объектов определенных пользователем
        классов</div>
        <p>Не обсуждая подробности
        управления вводом-выводам (форматирование,
        исключительные ситуации и т.п.),
        рассмотрим стандартные схемы объектно-ориентированного
        программирования ввода-вывода.
        Определение операций ввода-вывода для
        определенных пользователем классов
        рекомендуется проводить путем
        дополнительного переопределения
        операторов &quot;&gt;&gt;&quot; и &quot;&lt;&lt;&quot; для
        подходящих библиотечных классов.
        Пример определения операторов ввода-вывода:
        <pre><div class="code"> 
   #include &lt;iostream.h&gt;
   class our_class { 
   public: 
      int data; 
   };

   ostream&amp; operator&lt;&lt;(ostream&amp; output, our_class&amp; object) { 
      output&lt;&lt;&quot;{{&quot;&lt;&lt;object.data&lt;&lt;"}}";
      return output;
   }

   istream&amp; operator&gt;&gt;(istream&amp; input, our_class&amp; object) { 
      input&gt;&gt;object.data; 
      return input; 
   }

   void main() { 
      our_class x;
      while (cout&lt;&lt;&quot;\n\a* data-? &quot;, cin&gt;&gt;x) 
         cout&lt;&lt;&quot;\n data is &quot;&lt;&lt;x;
   } </div></pre>
        Результаты работы программы:
        <pre>   * data-? 1
   data is {{1}}
   * data-? 2
   data is {{2}}
   data-? e</pre>
<a href="5_3.exe">Выполнить</a>
        <p>Приведенная схема не требует
        вмешательства в определения
        библиотечных классов ввода-вывода и не
        зависит от версии таких классов.
        <p>
        <div class="header"><a name="REF_1_5_4"></a>5.4. Контроль
        исключительных ситуаций ввода-вывода</div>
        <p>Ключевая информация о
        состоянии обмена любого потока
        предоставляется элементами базового
        класса ios. Функция получения информации
        о состоянии потока:
        <pre><div class="code">  
   int rdstate();  // чтение битов состояния</div> </pre>
        <p>Возможные состояния потока
        перечислены в классе ios:
        <pre><div class="code">  
   enum io_state { // биты состояния потока
      goodbit  = 0x00,  // все в порядке - ошибок нет
      eofbit   = 0x01,  // конец файла
      failbit  = 0x02,  // ошибка без потери символов
      badbit   = 0x04,  // ошибка с потерей данных
      hardfail = 0x80   // грубая ошибка
   };</div></pre>
        <p>(обращение к элементам
        такого перечисления возможно
        посредством использования операции
        &quot;::&quot;, например, ios::goodbit).
        <p>Функции проверки конкретных
        исключительных ситуаций:
        <pre><div class="code">  
   int eof();  // конец файла
   int fail(); // неудачная операция
   int bad();  // наличие ошибок
   int good(); // отсутствие ошибок</div></pre>
        <p>Смысл приведенных функций
        можно выявить путем анализа исходного
        текста определения класса ios в файле
        iostream.h:
        <pre><div class="code">
   class ios {
      // ...
   public:
      int  state;       // биты состояния потока
      long x_flags;     // биты флагов форматирования
      int  x_precision; // точность вывода данных типа float
      int  x_width;     // ширина поля вывода
      int  x_fill;      // символ заполнения потока
      // ...
   };
   inline int ios::rdstate() { return state; } 
   inline int ios::eof() { return state &amp; eofbit; } 
   inline int ios::fail() {return state &amp; (failbit | badbit | hardfail); } 
   inline int ios::bad() { return state &amp; (badbit | hardfail); } 
   inline int ios::good() { return state == 0; } 
   inline long ios::flags() { return x_flags; }	 </div></pre>
        <p>Функция установки текущего
        состояния потока:
        <pre><div class="code">  
   void  clear(int =0); // установка битов состояния</div></pre>
        <p>Обращение к функции clear
        позволяет сбросить биты ошибок или
        принудительно установить некоторые
        ситуации для последующего анализа.
        Нулевое значение параметра означает
        запрос сброса битов ошибок. Следует
        учитывать, что после любой ошибки
        операции над потоком игнорируются до
        сброса битов ошибок. Пример программы с
        контролем исключительных ситуаций: 
<pre><div class="code">
   #include &lt;iostream.h&gt;
   #include &lt;math.h&gt;
   #include &lt;stdlib.h&gt;

   void main() { 
      int i; 
      double x; 
      for (;; ) { 
         cout&lt;&lt;&quot;\n?? &quot;; 
         cin&gt;&gt;x; 
         switch(i=cin.rdstate()) { 
              case ios::goodbit:cout&lt;&lt;&quot;sin(&quot;&lt;&lt;x&lt;&lt;")="&lt;&lt;sin(x);
              break;
              case ios::eofbit: exit(0);
              default:cout&lt;&lt;&quot;\n\a* Error &quot;&lt;&lt;i;
              cin.seekg(0,ios::end); // Пропуск введенных символов
              cin.clear(); // Сброс битов ошибок
         }
      }
   } </div></pre>
        Результаты работы программы:
        <pre>   ?? 5
   sin(5)=-0.958924
   ?? e
   * Error 2 ??^C</pre>
        <a href="5_4_1.exe">Выполнить</a>
        <p>Проверка наличия ошибок
        возможна и посредством операторов:
        <pre><div class="code">  
   operator void* (); // отсутствие ошибок
   int operator! ();  // наличие ошибок</div></pre>
        <p>Пример программы с контролем
        глобального состояния потоков: 
<pre><div class="code">
   #include &lt;iostream.h&gt;
   #include &lt;math.h&gt;

   void main() { 
      double x; 
      cout&lt;&lt;&quot;\nКосинус-калькулятор\a\n&quot;;
      while(cout&lt;&lt;&quot;\n\a* x-? &quot;) { 
          if (!(cin&gt;&gt;x)) break; // аналог: if (cin&gt;&gt;x, cin.bad()) break; 
          cout&lt;&lt;&quot; cos(&quot;&lt;&lt;x&lt;&lt;")="&lt;&lt;cos(x);
      }
   }</div></pre>
       Результаты работы программы:
       <pre>   Косинус-калькулятор
   * x-? 4 cos(4)=-0.653644 * x-? r</pre>
<a href="5_4_2.exe">Выполнить</a>
<p>
        <div class="header"><a name="REF_1_5_5"></a>5.5. Форматный ввод-вывод</div>
        <p>Базовый класс ios предоставляет
        возможность управления
        преобразованием форм представления
        данных с помощью флагов и параметров
        форматирования. Функции чтения/установки/сброса
        флагов форматирования:
        <pre><div class="code">   
   long flags(); // чтение поля флагов
   long flags(long); // чтение и установка поля флагов</div></pre>
        <p>Возможные флаги форматирования
        определены в классе ios элементами
        перечисления
        <pre><div class="code">
   enum {
      skipws    = 0x0001, // пропуск пустого пространства при вводе
      left      = 0x0002, // &quot;левое&quot; выравнивание при выводе
      right     = 0x0004, // &quot;правое&quot; выравнивание при выводе
      internal  = 0x0008, // знак или признак основания системы
                          // счисления не отделять от данных
      dec       = 0x0010, // десятичное преобразование
      oct       = 0x0020, // восьмеричное преобразование
      hex       = 0x0040, // шестнадцатеричное преобразование
      showbase  = 0x0080, // вывод признак основания
      showpoint = 0x0100, // вывод десятичной точки
      uppercase = 0x0200, // верхний регистр при выводе hex-данных
      showpos   = 0x0400, // вывод знака '+' для положительных чисел
      scientific= 0x0800, // формат вида 1.2345E2 вывода float-данных
      fixed     = 0x1000, // формат вида 123.45 вывода float-данных
      unitbuf   = 0x2000, // очистка буфера потоков после вывода
      stdio     = 0x4000  // очистка буфера потоков stdout и stderr
                          // после вывода
   };</div></pre>
        <p>Для работы с флагами форматирования
        могут быть использованы следующие
        функции-элементы: long setf(long setbits, long field) -
        сброс флагов, соответствующим единицам
        в поле field, установка их по значению
        поля setbits и возврат первоначального
        поля флагов; long setf(long) - чтение и
        установка флагов; long unsetf(long) - чтение и
        сброс помеченных единицами флагов. C
        целью удобного доступа к некоторых
        связанным флагам в классе ios определены
        константы для второго параметра
        функции setf:
        <pre><div class="code">  
   static const long basefield;   // dec | oct | hex
   static const long adjustfield; // left | right | internal
   static const long floatfield;  // scientific | fixed </pre></div>
        <p>Таким образом, доступ к объектам
        класса ios можно программировать без
        записи числовых констант:
        <pre><div class="code">  
   cout.setf(ios::left);
   cout.setf(ios::right | ios::fixed);
   cout.setf(ios::right + ios::hex + ios::showbase);
   cin.setf(ios::oct,ios::basefield); </div></pre>
        <p>Кроме вызова функции setf, cуществует
        другой способ установки основания
        системы счисления. Классы istream и ostream
        включают дополнительное
        переопределение операторов ввода и
        вывода:
        <pre><div class="code">
   istream&amp; istream::operator&gt;&gt;(istream&amp; (*f)(istream&amp;)){ /*...*/ }
   ostream&amp; ostream::operator&lt;&lt;(ostream&amp; (*f)(ostream&amp;)){ /*...*/ } </div></pre>
        <p>В файле iostream.h описаны так называемые <strong>функции
        - манипуляторы</strong>:
        <pre><div class="code">
   ios&amp; dec(ios&amp;); // установка десятичного преобразования
   ios&amp; hex(ios&amp;); // установка шестнадцатеричного преобразования
   ios&amp; oct(ios&amp;); // установка восьмеричного преобразования </div> </pre>
      <p>Отсюда следует, что основание системы
        исчисления может быть установлено
        непосредственно операторами ввода и
        вывода:
        <pre><div class="code">  
   int data;
   cin&gt;&gt;hex&gt;&gt;data; // ввод шестнадцатеричного числа
   cin&gt;&gt;dec; // переключение на ввод десятичных чисел
   // ...
   cout&lt;&lt;dec&lt;&lt;data; // вывод десятичного числа
   cout&lt;&lt;hex&lt;&lt;data; // вывод шестнадцатеричного числа </div></pre>
        <p>Последний способ отличается
        лаконичностью записи выражений.
        <p>Примеры других функций-манипуляторов:
        <pre><div class="code">
   ostream&amp; endl(ostream&amp;);  // переход на новую строку
   ostream&amp; ends(ostream&amp;);  // добавление символа конца строки
   ostream&amp; flush(ostream&amp;); // вывод содержимого буфера потока
   istream&amp; ws(istream&amp;);    // пропуск &quot;пробелов&quot; при вводе </div></pre>
        <p>Рассмотрим набор функций для чтения и/или
        установки количественных параметров
        формата - ширины поля, символа
        заполнения неиспользованных элементов
        поля и точности вывода данных с
        плавающей точкой.
        <p>Функции чтения/установки ширины поля
        вывода:
        <pre><div class="code">  
   int width() - чтение текущей ширины;
   int width(int) - чтение текущей и установка новой ширины. </div></pre>
        <p>Установленное значение ширины
        действительно только для очередной
        операции вывода. Если ширина поля
        недостаточна, то она расширяется для
        предотвращения потери данных. По
        умолчанию ширина поля нулевая.
        <p>Функции чтения/установки символа
        заполнения потока:
        <pre><div class="code">  
   char fill() - чтение символа заполнения;
   char fill(char) - чтение и установка символа заполнения. </div></pre>
        <p>Функции чтения/установки точности
        вывода данных с плавающей точкой:
        <pre><div class="code">  
   int precision() - чтение точности вывода;
   int precision(int) - чтение и установка точности вывода. </div></pre>
        <p>Пример программы с форматным вводом-выводом:
        <pre><div class="code">
   #include &lt;iostream.h&gt;

   // Процедура отображения целого числа

   void intout(int x) { 
      long old_flg=cout.flags(); // Сохранение флагов форматирования 
      cout&lt;&lt;endl&lt;&lt;"Dec: "&lt;&lt;dec&lt;&lt;x;
      cout.setf(ios::showbase);
      cout&lt;&lt;endl&lt;&lt;"Oct: "&lt;&lt;oct&lt;&lt;x;
      cout&lt;&lt;endl&lt;&lt;"Hex: "&lt;&lt;hex&lt;&lt;x;
      cout.setf(old_flg); // Восстановление флагов форматирования
   }

   // Программа демонстрации форматного ввода-вывода

   void main() {
      int i; 
      double d;
      cout&lt;&lt;endl&lt;&lt;"Dec-? ";
      cin&gt;&gt;dec&gt;&gt;i; 
      intout(i); 
      cout&lt;&lt;endl&lt;&lt;"Oct-? ";
      cin&gt;&gt;oct&gt;&gt;i; 
      intout(i);
      cout&lt;&lt;endl&lt;&lt;"Hex-? ";
      cin&gt;&gt;hex&gt;&gt;i; 
      intout(i);
      
      cout&lt;&lt;endl&lt;&lt;"Double-? ";
      cin&gt;&gt;d; 
      cout&lt;&lt;d;
      
      cout.width(20), cout.setf(ios::left), cout.fill('_'); 
      cout&lt;&lt;endl&lt;&lt;d;
      cout.width(20), cout.precision(3);
      cout&lt;&lt;endl&lt;&lt;d;
      cout.width(20), cout.setf(ios::right), cout.unsetf(ios::left);
      cout&lt;&lt;endl&lt;&lt;"End";
   } </div>  </pre>
        Результаты работы программы:
        <pre>   Dec-? 10
   Dec: 10 
   Oct: 012 
   Hex: 0xa 
   Oct-? 10
   Dec: 8 
   Oct: 010 
   Hex: 0x8 
   Hex-? 10
   Dec: 16 
   Oct: 020 
   Hex: 0x10 
   Double-? 123.456789 
   123.456789
   123.456789__________ 
   123.457_____________
    _________________End</pre>
<a href="5_5_1.exe">Выполнить</a>
        <p>Дополительные возможности по
        управлению форматированием
        предоствляют функции-манипуляторы,
        определенные в файле iomanip.h:
        <pre><div class="code">  
   setbase(int base) - установка основания системы исчисления base = 0, 8, 10, или 16<br>   (0 - десятичное основание при выводе, а при вводе основание<br>   определяется автоматически);
   resetiosflags(long flags) - сброс указываемых флагов форматирования;
   setiosflags(long flags) - установка указываемых флагов форматирования;
   setfill(int fill) - установка указанного символа заполнения потока;
   setprecision(int prec) - установка точности вывода чисел с плавающей точкой;
   setw(int width) - установка ширины поля ввода или вывода.
</div></pre>
        <p>Пример использования манипуляторов
        потока: 
<pre><div class="code">
   #include &lt;iostream.h&gt;
   #include &lt;iomanip.h&gt;

   void main(void) { 
      int i=123;
      float f=123.456789; 
      cout&lt;&lt;endl&lt;&lt;setbase(10)&lt;&lt;setw(10)&lt;&lt;i;
      cout&lt;&lt;endl&lt;&lt;setbase(8)&lt;&lt;i;
      cout&lt;&lt;endl&lt;&lt;setfill('.')&lt;&lt;setw(10)&lt;&lt;i;
      cout&lt;&lt;endl&lt;&lt;setprecision(3)&lt;&lt;setw(10)&lt;&lt;f;
      cout&lt;&lt;endl&lt;&lt;setw(10)&lt;&lt;f&lt;&lt;setw(8)&lt;&lt;i;
   } </div> </pre>
        Результаты работы программы:
        <pre>   123
   173
   .......173
   ...123.457
   ...123.457.....173 </pre>
        <p>Технология программирования
        собственных манипуляторов: 
<pre><div class="code">
   #include &lt;iostream.h&gt;

   ostream& func(ostream &amp; x) { 
      cout&lt;&lt;endl&lt;&lt;"func";
      return x;
   }

   class my_manip {
      int n;
   public:
      my_manip(int i):n(i) {}
      friend ostream& operator&lt;&lt;(ostream & x, my_manip y) {
         x&lt;&lt;endl&lt;&lt;y.n&lt;&lt;" my_manip ?";
         return x;
      }
   };

   void main() {
      cout&lt;&lt;func&lt;&lt;my_manip(1999)&lt;&lt;func;
   }</div> </pre>
        Результаты работы программы:
        <pre>   func
   1999 my_manip
   func </pre>
<a href="5_5_3.exe">Выполнить</a>
        <p>
        <div class="header"><a name="REF_1_5_6"></a>5.6. Бесформатный ввод-вывод</div>
        <p>Рассматриваемые здесь функции
        предназначены для обмена между
        потоками и полями данных,
        рассматриваемыми как
        последовательности байтов. Ввод строки
        символов с указанием максимальной
        длины и символа-разделителя (символ-разделитель
        в строку не включается, строка
        завершается нулевым символом):
        <pre><div class="code">  
   istream&amp; get(  signed char*, int, char = '\n');
   istream&amp; get(unsigned char*, int, char = '\n'); </div></pre> 
     <p>Ввод заданного количества символов:
        <pre><div class="code">  
   istream&amp; read(  signed char*, int);
   istream&amp; read(unsigned char*, int); </div></pre>
        <p>Ввод строки символов с указанием
        максимальной длины и символа-разделителя
        включением символа-разделителя:
        <pre><div class="code">  
   istream&amp; getline(  signed char*, int, char = '\n');
   istream&amp; getline(unsigned char*, int, char = '\n'); </div></pre>
        <p>Ввод одиночных символов:
        <pre><div class="code">  
   int get();
   istream&amp; get(unsigned char&amp;);
   istream&amp; get(  signed char&amp;); </div></pre>
        <p>Последний вариант функций ввода
        символа допускает использование
        результата операции ее вызова в
        сложных выражениях ассоциативного
        типа. Пример программы: 
<pre><div class="code">
   #include &lt;iostream.h&gt;

   void main() { 
      char i; 
      int j;
      (cin&gt;&gt;ws).get(i)&gt;&gt;j; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j;
   } </div> </pre>
        Результаты работы программы:
        <pre>   r   123
   r 123</pre>
<a href="5_6.exe">Выполнить</a>
        <p>Чтение очередного символа без
        извлечения из потока:
        <pre><div class="code">  
   int peek(); </div></pre>
        Количество символов, полученных
        последней операцией ввода:
        <pre><div class="code">  
   int gcount(); </div></pre>
        Возврат символа в поток:
        <pre> <div class="code">   istream&amp; putback(char);</div> </pre>
        <p>Пропуск заданного количества
        символов с остановкой в позиции
        разделителя:
        <pre><div class="code">  
   istream&amp; ignore(int =1, int = EOF); </div></pre>
        Вывод одиночного символа:
        <pre><div class="code">  
   ostream&amp; put(char); </div></pre>
        <p>Вывод массива символов указанной
        длины:
        <pre><div class="code">  
   ostream&amp; write(const   signed char*, int);
   ostream&amp; write(const unsigned char*, int); </div></pre>
        <p>Ввод символов в заданный буфер потока,
        исключая символ-разделитель:
        <pre><div class="code">   
   istream&amp; get(streambuf&amp;, char = '\n'); </div></pre>
        <p align="justufy">Требуемый здесь указатель на буфер
        потока можно получить обращением к
        функции
        <pre><div class="code">  
   streambuf *ios::rdbuf(); </div></pre>
        <p>
        <div class="header"><a name="REF_1_5_7"></a>5.7. Управление
        позиционированием потока</div>
        <p>Если рассматривать поток как
        последовательно заполняемый или
        читаемый массив символов, то текущая <strong>позиция</strong>
        соответствует индексу очередного
        символа, участвующего в операции
        обмена данными. Манипулирование
        позициями позволяет часто упростить и
        повысить эффективность операций ввода-вывода
        за счет отказа от последовательного
        сканирования потока. Рассмотрим набор
        функций-элементов, оперирующих с
        текущей позицией потока. Файл iostream.h
        содержит определение двух типов данных:
        <pre><div class="code">  
   typedef long streampos; // абсолютная позиция потока
   typedef long streamoff; // относительная позиция потока </div></pre>
        Чтение значения указателя текущей
        позиции потока:
        <pre><div class="code">
   streampos tellg(); // поток ввода istream
   streampos tellp(); // поток вывода ostream </div></pre>
        Установка указателя текущей позиции
        потока:
        <pre><div class="code">  
   istream&amp; seekg(streampos); // поток ввода istream
   ostream&amp; seekp(streampos); // поток вывода ostream </div></pre>
        <p>Относительное смещение указателя
        текущей позиции потока:
        <pre><div class="code">  
   istream&amp; seekg(streamoff,seek_dir); // поток ввода istream
   ostream&amp; seekp(streamoff,seek_dir); // поток вывода ostream </div></pre>
        <p>Определение символических констант
        направления смещения:
        <pre><div class="code">  
   enum seek_dir { // Точка отсчета направления смещения
      beg=0, // начало потока
      cur=1, // текущая позиция
      end=2  // конец потока
    }; </div></pre>
        <p>Пример программы с позиционированием
        потока cin рассматривался в подразделе
        2.4.
        <pre><div class="code">  
   //...
   cin.seekg(0,ios::end); // Пропуск введенных символов
   //... </div></pre>
        <p>Здесь запрашивается переход в
        конечную позицию потока введенных
        символов для игнорирования ошибочных
        символов. Относительное смещение
        позиции допускается не для всех типов
        потоков.
        <p>
        <div class="header"><a name="REF_1_5_8"></a>5.8. Связанные потоки</div>
        <p>С любым из потоков ввода может
        ассоциироваться так называемый <strong>связанный</strong>
        выходной поток (tied stream), который
        позволяет выполнять логически
        корректные двунаправленные операции
        ввода-вывода: если начинается ввод
        данных, то содержимое буфера вывода
        будет обязательно выдано на носитель
        данных. По умолчанию с потоком cin связан
        поток cout. В любой момент времени с
        потоком ввода может быть связан только
        один поток вывода. Управление
        связыванием реализуется функциями:
        ostream* tie() - чтение указателя связанного
        потока; ostream* tie(ostream*) - чтение указателя
        связанного потока и установка новой
        связи по указателю потока вывода.
        <p>Вызов функции tie с нулевым параметром
        приводит к разрыву связи потоков.
        Например, оператор
        <pre><div class="code">  
   ostream *old_flw=cin.tie(0); </div></pre>
        <p>устанавливают асинхронный режим
        обмена через потоки cin и cout.
        Восстановление связи можно выполнить
        оператором
        <pre><div class="code">  
   cin.tie(old_flw); </div></pre>
        Упрощенный вариант приведенных
        действий:
        <pre><div class="code">  
   cin.tie(0);
   cin.tie(&amp;cout); </div></pre>
        <p>
        <div class="header"><a name="REF_1_5_9"></a>5.9. Создание и
        организация взаимодействия потоков</div>
        <p>До сих пор в примерах программ
        использовались предопределенные по
        умолчанию потоки. Практика
        программирования часто требует
        использования потоков,
        ассоциированных не только с
        стандартными файлами ввода-вывода, но и
        с другими файлами либо областями
        памяти. Важнейший элемент любого
        потока - буфер потока, представляемый
        объектами производных классов на
        основе базового класса streambuf <a href="#REF_1_5_1">(см.
        5.1)</a>. Именно на элементах такого класса
        определены функции стратегии обмена
        данными. Буфер потока среди элементов
        данных включает, кроме буфера ввода-вывода,
        набор переменных состояния обмена.
        Конструирование потока означает его
        ассоциацию с буфером подходящего типа.
        В системах программирования С++ фирмы
        Borland поддерживается два вида
        специализированных высокоуровневых
        потоков обмена:
        <dl>
          <dd>файловые потоки (классы fstream, ifsream и
            ostream - определены в файле fstream.h);
          <dd>строкоориентированные потоки (классы
            strstream, istrstream и ostrstream - определены в
            файле strstrea.h).</dd>
        </dl>
        <p>Если специализация потокового объекта
        нежелательна, то можно использовать
        универсальные потоки обмена (классы
        iostream, istream и ostream - определены в файле
        iostrstream.h). Однако в этом случае требуется
        явное установление ассоциации со
        специализированным буфером. Такую
        ассоциацию можно установить
        следующими способами:
        <dl>
          <dd>конструирование потока со ссылкой
            на буфер требуемого типа;
          <dd>выполнение операций обмена данными
            некоторого потока с данными во
            внешнем для этого потока буфере
            требуемого типа.</dd>
        </dl>
        <p>Реализация первого способа требует
        знакомства с конструкторами
        используемых классов (приходится
        обращаться к исходному тексту
        определения классов). Например, класс
        iostream имеет конструктор
        <pre><div class="code">  
   iostream(streambuf *);</div></pre>
        Если требуется связь такого потока с
       <p> файлом, то необходима ссылка на буфер
        потока - объект класса filebuf.
        Набор конструкторов класса filebuf:
        <pre><div class="code">
   // Буфер потока без связи с файлом
   filebuf();
   // Буфер потока со связью с открытым файлом
   filebuf(int fd);
   // Буфер потока со связью с открытым
   // файлом и назначенным буфером обмена
   filebuf(int fd, char *buf_addr, int buffer_len);</div></pre>
   <p>Здесь fd - дескриптор файла, а buf_addr и
        buf_len) - указатель и размер буфера обмена.
        <p>Идентификатором файла на внешнем
        носителе как набора данных является
        его имя, но после открытия файла
        достаточна более лаконичная схема
        идентификации дескриптором. Система
        управления вводом-выводом в MS-DOS строит
        взаимно-однозначное соответствие
        между именем файла и его дескриптором.
        Для любого файла, открытого обычным
        образом, например,
        <pre><div class="code">  
   FILE *pf=fopen(&quot;a:user.txt&quot;,&quot;wt&quot;); </div></pre>
        <p>его дескриптор определяется макросом
        fileno:
        <pre> <div class="code"> 
   int fd=fileno(pf); </div></pre>
        <p>Приведенный выше набор конструкторов
        позволяет создать буфер потока c
        различной исходной привязкой к файлу.
        Рассмотрим набор функций-элементов
        класса filebuf, которые позволяют
        управлять такой привязкой во времени.
        Открытие потока и связываемого с ним
        файла с именем fname, режимом открытия mode
        и признаком защиты файла prot:
        <pre><div class="code">  
   filebuf* open(const char *fname, int mode, int prot=filebuf::openprot); </div></pre>
        <p>(признак защиты имет смысл в
        многозадачных системах). Возможные
        режимы открытия потоков и связанных с
        ними файлов определены в классе ios:
        <pre><div class="code">  
   enum open_mode { // Виды открытия потоков
      in        = 0x01, // открытие для чтения
      out       = 0x02, // открытие для записи
      ate       = 0x04, // переход к концу файла при открытии
      app       = 0x08, // открытие для добавления
      trunc     = 0x10, // открытие для усечения файла
      nocreate  = 0x20, // ошибка, если при открытии файла нет
      noreplace = 0x40, // ошибка, если при открытии файл есть
      binary    = 0x80  // открытие двоичного файла
   }; </div></pre>
        <p>Очевидно, что можно объединять
        несколько признаков операцией
        дизьюнкции или суммирования. Например,
        выражение <pre> <div class="code"> 
   ios::nocreate | ios::out | ios::binary </div></pre>
        <p>запрашивает открытие нового
        двоичного файла для вывода. Операция
        открытия обязательна, если
        предполагается использование буфера
        потока, созданного конструктором
        класса filebuf без параметров. Другие
        функции для управления связью &quot;поток
        - файл&quot; посредством переназначения
        буфера потока:
         <pre><div class="code">
   // Очистка буфера и закрытие файла
   filebuf* close();
   // Проверка открытия файла
   int is_open();
   // Получение дескриптора связанного с буфером файла
   int fd();
   // Подключение буфера потока к открытому файлу
   filebuf* attach(int fd);</div></pre>
        <p>Операции обмена с потоком возможны
        лишь в состоянии, когда его буфер
        связан с открытым любым способом
        файлом. Для контроля исключительных
        ситуаций, управления
        позиционированием и выполнения
        операций ввода-вывода могут
        использоваться все ранее
        рассмотренные функции-элементы
        потоковых классов. Пример программы со
        связыванием потока с буфером: 
<pre><div class="code">
   #include &lt;fstream.h&gt;
        
   void main() {
      filebuf fb; // Создание файлового буфера
      if (fb.open(&quot;con&quot;,ios::in|ios::out)) { // Файл открыт-?
         iostream сio(&amp;fb); // Создание потока ввода-вывода
         int x;
         cio&lt;&lt;endl&lt;&lt;"\ax-? ";
         cio&gt; &gt;x; cio&lt;&lt;&quot;x=&quot;&lt;&lt;x;
      }
   }  </div> </pre>
        Результаты работы программы:
        <pre>   x-? 1992
   x=1992  </pre>
        <p>Пояснения к программе:
        <p>1) операторы &quot;&gt;&gt;&quot; и &quot;&lt;&lt;&quot;
        определены для двух разных классов
        (istream и ostream) поэтому запись следующего
        выражения ошибочна:
        <pre> <div class="code"> 
   cio&lt;&lt;endl&lt;&lt;&quot;\ax-? &quot;&gt;&gt;x&lt;&lt;&quot;x=&quot;&lt;&lt;x; </div></pre>
        <p>2) операции закрытия файла
        автоматически выполняются
        деструкторами.
        <p>Рассмотрим второй способ образования
        ассоциации потоков - операции ввода-вывода
        посредством связи буферов. Производные
        классы istream, ostream и iostream включают
        функцию-элемент для получения
        указателя буфера потока:
        <pre> <div class="code"> 
   filebuf* rdbuf(); </div></pre>
        <p>Кроме этого, имеется дополнительное
        переопределение операторов:
        <pre><div class="code">  
   istream&amp; operator&gt;&gt; (streambuf*);
   ostream&amp; operator&lt;&lt; (streambuf*); </div></pre>
        <p>Указатель типа streambuf* неявно
        преобразуется к указателю типа filebuf* по
        правилам связи указателей базовых и
        производных классов. Таким образом,
        можно динамически связать один поток с
        другим без дополнительной пересылки
        данных в памяти.
        <p>Пример программы: 
<pre><div class="code">
   #include &lt;fstream.h&gt;
        
   void main() { 
      filebuf *fbp=new filebuf; // Создание буфера
   // Создание файла с постскриптумом
      if (fbp-&gt;open(&quot;f:ps&quot;,ios::out)) { // Файл открыт-?
   // Создание потока со связью с открытым файлом 
         ostream os(fbp); // ... 
   // Вывод основного текста 
         os&lt;&lt;endl&lt;&lt;"PS: "; // Вывод заголовка постскриптума
         cout&lt;&lt;"PS-? "&lt;&lt;endl; // Приглашение для ввода текста
         cin&gt;&gt;fbp; // Копирование файла из cin в буфер потока os 
         cout&lt;&lt;endl&lt;&lt;"FINISH";
      }
   } </div></pre>
        Результаты работы программы:
        а) протокол диалога
        <pre>   PS-?
   Good Luck^Z
     
   FINISH</pre>
<a href="5_9.exe">Выполнить</a>
<p>
        б) содержимое файла f:ps
        <pre>   PS: Good Luck </pre>
        <p>При обсуждении связи понятий потока и
        его буфера здесь приводились примеры
        только для файловых потоков.
        Конструкторы буферов
        строкоориентированных потоков будут
        рассмотрены ниже.
        <p>
        <div class="header"><a name="REF_1_5_10"></a>5.10. Файловый ввод-вывод</div>
        <p>Для работы с файлами в соответствии с
        направлением передачи данных можно
        создавать объекты одного из трех
        определенных в файле fstream.h
        специализированных файловых классов:
        <dl>
          <dd>fstream - ввод-вывод;
          <dd>ifstream - ввод;
          <dd>ofstream - вывод.</dd>
        </dl>
        <p>Файл fstream.h включает директиву #include
        &lt;iostream.h&gt; для включения декларации
        иерархии базовых классов <a href="#REF_1_5_1">(см.
        5.1)</a>. Рассмотрим многообразие
        конструкторов объектов файловогo ввода-вывода,
        обозначая именем fstream_t любой элемент
        множества {fstream, ifstream, ofstream}:
        создание потока без соединения с
        файлом:
        <pre><div class="code">  
   fstream_t(); </div></pre>
        <p>создание потока, соединенного с
        открытым файлам указанием дескриптора
        файла (fd):
        <pre>  <div class="code">
   fstream_t(int fd); </div></pre>
        <p>создание потока, соединенного с
        открытым файлам указанием дескриптора
        файла (fd), указателя (buf_addr) и размера
        (buf_len) буфера обмена:
        <pre>  <div class="code">
   fstream_t(int fd, char *buf_addr, int buffer_len);</div></pre>
        <p>создание потока, соединяемого с
        открываемым файлом указанием имени
        файла (fname), режима открытия (mode) и
        признака защиты файла (prot):
        <pre>  <div class="code">
   fstream_t(const char *fname, int mode, int prot=filebuf::openprot); </div></pre>
        <p>Конструктор последнего вида в
        файловых классах описан с разными
        умалчиваемыми значениями параметра mode:
        <pre>  <div class="code">
   ofstream(const char *fname, int mode=ios::out, int prot=filebuf::openprot); 
   ifstream(const char *fname, int mode=ios::in, int prot=filebuf::openprot);
   fstream(const char *fname, int mode, int prot=filebuf::openprot); </div></pre>
        <p>Отсюда следует, что для
        конструирования потоков классов ifstream
        или ofstream можно указать лишь имя файла.
        Состав и смысл параметров
        конструкторов файловых классов
        соответствует ранее рассмотренным
        параметрам конструктора класса filebuf.
        Использование файловых классов
        избавляет от необходимости явного
        конструирования буфера потока, но
        схема связи потока и файла остается
        преждней.
        <p>Функции-элементы файловых классов:
        <p>открытие потока и связываемого с ним
        файла с именем fname, режимом открытия mode
        и признаком защиты файла prot:
        <pre>  <div class="code">
   void open(const char *fname, int mode, int prot=filebuf::openprot);</div></pre>
        <p>получение указателя буфера потока:
        <pre>  <div class="code">
   filebuf* rdbuf(); </div></pre>
        <p>Класс filebuf не является базовым для
        файловых классов, поэтому его функции-элементы,
        пригодные для управления связью &quot;поток-файл&quot;,
        доступны косвенно по указателю буфера
        потока.
       <pre><div class="code">
   #include &lt;fstream.h&gt;

   void main() { // Пример программы с управлением буфером 
      ifstream fp;
      fp.open(&quot;tst77.c&quot;); // Открытие файла tst77.c 
      if (fp.rdbuf()-&gt;is_open()) { // Файл открыт-? 
         char x; 
         while ((x=fp.get())!=EOF) // Копирование файла в поток cout 
            cout&lt;&lt;x; 
      }
   }</div></pre>
        <p>Здесь для определения состояния
        открытия файла использовано косвенное
        обращение к буферу файла, но чтение
        символов реализуется наследуемой из
        класса istream функцией get <a href="#REF_1_5_1">(см.
        5.1)</a>.
        <p>Пример программы без явного
        обращения к буферу потока:
        <pre><div class="code">
   #include &lt;fstream.h&gt;
   #include &lt;stdlib.h&gt;

   void main() { 
      ofstream R(&quot;f:random&quot;); 
      if (R) {
         R.setf(ios::right); 
         for (int i=0; (i&lt;100)&amp;&amp; R.good(); i++) {
            R.width(8); 
            R&lt;&lt;random(32767);
         } 
      } 
   }</div></pre>
        <p>Здесь в файл f:random будут выведены 100
        псевдослучайных чисел по формату
        &quot;%8d&quot;.
        <p>
        <div class="header"><a name="REF_1_5_11"></a>5.11. Строко-ориентированный
        ввод-вывод</div>
        <p>Поток можно ассоциировать со строкой
        символов некоторой длины. Это
        позволяет воспользоваться средствами
        оперирования потоками для подготовки
        или обработки данных в памяти. Подобные
        действия на процедурном уровне
        выполняют, например, библиотечные
        функции sprintf и sscanf. Для работы с
        строками в соответствии с направлением
        передачи данных можно создавать
        объекты одного из трех определенных в
        файле strstrea.h специализированных
        строковых классов:
        <p>strstream - ввод-вывод; istrstream - ввод; ostrstream -
        вывод.
        <p>Файл strstrea.h включает директиву #include
        &lt;iostream.h&gt; для включения декларации
        иерархии базовых классов <a href="#REF_5_1_1">(см.
        5.1)</a>. Рассмотрим многообразие
        конструкторов и интерфейсных функций-элементов
        классов строкового ввода-вывода:
        <pre><div class="code">  
   // Класс strstream:
   strstream(char *buf, int size, int mode); 
   char *str();

   // Класс istrstream:
   istrstream(char *buf); 
   istrstream(char *buf, int size);

   // Класс ostrstream:
   ostrstream(char *buf, int size, int mode=ios::out); 
   char *str(); 
   int pcount();</div></pre>
        <p align=""justify>Идентификация элементов определения
        перечисленных классов:
        <p>buf и str - указатели буферов обмена; size -
        размер буфера; mode - режим открытия; pcount -
        количество символов, выведенных
        последней операцией обмена.
        <p>Функции-элементы
        строкоориентированных классов
        обеспечивают контроль исключительных
        ситуаций, связанных с переполнением
        буфера. При необходимости функция str
        позволяет рассмотреть сформированный
        поток как строку или массив символов.
        <p>Приведем пример программы
        буферизованного вывода строк
        псевдослучайных чисел заданного
        размера: 
<pre> <div class="code">
   #include &lt;strstrea.h&gt;
   #include &lt;stdlib.h&gt;

   void main() {
      char buf[65]; // буфер вывода 
      ostrstream R(buf,sizeof(buf)); // поток подготовки буфера
      if (R) {
         long j; 
         R.setf(ios::right);
   // Цикл вывода строк
         for (int k=0; k&lt;5; k++) { 
            R.seekp(0);
   // Цикл заполнения строки
            for (int i=0; R.good(); i++) { 
               j=R.tellp(); 
               R.width(8); 
               R&lt;&lt;rand();
            }
            R.clear();
            R.seekp(j);
            R&lt;&lt;ends;
            cout&lt;&lt;endl&lt;&lt;R.str();
         }
      }
   }</div> </pre>
        Результаты работы программы:
        <pre>      41  18467   6334    26500   19169    15724   11478    29358
   24464   5705  28145    23281   22879    18492    1360     5412
   22463  25047  27119    31441    7190    13985   31214    27509
   26571  14779  19816    21681   19651    17995   23593     3734
    3979  21995  15561    16092   18489    11288   28466     8664
</pre>
<a href="5_11.exe">Выполнить</a>
        <p>Здесь каждая строка будет выведена
        только после ее формирования в памяти.
        В отличие от буферизации данных
        файловой системой ввода-вывода, при
        этом существует возможность
        вмешательства в содержимое буфера.
        <hr width="100%" SIZE="1">
        <a href="#REF_1_C">Начало</a>
<p>
<div class="header"><A NAME="REF_2_1"></A>
      6. ТЕХНОЛОГИЧЕСКИЕ АСПЕКТЫ ОБЪЕКТНО-ОРИЕНТИРОВАННОГО
                 ПРОГРАММИРОВАНИЯ НА ЯЗЫКЕ С++
</div>
<div class="header"><A NAME="REF_2_1_1"></A>
      6.1. Обзор операционных особенностей объектов класса
</div>
<p>
     Одной из  причин сложного восприятия языка С++ по сравнению с языком С  даже опытными  программистами  является  потребность учета  достаточно большого множества деталей при объявлении либо использовании классов. В языке C после объявления любого объекта поведение  программы  полностью  можно характеризовать только в терминах операций языка. В языке С++ многие действия планируются компилятором неявно, а для производных классов могут даже только обозначаться.
     Здесь приводятся  исходные  тексты  заготовок   определений классов,  которыми можно воспользоваться при подготовке рабочего варианта определения конкретного класса  с  учетом  рекомендаций надежного [4,5] программирования на языке С++.
<PRE><div class="code">
   //------------------------------------------------------------
   // Прототип определения базового класса
   //------------------------------------------------------------
   class base {
      any_class obj;
   public:
      virtual ~base(void);
      base(void);
      base(const base &r);
      const base &operator=(const base &r);
   private:
   };
   
   //------------------------------------------------------------
   base::~base(void) {}
   //------------------------------------------------------------
   inline base::base(void):obj(any_value) {}
   //------------------------------------------------------------
   inline base::base(const base &r):obj(r.obj) {}
   //------------------------------------------------------------
   inline const base &base::operator=(const base &r) {
      if (this!=&r) {
         obj=r.obj;
      }
      return *this;
   }
   //------------------------------------------------------------
</div></PRE>
     Обратите внимание, что определение даже почти всегда требующихся функций-элементов вынесено за пределы определения класса. Это облегчает обзор архитектуры класса и позволяет не забывать о недостатках встраивания функций.
<PRE><div class="code">
   //------------------------------------------------------------
   // Прототип определения производного класса
   //------------------------------------------------------------
   class derived: public base {
      any_class obj;
   public:
      virtual ~derived(void);
      derived(void);
      derived(const derived &r);
      const derived &operator=(const derived &r);
   private:
   };
   //------------------------------------------------------------
   derived::~derived(void) {}
   //------------------------------------------------------------
   inline derived::derived(void):
   base(any_value), obj(any_value) {}
   //------------------------------------------------------------
   inline derived::derived(const derived &r):
   base(r), obj(r.obj) {}
   //------------------------------------------------------------
   inline const derived &derived::operator=(const derived &r) {
      if (this!=&r) {
         *((base *)this)=r;
         obj=r.obj;
      }
      return *this;
   }
   //------------------------------------------------------------
</div></PRE>
     <p>Наличие конструктора  и деструктора объектов класса существенно расширяет 
процедурные возможности языка С.  Объявление любого объекта в языке C и интервал его существования 
определяются лишь классом памяти, а изменение состояния объекта требует явного  программирования 
преобразования содержимого памяти.  В языке С++ организуемый компилятором неявный вызов конструктора 
и деструктора позволяет запрограммировать некоторые действия, выполняемые на границах интервала  существования  
объекта.  Естественно скрываемые таким образом переходные процессы будут гарантированно реализованы для каждого 
объекта. Это позволяет не случайно не забыть для отдельного объекта,  например, освободить захваченную память, 
закрыть открытый файл,  восстановить вектор  прерываний или обработчик ошибок и т.д.
<p> Здесь объект  is_true в блоке функции main используется для управления доступом к клавиатуре при работе в среде MS-DOS.
     Можно ли  конструктор и деструктор вызвать повторно для существующего объекта?
     Если из содержательных соображений такие действия желательны,  то в конкретной системе  программирования  C++  потребуется лишь подбор приема вызова конструктора. Дело в том, что деструктор всегда вызывается после создания объекта,  поэтому  фрагмент текста программы, подобный
<PRE><div class="code">
   class X;
   //...
   X object;
   //...
   object.X::~X(); </div></PRE>
<p>не имеет логических противоречий и будет синтаксически правильным.
     Вызов конструктора тесно увязан с процессом выделения памяти для конструируемого объекта.  Лишь некоторые компиляторы  C++ разрешают явный вызов конструктора для существующего объекта:
<PRE><div class="code">
   //... class X;
   //... X object;
   //...
   object.X::X();  // Borland C++ 3.1 не разрешает... </div></PRE>
<p>Однако современный язык C++ позволяет использовать так называемую помещающую форму операции new, когда оператор вида
<PRE><div class="code">
   new(&object) X; </div></PRE>
<p>предписывает вызов конструктора класса X применительно к существующему объекту object (подробности смотри ниже).
     Строго говоря, есть и другой способ разрешения последнего вопроса - введение вспомогательных функций:
<PRE> <div class="code">
   class X {
      //...
   public:
      //...
      void create()  { /*...*/}
      void destroy() { /*...*/}
      //...
      X() { create(); }
      ~X() { destroy(); }
      //...
   };
   //...
   X object;
   //...
   object.create();  // object.X::X();
   object.destroy(); // object.X::~X(); </div></PRE>
<p>Особую роль,  как отмечалось в первой части пособия, играют конструктор копирования и функция-элемент operator=().  Их определения  практически  безусловно необходимы при наличии в классе указателей либо ссылок на некоторые объекты. Рекомендуемый стиль оформления  таких  функций отражен выше в прототипах определений классов.  В частности, не следует забывать о возможности самокопирования  объектов,  а также необходимости инициализации компонент базового класса при конструировании  объектов  производного класса.
<p>Далее в настоящем разделе  обсуждаются  другие  особенности использования  классов,  в том числе и потребность использования виртуальных деструкторов.
<p>
<div class="header"><A NAME="REF_2_1_2"></A>
       6.2. Особенности динамического управления памятью
</div>
<p> Возможность динамического управления памятью в С++ реализуется разрешенными для переопределения операциями new  и  delete,
классический синтаксис которых имеет вид:
<PRE><div class="code">
   // Размещение объектов типа type
   type *ptr=new type;
   type *ptr=new type(параметры_конструктора/инициализации);
   type *ptr=new type[размерность_массива];
   // Удаление объектов типа type
   delete ptr;   // Удаление одиночного объекта
   delete[] ptr; // Удаление массива
</div></PRE>
     <p>Ниже будет рассмотрен расширенный вариант синтаксиса оператора new в современных версиях языка C++.
<p>Рекомендуется пользоваться операциями new и  delete  вместо традиционных  для  языка C обращений к функциям вида malloc/free по причинам:
<UL>
<LI>результат операции  new - указатель на определенный тип, а возвращаемый функцией malloc пустой указатель (void *)  в  языке С++ потребуется явно преобразовывать;
<LI>операции new и delete можно  переопределить  как  глобально для всех типов, так и локально внутри классов;
<LI>имеется возможность централизованной обработки ошибок распределения памяти.
</UL>
     <p>Операции управления  памятью относятся к глобально контролируемым действиям программы. Переопределяющие такие операции функции-операторы в любом классе подразумеваются <STRONG>статическими</STRONG> (для других разрешенных для переопределения операций языка C++ функции-операторы статическими быть не могут).
     Определенной по умолчанию операции new соответствуeт функция
<PRE><div class="code">
   void *operator new(size_t);</div></PRE>
<p>(параметр типа size_t представляет объем запрашиваемой памяти для размещения объекта)
<p>Переопределяя глобально подобную функцию вне класса, следует учитывать, что она будет вызываться для размещения:
<UL>
<LI>одиночных объектов типов, не являющихся классами с локальными функциями operator new();
<LI>массивов объектов любых типов.
</UL>
<p>Помещенная в определении некоторого класса локальная  функция  operator new() используется только для размещения одиночных объектов этого класса. Обращение из любых функций к умалчиваемой или  переопределенной  версии оператора new возможно посредством операции привязки:
<PRE><div class="code">
   class type {
      //...
      void *operator new(size_t) { };
   };
   type *ptr1=::new type;        // Объект без инициализации
   type *ptr2=::new type(...);   // Инициализируемый объект
   type *ptr3=::new type[size];  // Здесь привязка не обязательна - массив...
</div></PRE>
<p> Функция operator new() всегда должна возвращать указатель на тип void и получать первый аргумент типа  size_t.  В  современных версиях языка C++ разрешается расширять список параметров.  Тогда функция
<PRE> <div class="code">
   void *operator new(size_t,&lt;дополнительные_формальные_параметры&gt;); </div></PRE>
<p>вызывается для интерпретации операций new вида
<PRE><div class="code">
    new(&lt;дополнительные_фактические_параметры&gt;) &lt;тип&gt;;
    new(&lt;дополнительные_фактические_параметры&gt;) &lt;тип&gt;(...);
    new(&lt;дополнительные_фактические_параметры&gt;) &lt;тип&gt;[...];
</div></PRE>
<p>(здесь угловые скобки синтаксическими элементами не являются).
<P align ="justify">Очевидно, что тем самым открывается возможность многократного переопределения функций вида operator new().
<p>Определенной по умолчанию операции delete может соответствовать одна из функций:
<PRE><div class="code">
   void operator delete(void *);
   void operator delete(void *, size_t);</div></PRE>
<p>(параметр типа void * представляет указатель на удаляемый объект,
а size_t - размер объекта в байтах).
     В системе программирования Borland C++ 3.1 локальное  переопределение операции delete в классе возможно любой из приведенных версий функций-операторов,  но для глобального переопределения  разрешено использование только функции с единственным параметром.
<p>Подобно операции new глобально определенная вне какого-либо класса функция operator delete() будет вызываться для  удаления:</P>
<UL>
<LI>одиночных объектов типов,  не являющихся классами с локальными функциями operator delete();
<LI>массивов объектов любых типов.
</UL>
<p>Отсюда следует,  что определенная в классе функция operator delete() может удалять только одиночные объекты  такого  класса. Если  для  такого  удаления желателен вызов глобального варианта функции-оператора, то необходимо использовать операцию привязки.</P>
<p>Следующая программа демонстрирует различные работоспособные варианты управления размещением объектов с переопределением операторов new и delete:
<pre><div class="code">
   #include &lt;stdio.h&gt;
   #include &lt;stdlib.h&gt;
   class X {
      int item;
   public:
      X():item(0) { printf("\n X() ?"); }
      X(X& x):item(x.item) { printf("\n X(X&) ??"); }
      void *operator new(size_t size) {
         void *area=malloc(size);
         printf("\nЛок. запрос %d байт. Адрес %p",size,area);
         return area;
      }
      void operator delete(void *p, size_t i) {
         printf("\nЛок. возврат по адресу %p, размер %d",p,i);
         free(p);
      }
      X(int i):item(i) { printf("\n X(%d) ???",item); }
      ~X() { printf("\n~X(%d) ??",item); }
   };

   void *operator new(size_t size) { // Вариант 1
      void *area=malloc(size);
      printf("\nГлоб. запрос %d байт. Адрес %p",size,area);
      return area;
   }

   void *operator new(size_t size,char *s,int n) { // Вариант 2
      void *area=malloc(size);
      printf("\nГлоб. запрос %d байт. Адрес %p. %s %d", size,area,s,n);
      return area;
   }

   void operator delete(void *p) { // Разрешен только 1 вариант...
      printf("\nГлоб. возврат по адресу %p",p);
      free(p);
   }

   void TEST(int i) {
      printf("\n\nТест %d:",i);
   }

   void main() {
      { TEST(1);           // Вызываются ли глобальные функции
         int *p=new int;    // operator new() и
         delete p;          // operator delete() ?
      }
      { TEST(2);           // Инициализация базовых типов
         int *p=new int(1); // доступна ?
         delete p;
      }
      { TEST(3);           // Какие версии функций определяет
         int *p=::new int;  // операция глобальной привязки ?
         ::delete p;
      }
      { TEST(4);           // Что происходит при работе с
         int *p=new int[3]; // массивами базовых типов ?
         delete[] p;        // Устаревшая версия: delete[3] p;
      }
      { TEST(5);           // Некорректное управление размещением
         int *p=new int[3]; // массивов базовых типов... работает ?
         delete p;          // Правильно: delete[] p;
      }
      { TEST(6);           // Как организуется размещение одиночных
         X *p=new X;        // объектов класса с переопределением
         delete p;          // операций new и delete ?
      }
      { TEST(7);           // Как организуется размещение массивов
         X *p=new X[3];     // объектов класса с переопределением
         delete[] p;        // операций new и delete ?
      }
      { TEST(8);                 // Допустимо ли комбинирование
         X *p=::new("Тест",8) X;  // глобальных и локальных версий
         delete p;                // операторов new и delete ?
      }
      { TEST(9);           // Другой вариант предыдущего теста
         X *p=new X(9);
         ::delete p;
      }
      printf("\n\nОК ? ");
   }</div></pre>
     Результаты работы программы:
<PRE>   Тест 1:
   Глоб. запрос 4 байт. Адрес 00430070
   Глоб. возврат по адресу 00430070

   Тест 2:
   Глоб. запрос 4 байт. Адрес 00430070
   Глоб. возврат по адресу 00430070

   Тест 3:
   Глоб. запрос 4 байт. Адрес 00430070
   Глоб. возврат по адресу 00430070

   Тест 4:
   Глоб. запрос 12 байт. Адрес 00430070
   Глоб. возврат по адресу 00430070

   Тест 5:
   Глоб. запрос 12 байт. Адрес 00430070
   Глоб. возврат по адресу 00430070

   Тест 6:
   Лок. запрос 4 байт. Адрес 00430070
   X() ?
   ~X(0) ??
   Лок. возврат по адресу 00430070, размер 4

   Тест 7:
   Глоб. запрос 16 байт. Адрес 00430070
   X() ?
   X() ?
   X() ?
   ~X(0) ??
   ~X(0) ??
   ~X(0) ??
   Глоб. возврат по адресу 00430070

   Тест 8:
   Глоб. запрос 4 байт. Адрес 00430070. Тест 8
   X() ?
   ~X(0) ??
   Лок. возврат по адресу 00430070, размер 4
 
   Тест 9:
   Лок. запрос 4 байт. Адрес 00430070
   X(9) ???
   ~X(9) ??
   Глоб. возврат по адресу 00430070

   ОК ?</PRE>
<a href="6_2.exe">Выполнить</a>
    <p> Можно экспериментально проверить,  что если для базовых типов фрагмент программы вида
<PRE><div class="code">
   { ТEST(5);           // Некорректное управление размещением
      int *p=new int[3]; // массивов базовых типов... работает ?
      delete p; }        // Правильно: delete[] p;
</div></PRE>
<p>не привел к аварийному завершению программы, то синтаксически
правильный фрагмент
<PRE><div class="code">
   { X *p=new X[3];   // Глобальная операция new
      delete p; }       // Локальная операция delete
</div></PRE>
<p>не является логически корректным и завершается в общем случае
аварийно.
     <p>Реализуемая функцией вида
<PRE><div class="code">
     void *operator new(size_t, void *pointer)
</div></PRE>
<p> выше упомянутая помещающая форма операции new позволяет предписать место размещения в памяти создаваемого объекта:
<pre><div class="code">
   #include &lt;new.h&gt;
   #include &lt;stdio.h&gt;
   inline void * operator new(size_t, void *pointer) {
      return pointer;
   }

   class AnyClass {
   public:
      AnyClass() { printf("\nИнициализация -&gt; %p",this); }
      ~AnyClass() { printf("\nРазрушение -&gt; %p",this); }
   };

   AnyClass global_object;

   void main() {
      printf("\nНачало программы");
      new (&global_object) AnyClass;
      printf("\nКонец программы");
   }</div></pre>
     Результаты работы программы:
<PRE>
   Инициализация -&gt; 0386
   Начало программы
   Инициализация -&gt; 0386 
   Конец программы
   Разрушение -&gt; 0386</PRE>
<p>Здесь операция new используется с обращением по адресу к существующему объекту global_object только для повторного вызова конструктора.  Конструктор в подобных ситуациях может учесть дополнительные  обстоятельства,  касающиеся  уточнения глобального окружения объекта.
     Некоторые компиляторы  (например,  Borland  C++ 4.0 и более поздние версии) разрешают переопределение операций захвата и освобождения памяти массивов [1]:
<PRE><div class="code">
   void *operator new[](size_t); // Размещение массивов
   void operator delete[](void *); // Удаление массивов </div></PRE>
<p> В процессе выполнения  стандартной  операции  new  возможны
аварийные ситуации из-за недостатка памяти.  Признаком такой ситуации является возврат нулевого указателя.  Так как  нормальное продолжение программы при нехватке памяти чаще всего невозможно, то вместо тестирования результата каждой операции new можно воспользоваться централизованной обработкой ситуаций недостатка памяти.
     В современных  системах программирования на языке C++ определенная в файле new.h библиотечная функция
<PRE><div class="code">
   void *set_new_handler(void (* my_handler)())();</div></PRE>
<p>позволяет указать функцию my_handler, которая будет вызвана, если любой последующий оператор new не сможет получить требуемую память.
<P>Функция my_handler может:
<UL>
<LI>завершить программу  вызовом  функций,  подобных  exit() или abort() с выдачей диагностического сообщения;
<LI>выполнить перекомпоновку или освобождение памяти и,  завершившись явным либо неявным оператором return, вынудить повторное исполнение оператора new (очевидно,  что если памяти снова  окажется недостаточно, то налицо условие для бесконечного цикла).
</UL>
     Стандартная реакция на ошибки в операторах new восстанавливается оператором
<PRE><div class="code">
   set_new_handler(0); </div></PRE>
<p>(нулевой указатель устанавливается по умолчанию).
     Функция set_new_handler возвращает  в  качестве  результата указатель старого обработчика ошибок, что может быть использовано для восстановления реакции:
<pre><div class="code">
   #include &lt;iostream.h&gt;
   #include &lt;new.h&gt;
   #include &lt;stdlib.h&gt;
   void new_error_handler() {
      cerr&lt;&lt;endl&lt;&lt;"Дефицит памяти !"&lt;&lt;endl;
      exit(1);
   }

   void main() {
      //...
      void (* old_handler)(void)=set_new_handler(new_error_handler);
         
      char *ptr_1=new char[1024];
      cout&lt;&lt;"\nПервое размещение: "&lt;&lthex&lt;&ltlong(ptr_1);
         
      char *ptr_2=new char[64000U];
      cout&lt;&lt;"\nПоследнее размещение: "&lt;&lthex&lt;&ltlong(ptr_2);
          
      set_new_handler(old_handler); // Восстановление реакции
      //...
      set_new_handler(0); // Стандартная реакция
      //...
      delete[] ptr_1;
      delete[] ptr_2;
      //...
   }</div></pre>
     Результаты работы программы (потоки cout и cerr):
<PRE>
   Первое размещение: 28970f28
   Дефицит памяти ! </PRE>
<p> В последних версиях реализации оператора new  при  нехватке памяти вместо возврата нулевого указателя может порождаться исключение xalloc [2, 7-9].
<P>
<div class="header"><A NAME="REF_2_1_3"></A>
        6.3. Использование статических элементов класса
</div>
<p> Статические элементы  класса,  по  существу,  можно считать глобальными объектами программы,  доступ к  которым  разрешен  в пределах  видимости класса.  Независимо от количества фактически существующих объектов класса в программе такие  элементы  всегда присутствуют в единственном экземпляре.
     Статические элементы данных можно применять для нумерации и построения механизмов синхронизации процессов использования объектов.
<p>Пример организации управления устройством коллективного использования:
<PRE><div class="code">
   class some_process {
      //...
      static int number_process; // Длина очереди процессов
      //...
   public:
      some_process();
      virtual ~some_process();
      //...
   };

   // Статические элементы данных класса должны быть определены
   // как глобальные и могут инициализироваться любым выражением,
   // включая вызов функций...

   int some_process::number_process=0;

   some_process::some_process() {
      if (++number_process==1)   // Заявка при пустой очереди
         set_device_online_mode(); // требует включения устройства...
      //...
   }

   some_process::~some_process() {
      if (--number_process==0)    // При исчерпании очереди заявок
         set_device_offline_mode(); // устройство выключается...
      //...
   }</div></PRE>
<p> Одно из типичных применений статических функций-элементов - обработка прерываний. Обычные функции-элементы не могут быть обработчиками прерываний, так как для их вызова требуется формирование  в стеке параметров первого неявного параметра - указателя объекта this.
<P>
     Пример обработки прерываний в классе:
<PRE><div class="code">
   #include &lt;iostream.h&gt;
   #include &lt;dos.h&gt;
   #include &lt;stdlib.h&gt;
   #include &lt;time.h&gt;
   class wakeup {
      enum { timer_int_no = 0x1C };
      static long count;
      static void interrupt (*old_handler)(...);
      static void interrupt new_handler(...) {
         if (count) count--;
         old_handler();
      }
   public:
      wakeup(int delay=10) {
         count=long((delay&lt;0)? 0:delay)*CLK_TCK;
         old_handler=getvect(timer_int_no);
         setvect(timer_int_no, new_handler);
      }
      operator int() { return count/CLK_TCK; }
      ~wakeup() { setvect(timer_int_no, old_handler); }
   };

   void interrupt (*wakeup::old_handler)(...)=0;
   long wakeup::count=0;

   void main() {
      cout&lt;&lt;endl&lt;&lt;"Отсчет 5 сек...";
      wakeup timer_set(5);
      while (timer_set) {
         cout&lt;&lt;endl&lt;&lt;"Еще не вечер...";
         sleep(1);
      }
   }</div></PRE>
<p>Статические функции-элементы класса удобно  использовать  в качестве аргументов библиотечных функций на языке С. Например, в представленной ниже программе библиотечная функция qsort вызывается с адресом статической функции-элемента rndset::compare():
<pre><div class="code">
   #include &lt;iostream.h&gt;
   #include &lt;iomanip.h&gt;
   #include &lt;stdlib.h&gt;
   class rndset {
      int *x;
      int n;
      static int compare(const void *a, const void *b) {
         return(*((int *)a)-*((int *)b));
      }
   public:
      rndset(int m);
      ~rndset() { delete[] x; }
      void sort() { qsort(x,n,sizeof(*x),compare); }
      friend ostream &operator&lt;&lt(ostream &out, rndset &obj);
   };

   rndset::rndset(int m=10):n(m) {
      x=new int[n];
      if (x) for (int i=0; i&lt;n; x[i++]=random(n));
   }

   ostream &operator&lt;&lt(ostream &out, rndset &obj) {
      for (int i=0; i&lt;obj.n; i++) {
         if (!(i%10)) out&lt;&lt;endl;
         out&lt;&ltsetw(3)&lt;&ltobj.x[i]&lt;&lt' ';
      }
      return out&lt;&lt;endl;
   }

   void main() {
      rndset a(30);
      cout&lt;&lt;endl&lt;&lt;"   Исходный массив:"&lt&lt;endl&lt;&lt;a;
      a.sort();
      cout&lt;&lt;endl&lt;&lt;"   Упорядоченный массив:"&lt;&lt;endl&lt;&lt;a;
   }</div></pre>
     Результаты работы программы:
<PRE>
   Исходный массив:
   0   0  10   0  10   6  16   5  21  28
   8  13   3  20  16   1   4  24  20  22
  24  28   6  12  28  25  27  24  13  18
   
   Упорядоченный массив:
   0   0   0   1   3   4   5   6   6   8
  10  10  12  13  13  16  16  18  20  20
  21  22  24  24  24  25  27  28  28  28
</PRE>
<a href="6_3.exe">Выполнить</a>
<P>
<div class="header"><A NAME="REF_2_1_4"></A>
           6.4. Статическое и динамическое связывание
</div>
<p>Термин "связывание"  в языке C++ используют в контексте момента времени привязки функций к обрабатываемым данным.  Обычные функции  (без атрибута virtual) оказываются связанными <STRONG>статически</STRONG>,  так как эта связь устанавливается на этапе компиляции. Виртуальные функции, вызываемые через указатель или ссылку на базовый класс, могут относиться к разным производным классам. Фактическая принадлежность к конкретному производному классу устанавливается во время исполнения программы, поэтому в таких случаях говорят о  <STRONG>динамическом</STRONG>,  или позднем, связывании.
     Можно выделить два назначения виртуальных функций:
<UL>
<LI>определение общих  для  всей  иерархии  производных классов возможностей с целью единообразия использования;
<LI>определение специфичных  возможностей для отдельного уровня наследования,  которые не могут быть представлены элементами базового класса.
</UL>
     <p>Рассмотрим действия компилятора при трансляции  производных классов.  Механизм  виртуальных  функций реализуется посредством таблиц указателей
<PRE><div class="code"> 
   typedef void (*_vtab[])(...);</div></PRE>
<P>по следующей схеме:
<P><PRE><div class="code">
   // Пример класса с типичным набором функций-элементов
   class any_class {
      int item;
   public:
      any_class();
      virtual void print();
      virtual void action();
      virtual int compar(const any_class &)=0;
      int nonvirtual();
   };

   any_class::any_class() {
   // Конструктор по умолчанию в лучшем случае
   // очищает элементы данных
      item=0;
   };
   
   void any_class::print() {
   // Печать в какой-то форме
   };
   
   void any_class::action() {
   // Какие-то неспецифические действия с объектом класса
   };

   int any_class::nonvirtual() {
   // Какие-то специфические действия с объектом класса
   }; </div></PRE>
<p> Определение класса  с учетом некоторого правила декорирования имен его элементов можно представить так:
<PRE><div class="code">
   // 1. Имена элементов класса расширяются (декорируются)
   //    информацией о принадлежности к классу...
   // 2. Каждая нестатическая функция-элемент имеет неявный
   //    параметр - указатель this...

   void _any_class__print(any_class *this) { /*... */ };
   void _any_class__action(any_class *this) { /*... */ };
   int _any_class__nonvirtual(any_class *this) { /*... */ };
   
   _vtab _any_class__vtab={ // Таблица виртуальных функций
      _any_class__print,
      _any_class__action,
      NULL // Место для указателя чисто виртуальной функции
  };

   typedef struct {
      _vtab _vtable; // Добавляемый указатель
      int _any_class_item;
  } any_class;
       
  _any_class__any_class(any_class *this) { // Конструктор
     this-&gt;_vtable=_any_class__vtab;
     this-&gt;_any_class_item=0;
  }</div></PRE>
<p>(здесь предполагается, что имя функции-элемента class::function представлено после расширения как _class__function).
       Обращения к невиртуальным функциям, например, в виде
<PRE><div class="code">
   any_class x, *p;
   x.nonvirtual();
   p-&gt;nonvirtual();</div></PRE>
<p>компилятор представляет в виде
<PRE><div class="code">
   _any_class__nonvirtual(&x);
   _any_class__nonvirtual(p);</div></PRE>
<p>Для виртуальных  функций операция вызова организуется через косвенное обращение  к  элементам  таблицы  виртуальных  функций класса: выражения вида
<PRE><div class="code">
   x.print();
   p-&gt;print();</div></PRE>
<p>на самом деле представляются операциями
<PRE><div class="code">
   (x.vtable[_print_index])(&x);
   (p-&gt;vtable[_print_index])(p); </div></PRE>
<p>(здесь _print_index - индекс функции print в таблице виртуальных функций, который во всех таблицах иерархии имеет одинаковое значение).
    Вид последних операций объясняет причины потерь времени  на косвенный вызов виртуальных функций.
     Пусть определен производный класс
<PRE><div class="code">
   class derived: public any_class {
      int derived_item;
   public:
      virtual void print();
      virtual int compar(const any_class &);
   }

   void derived::print() {
   // Печать в какой-то форме
   };

   int derived::compar(const any_class &r) {
      return this-&gt;item&lt;r.item;
  };</div></PRE>
<p> Определение такого  класса с учетом тех же правил декорирования имен его элементов можно представить так:
<PRE><div class="code">
   void _derived__print(derived *this) { /*... */ };
   void _derived__action(derived *this) { /*... */ };
   int _derived__nonvirtual(derived *this) { /*... */ };
       
   _vtab _derived__vtab={ // Таблица виртуальных функций
      _derived__print,
      _any_class__action,
      _derived_corpar
  };

   typedef struct {
      _vtab _vtable; // Добавляемый указатель
   // Элементы данных базового класса
      int _any_class_item;
   // Элементы данных производного класса
      int derived_item;
  } derived;

   _derived__derived(derived *this) {
      _any_class__any_class(this); // Конструктор базового
                                   // класса вызван вначале...
      this-&gt;_vtable=_derived__vtab;
      this-&gt;derived_item=0;
   }</div></PRE>
<p> Интерпретация операций  вызова виртуальных функций остается
прежней: для объекта
<PRE><div class="code">
   derived d;</div></PRE>
операция
<PRE><div class="code">
   d-&gt;print();</div></PRE>
компилятором будет представлена в виде
<PRE><div class="code">
   (d.vtable[_print_index])(&d);</div></PRE>
<p>Но после конструирования объекта d в таблице vtable элемент с нулевым индексом указывает на версию функции print производного класса. Говорят, что таблицы виртуальных функций представляют так называемое  <STRONG>динамическое  связывание</STRONG> функций-элементов и данных классов.
     Такая схема  характеризуется тем,  что конструктор базового класса не может вызвать виртуальную функцию,  переопределенную в производном классе. Этим, в частности, объясняется запрет объявления конструктора виртуальным.
<p>Деструктор класса с виртуальными функциями строится так:
<PRE><div class="code">
   _derived__destructor(derived *this) { // Деструктор
   // 1. Фиксация указателя таблицы виртуальных функций
      this-&gt;_vtable=_derived__vtab;
   // 2. Операторы тела деструктора
      // ...
   // 3. Вызов деструкторов базовых классов
      // ...
  }</div></PRE>
<p>Отсюда следует,  что деструктор производного класса переопределенные виртуальные функции использует правильно.
<P>
<div class="header"><A NAME="REF_2_1_5"></A>
                  6.5. Виртуальные деструкторы
</div>
<p> По определению деструктор класса  может  быть  виртуальным. Так  как любой класс может стать базовым,  то деструктор для надежности программирования рекомендуется всегда объявлять  виртуальным [4].
     Рассмотрим простейшую иерархию классов:
<PRE><div class="code">
   class base {
      char *bp;
   public:
      base() { bp=new char[100]; }
      ~base() { delete bp; }
   };

   class derived: public base {
      char *dp;
   public:
      derived() { dp=new char[100]; }
      ~derived() { delete dp; }
   };</div></PRE>
<p> Неприятности использования таких классов проявляются в случае наличия в каких-либо местах программы пары операторов:
<PRE><div class="code">
   base *bx=new derived;
   //...
   delete bx;

   //Оператор delete bx компилятор интерпретирует так:

   _base__destructor(bx);
   free(bx);</div></PRE>
<p>В результате деструктор  фактически  существующего  объекта производного класса derived не будет вызван,  хотя потребность в этом для рассматриваемой версии класса derived несомненна.
     Если же объявить деструктор базового класса виртуальным, то при интерпретации оператора delete bx компилятор использует косвенный вызов деструктора из таблицы виртуальных функций:
<PRE><div class="code">
   (bx-&gt;_vtable[destructor_index])(bx);</div></PRE>
<p>(здесь destructor_index - индекс деструктора в таблице виртуальных функций).
     Так как bx указывает на объект производного класса,  то будет вызван именно деструктор производного  класса,  который  при удалении объекта выполнит вызов и деструктора базового класса.
<pre><div class="code">
   #include &lt;stdio.h&gt;

   // Использование невиртуального деструктора

   class base_1 { // Базовый класс без особенностей
   public:
      base_1() { printf("\nbase_1"); }
      ~base_1() { printf("\n~base_1"); }
   };

   class derived_1: public base_1 {
      char *dp;
   public:
      derived_1() {
         dp=new char[100];
         printf("\nderived_1");
      }
      ~derived_1() {
         delete dp;
         printf("\n~derived_1");
      }
   };

   // Использование виртуального деструктора

   class base_2 { // Базовый класс без особенностей
   public:
      base_2() { printf("\nbase_2"); }
      virtual ~base_2() { printf("\n~base_2"); }
   };

   class derived_2: public base_2 {
      char *dp;
   public:
      derived_2() {
         dp=new char[100];
         printf("\nderived_2");
      }
      ~derived_2() {
         delete dp;
         printf("\n~derived_2");
      }
   };

   void main() {
      printf("\n\n* Использование невиртуального деструктора\n");
      base_1 *pb1=new derived_1;
      delete pb1;
         
      printf("\n\n* Использование виртуального деструктора\n");
      base_2 *pb2=new derived_2;
      delete pb2;
   }</div></pre>
     Результаты работы программы:
<PRE>
   * Использование невиртуального деструктора
   base_1
   derived_1
   ~base_1

   * Использование виртуального деструктора
   base_2
   derived_2
   ~derived_2
   ~base_2</PRE>
<a href="6_5.exe">Выполнить</a>
<p>Действительная потребность вызова деструктора  производного класса  в  общем случае определяется только особенностями такого класса,  но предвосхитить игнорирование вызова деструктора можно только объявлением деструктора базового класса виртуальным.
<P>
<div class="header"><A NAME="REF_2_1_6"></A>
     6.6. Динамические особенности операторов присваивания
</div>
<p>Рассмотрим функционирование механизма виртуальных  функций при переопределении операторов присваивания функциями operator=().
     В следующей программе, на первый взгляд, учтены все рекомендации по надежному программированию:
<pre><div class="code">
   #include &lt;stdio.h&gt;
   inline void * operator new(size_t, void *pointer) {
      return pointer;
   }

   class base { // Класс с функцией operator=()
      int item;
   public:
      virtual ~base() {}
      virtual print() { printf("\nКласс base ?"); }
      base():item(0) {}
      base(const base &r):item(r.item) {
         printf("\nКопирование base ");
      };
      const base &operator=(const base &r);
   };

   const base &base::operator=(const base &r) {
      if (this!=&r) {
         this-&gt;base::~base(); // Разрушение текущего объекта
         new(this) base(r);   // и построение на его месте нового
      }
      printf("\nПрисваивание base");
      return *this;
   }

   class derived:public base { // Класс без функции operator=()
      int d_item;
   public:
      virtual print() { printf("\nКласс derived ?"); }
      derived():d_item(0) {}
      ~derived() {}
   };

   derived x, y; // Глобальные объекты производного класса

   void f() { // Тест указателя таблицы виртуальных функций
      base &rx=x;
      rx.print();
      base &ry=y;
      ry.print();
   }

   void main() {
      printf("\n* Начало...");
      x.print();
      y.print();
      printf("\n* Тест до присваивания");
      f();
      printf("\n* Присваивание");
      y=x;
      printf("\n* Тест после присваивания");
      f();
      printf("\nОК...");
   }</div></pre>
     Результаты работы программы:
<PRE>
   * Начало...
   Класс derived ?
   Класс derived ?
   * Тест до присваивания
   Класс derived ?
   Класс derived ?
   * Присваивание 
   Копирование base
   Присваивание base
   * Тест после присваивания
   Класс derived ?
   Класс base ?
   ОК...</PRE>
<a href="6_6.exe">Выполнить</a>
<p>Однако результаты работы программы не располагают  к  оптимизму:  операция  присваивания  разрушила  указатель виртуальной таблицы объекта y.
     Причина ошибки здесь в том, что для класса derived компилятор предполагает использование умалчиваемой операции  присваивания методом побитового копирования, но при этом дополняет ее явно определенной  в  базовом  классе  base  функцией const base &operator=(const base &) (смотри отображение хода присваивания).
Последняя же функция, использующая включающую форму операции new,  неявно вызывает конструктор базового класса, который и выполняет замену указателя виртуальной таблицы.
     Таким образом,  при  переопределении  операции присваивания для классов с  виртуальными  функциями  вызов  конструкторов  из функции operator=() должен быть исключен.  Если разработчик производного класса не имеет представления  о  базовом  классе,  то можно  рекомендовать  другой  радикальный прием защиты от ошибок рассмотренного типа - переопределение  операции  присваивания  в каждом производном классе (легко убедиться, что дополнение класса derived функцией derived &derived::operator=(derived &)  приводит к правильной работе программы).
<P>
<HR WIDTH="100%" SIZE="1">
<a href="#REF_1_C">Начало</a>
<p>
<div class="header"><A NAME="REF_2_2"></A>
7. ШАБЛОНЫ В ЯЗЫКЕ С++
</div>
<div class="header"><A NAME="REF_2_2_1"></A>
                   7.1. Назначение и виды шаблонов
</div>
<p>Естественное желание сокращения объема программы часто противоречит строгости контроля типов  компилятором  и  требованиям надежного программирования.  Например, задача определения максимального значения из пары значений разных типов может породить в программе наличие функций
<PRE><div class="code">
   int    max(int x, int y)       { return (x&gt;y)? x:y; }
   long   max(long x, long y)     { return (x&gt;y)? x:y; }
   char   max(char x, char y)     { return (x&gt;y)? x:y; }
   double max(double x, double y) { return (x&gt;y)? x:y; }
</div></PRE>
<p>Тело функций во  всех  вариантах  программы  одинаково,  но из-за  различия типов параметров и возвращаемых значений результат компиляции будет существенно различным.  Идея  использования препроцессора здесь может не отвергаться лишь по причине малости текста функций,  в других же ситуациях она несостоятельна по надежности.
     Приведенный пример иллюстрирует целесообразность параметризации определений функций в отношении  <STRONG>типов параметров</STRONG> функций. Это оформляют в интуитивно понятной форме
<PRE><div class="code">
   // Параметризация функций в С++
   template &lt;class Type&gt; // Шаблон функции максимума
   Type max(Type x, Type y) { return (x&gt;y)? x:y; }
</div></PRE>
<p>(здесь Type - параметр, представляющий тип).
<p>В языке С++ в современных системах программирования параметризация типов поддерживается понятиями  <STRONG>шаблонов</STRONG>(template) <STRONG>функций</STRONG>  и  <STRONG>классов</STRONG>. Шаблоны класса, в отличие от шаблонов функций, позволяют параметризовать не только признак типа элементов класса, но и  <STRONG>константы</STRONG>  разных типов. Например,определения классов
<PRE><div class="code">
   class char_array { // Массив символов фиксированного размера
   protected:
      char *area;
   public:
      char_array() {
         area=new char[81]; // Константа характеризует тип!
      }
      ~char_array() {
         delete[] area;
      }
   };

   class int_array { // Массив слов фиксированного размера
   protected:
      char *area;
   public:
      int_array() {
         area=new int[150]; // Константа характеризует тип!
      }
      ~int_array() {
         delete[] area;
      }
   };</div>
</PRE>
<p>из практических соображений можно было бы параметризовать относительно типа элементов и размера массива. Предварительно отметим, что это можно было бы выразить в форме
<PRE><div class="code">
   // Параметризация класса в С++
   template &lt;class Type, int Size&gt; // Шаблон класса
   class any_type_array { // Массив фиксированного размера
   protected:
      Type *area;
   public:
      any_type_array() {
         area=new Type[Size]; // Константа характеризует тип!
      }

      ~any_type_array() {
         delete[] area;
      }
   };</div>
</PRE>
<p>(здесь Type - параметр, представляющий тип, а Size - константу
типа int).
<p> Механизм шаблонов в языке С++ - средство  построения  обобщенных определений функций и классов,  независимых от используемых типов. Использование шаблонов избавляет от необходимости переписывания исходного текста функций и/или классов для различных типов объектов.  Компилятор на основе определения шаблона по заданному  в качестве параметра типу автоматически порождает соответствующие экземпляры, или так называемые  <STRONG>представители</STRONG> функции или класса.
<P>
<div class="header"><A NAME="REF_2_2_2"></A>
        7.2. Определение и использование шаблонов функций
</div>
<p>
     Синтаксис определения шаблона функции:
<PRE><div class="code">
   template &lt;список_параметров_шаблона&gt; декларация_функции
</div></PRE>
<p>(здесь угловые скобки обязательны).
     Элемент "список_параметров_шаблона" определяет набор типов,
параметризующих текст декларации функции. Каждый тип представляется ключевым словом class и локальным в рамках элемента "декларация_функции" идентификатором  типа.  Элемент  "список_параметров_шаблона"  не  может быть пустым,  а его элементы разделяются
запятыми.
     Элемент "декларация_функции"  подобен  обычному определению или описанию функции, но в списке параметров функции должны быть хотя  бы  раз упомянуты типы,  перечисленные в списке параметров шаблона.
<p>Примеры отношений между списками параметров шаблона и функции:
<DL>
<DD>а) шаблон с единственным параметром
<PRE><div class="code">
   template &lt;class T&gt;
   void f1 (T par) {
      //
      // Тело функции f1
      //
   }</div></PRE>
<p>(тип T можно использовать для спецификации возвращаемого значения и
 параметров функции, а также любых объектов в теле функции; обязательное требование упоминания T в списке параметров функции выполнено);
<DD>б) шаблон функции с частично параметризованными параметрами
<PRE><div class="code">
   template &lt;class T&gt;
   void f2 (T par, int x, float y) {
      //
      // Тело функции f2
      //
   }</div></PRE>
<p>(типы параметров шаблона должны обязательно использоваться в списке параметров функции, но функция может иметь параметры любых типов);
<DD>в) шаблон с несколькими параметрами
<PRE><div class="code">
   template &lt;class T1, class T2&gt;
   void f3 (T1 par_1, T2 par_2) {
      //
      // Тело функции f3
      //
   }</div></PRE>
<p>(здесь типы T1 и T2 не обязательно должны быть различными, а порядок их перечисления в списке параметров шаблона значения не
имеет, поэтому определение шаблона в виде
<PRE><div class="code">
   template &lt;class T2, class T1&gt;
   void f3 (T1 par_1, T2 par_2) {
      //
      // Тело функции f3
      //
   }</div></PRE>
эквивалентно исходному варианту).
</DL>
     <p>Использование шаблона функции не требует  каких-либо  действий от программиста - компилятор автоматически формирует требуемый операцией ее вызова экземпляр кода по набору типов аргументов.  Параметризуемая  функция может иметь атрибут inline,  т.е. быть встраиваемой.
     Пример определения и использования шаблона функций:
<pre><div class="code">
   #include &lt;iostream.h&gt;
   #include &lt;string.h&gt;
   template &lt;class T&gt; // Шаблон функции максимума
   T max(T x, T y) { return (x&gt;y)? x:y; }

   class string { // Класс строк
      char *buffer;
   public:
      string(char *x) {
         buffer=new char[strlen(x)+1];
         if (buffer) strcpy(buffer,x);
      }
      ~string() {
         delete buffer;
      }
          
      int operator&gt;(string &item) {
         return strcmp(this-&gt;buffer,item.buffer)&gt;0;
      }

      friend ostream &operator&lt;&lt(ostream& out, string &obj) {
         out&lt;&ltobj.buffer;
         return out;
      }
   };

   void main(void) {
      int ix=2, iy=3;
      cout&lt;&lt;endl&lt;&ltix&lt;&lt' '&lt;&ltiy&lt;&lt' '&lt;&ltmax(ix,iy);
       
      float fx=1.12, fy=1.13;
      cout&lt;&lt;endl&lt;&ltfx&lt;&lt' '&lt;&ltfy&lt;&lt' '&lt;&ltmax(fx,fy);
      
      long lx=123, ly=77;
      cout&lt;&lt;endl&lt;&ltlx&lt;&lt' '&lt;&ltly&lt;&lt' '&lt;&ltmax(lx,ly);
   }</div></pre>
     Результаты работы программы:
<PRE>
   2 3 3
   1.12 1.13 1.13
   123 77 123
</PRE>
<a href="7_2.exe">Выполнить</a>
<p>Шаблон функции определения максимума здесь избавляет от необходимости копирования ее определения для  <STRONG>любого  типа параметров</STRONG>. Нетрудно заметить, что тело параметризуемой функции не изменится при наличии переопределения операций для классов пользователя. Отсюда следует, что определения шаблонов целесообразно помещать в заголовочные файлы.</P>
<p>Технология подготовки шаблонов функций,  на первый взгляд, весьма проста.  Предположим,  имеется текст программы сортировки массива целых чисел:
<PRE><div class="code">
   // Пример процедуры сортировки методом Шелла

   void shells(int x[], int n) {
      if (n&lt;=1) return;
      for (int k=1; k&lt;=n; k&lt;&lt=1);
         for (int m=(k&gt;&gt1)-1; m; m&gt;&gt=1)
            for (int k=n-m, j=0; j&lt;k; j++)
               for (int i=j; (i&gt;=0)&amp;&amp;(x[i]&gt;x[i+m]); i-=m) {
                  int tmp=x[i+m];
                  x[i+m]=x[i], x[i]=tmp;
               }
   }</div></PRE>
<p>Параметризованный относительно  типа элементов массива шаблон такой функции, помещаемый в файл shells.h, может иметь вид:
<PRE><div class="code">
   //  Шаблон процедуры сортировки методом Шелла

   #ifndef SHELLS_H
   #define SHELLS_H

   template &lt;class T&gt;
   void shells(T x[], int n) {
      if (n&lt;=1) return;
      for (int k=1; k&lt;n; k&lt;&lt=1);
         for (int m=k-1; m; m&gt;&gt=1)
            for (int k=n-m, j=0; j&lt;k; j++)
               for (int i=j; (i&gt;=0)&amp;&amp;(x[i]&gt;x[i+m]); i-=m) {
                  T tmp=x[i+m]; // Требуется конструктор копирования!
                  x[i+m]=x[i], x[i]=tmp;
               }
   }

   #endif // SHELLS_H</div></PRE>
<p>Здесь тип  элементов  массива  обозначен идентификатором T. Такой идентификатор использован в списках параметров  шаблона  и функции, а также в операторе декларации буферной переменной tmp. Так как текст функции других изменений не имеет,  то в классе  T должны  быть  определены  все виды конструкторов (конструктор по умолчанию,  конструктор копирования).  Для элементов  класса  T, кроме   этого,   требуется  определение  функций  operator&gt;()  и operator=().
     Программа тестирования шаблона функции shells:
<pre><div class="code">
   #include &lt;stdio.h&gt;
   #include &lt;string.h&gt;
   #include "shells.h"
   class string {
      char *buffer;
   public:
      string():buffer(0) {} // Конструктор по умолчанию
      string(char *x) {
         buffer=new char[strlen(x)+1];
         if (buffer) strcpy(buffer,x);
      }
      string(string &x) { // Конструктор копирования
         buffer=new char[strlen(x.buffer)+1];
         if (buffer) strcpy(buffer,x.buffer);
      }

      int operator&gt;(string &item) {
         return strcmp(this-&gt;buffer,item.buffer)&gt;0;
      }

      string &operator=(string &item) { // Операция присваивания
         if (buffer) delete buffer;
         buffer=new char[strlen(item.buffer)+1];
         if (buffer) strcpy(buffer,item.buffer);
         return *this;
      }

      void operator=(char *item) { // Операция присваивания
         if (buffer) delete buffer;
         buffer=new char[strlen(item)+1];
         if (buffer) strcpy(buffer,item);
      }

      void print() { printf(" %s",buffer); }

      ~string() {
         delete buffer;
      }
   };

   void main(void) {
      int y[]={2,7,1,3,8};
      int n=sizeof(y)/sizeof(*y);
      string *x=new string[n];
      for (int i=0; i&lt;n; i++) {
         char temp[10];
         sprintf(temp,"\"%03d\"\0",y[i]);
         x[i]=temp;
      }

      printf("\n\n Вход: ");
      for (i=0; i&lt;n; i++) printf(" %5d",y[i]);
      shells(y,n);
      printf("\nВыход: ");
      for (i=0; i&lt;n; i++) printf(" %5d",y[i]);

      printf("\n\n Вход: ");
      for (i=0; i&lt;n; i++) x[i].print();
      shells(x,n);
      printf("\nВыход: ");
      for (i=0; i&lt;n; i++) x[i].print();
   }</div></pre>
     Результаты работы программы:
<PRE>
   Вход:      2     7     1     3     8
   Выход:      1     2     3     7     8

   Вход:  "002" "007" "001" "003" "008"
   Выход:  "001" "002" "003" "007" "008"
</PRE>
<p> Нетрудно заметить,  что шаблон функции shells разрешает переопределение и операции  индексации.  Это  позволяет  выполнять сортировку на структурах хранения данных,  отличных от линейного массива.  Таким образом, механизм шаблонов существенно расширяет возможности формализации прикладных задач,  предоставляемые языком С++ ранее рассмотренными понятиями классов и полиморфизма.
     Шаблоны могут применяться для взаимосвязанных функций:
<PRE><div class="code">
   //--------------------------------------------------------------
   // Решение системы линейных уравнений ax=b методом исключения
   //--------------------------------------------------------------

   template &lt;class Type&gt; // Модуль числа произвольного типа
   inline Type abs(const Type &value) {
      return (value&lt;0)? -value : value;
   }
   
   template &lt;class Type&gt; // Реализация метода исключения
   int simq(Type **a, Type *b, int n) {

      for (int j=0; j&lt;n; j++) { // Цикл по всем переменным
   // Поиск максимального элемента столбца
         Type amax=0, temp;
         for (int i=j, m; i&lt;n; i++)
            if ((temp=abs(a[i][j]))&gt;amax) {
               amax=temp, m=i;
            }
         if (!amax) return 0; // Случай вырожденной матрицы
   // Деление текущего уравнения с заменой строк
         Type *ai=a[m], *aj=a[j];
         amax=ai[j];
         for (int k=j; k&lt;n; k++) {
            temp=aj[k], aj[k]=ai[k], ai[k]=temp;
            aj[k]=amax;
         }
        Type &bj=b[j];
        temp=b[m], b[m]=bj, bj=temp/amax;
   // Исключение текущей переменной
        for (i=m=j+1; i&lt;n; i++) {
           ai=a[i];
           Type &aij=ai[j];
           for (k=m; k&lt;n; k++)
              ai[k]-=aij*aj[k];
           b[i]-=bj*aij;
        }
     }

   // Формирование результата

      for (j=--n-1; j&gt;=0; j--) {
         Type *aj=a[j], &bj=b[j];
         for (int k=n; k&gt;j; k--)
            bj-=aj[k]*b[k];
      }
      return 1; // Случай невырожденной матрицы
   }
   //--------------------------------------------------------------
</div></PRE>
<p>Здесь основной модуль - функция simq(),  вызывающая  функцию abs() для получения значения модуля элемента матрицы.  Обе функции параметризованы раздельно,  но компилятор предусмотрит их правильное совместное использование.
<P>
<div class="header"><A NAME="REF_2_2_3"></A>
     7.3. Переопределение шаблонов и специализация функций
</div>
<p>Шаблоны функций могут быть переопределены подобно переопределению функций,  так как их использование базируется на распознавании компилятором различий в списках параметров функций.
   Пример переопределения шаблонов функций:
<PRE><div class="code">
   // ШАБЛОНЫ ФУНКЦИЙ ПОИСКА МИНИМАЛЬНОГО ЗНАЧЕНИЯ
   template &lt;class T&gt; // Выбор минимума из пары объектов
   T min(T x, T y) { return (x&lt;y)? x:y; }

   template &lt;class T&gt; // Выбор минимума из массива объектов
   T min(T *x, int n) {
      T temp=x[0];
      for (int i=1; i&lt;n; i++)
         if (x[i]&lt;temp) temp=x[i];
         return temp;
      }</div>
</PRE>
(для ссылок далее текст шаблонов поместим в файл min_tmpl.h).
<p>Более того,  в  программе  могут  присутствовать  и обычные функции, переопределяющие специфическим составом списка параметров функции шаблона (такие функции иногда называют  <STRONG>специализированными</STRONG>). Например, при намерении выбора минимума  из пары строк в лексикографическом порядке текст программы можно просто дополнить функцией
<PRE><div class="code">
   // СПЕЦИАЛИЗИРОВАННАЯ ФУНКЦИЯ ПОИСКА МИНИМАЛЬНОГО ЗНАЧЕНИЯ
   char *min(char *x, char *y) { return strcmp(x,y)&lt;0 ? x:y; }
</div></PRE>
(для ссылок далее текст этой функции поместим в файл min_char.h).

<OL><p>Возможные конфликты разрешаются следующей жесткой последовательностью этапов выбора экземпляра переопределенных функций:
</P>
<LI>поиск специализированной (не представленной шаблонами)
функции с совпадающим списком параметров;
<LI>поиск шаблона функции с точным соответствием списка параметров;
<LI>поиск специализированной функции по условию совпадения списка параметров после возможных преобразований типов.
</OL>
<p>Успех поиска на любом этапе завершает выбор функции. Отметим, что анализ компилятором шаблонов функций не предполагает
преобразования типов.
<p> Пример использований переопределенных шаблонов и  специализированных функций:
<pre><div class="code">
   #include &lt;stdio.h&gt;
   #include &lt;string.h&gt;
   #include "min_tmpl.h" // ШАБЛОНЫ ФУНКЦИЙ ПОИСКА
   #include "min_char.h" // СПЕЦИАЛИЗИРОВАННАЯ ФУНКЦИЯ ПОИСКА
   void main(void) {
      int y[]={2,7,1,3,8};
      int n=sizeof(y)/sizeof(*y);
      
      printf("\n\n Минимум из {%d",y[0]);
      for (int i=1; i&lt;n; i++) printf(", %d",y[i]);
      printf("} есть %d",min(y,n));

      printf("\n Минимум из {%d, %d} есть %d",
      y[0],y[1],min(y[0],y[1]));

      char s1[]="one", s2[]="two";
      printf("\n Минимум из {\"%s\", \"%s\"} есть \"%s\"",s1,s2,min(s1,s2));
   }</div></pre>
     Результаты работы программы:
<PRE >
   Минимум из {2, 7, 1, 3, 8} есть 1
   Минимум из {2, 7} есть 2
   Минимум из {"one", "two"} есть "one"
</PRE>


<PRE >
#include "stdafx.h"

// Пример спецификации шаблона функции
template<class T> void f(T t) {}

// Явная специализация функции шаблона
//
void f(char) {}

// Явная специализация функции шаблона
// с явным определением параметра шаблона
//
template<> void f<char>(char c) {}

// Явная специализация функции шаблона
// без определения параметра шаблона
//
template<> void f(double d) {}

int main(int argc, char* argv[])
{
	f(10);
	printf("Hello World!\n");
	return 0;
}
</PRE>

<P>
<div class="header"><A NAME="REF_2_2_4"></A>
                  7.4. Определение шаблонов классов
</div>
<P>
     Синтаксис определения шаблона класса:
<PRE >
   template-declaration : 
    template < template-argument-list > declaration 

   template-argument-list : 
    template-argument
    template-argument-list , template-argument 

   template-argument : 
    type-argument
    argument-declaration 

   type-argument : 
    class identifier
    typename identifier 
</PRE>
<PRE><div class="code">
   template &lt;список_параметров_шаблона&gt; определение_класса
</div></PRE>
<p>(здесь угловые скобки обязательны, как и для шаблонов функций).
<p> Элемент "список_параметров_шаблона" не может быть пустым, а его элементы разделяются запятыми.
<UL>     Виды параметров шаблона:
<LI>     параметр типа - ключевое слово class и идентификатор;
<LI>     нетиповой параметр - имя типа и идентификатор, определяющие
константу.
</UL>
<p> Элемент "список_параметров_шаблона" определяет набор типов и констант,  параметризующих текст определения класса. Каждый параметр является локальным в рамках элемента "определение_класса".
<p> Элемент "определение_класса"  -  обычное определение класса, где хотя бы раз упомянуты идентификаторы типовых и нетиповых  параметров из списка параметров шаблона.
<p>Если функции-элементы определяются вне определения класса,
то синтаксис их определения должен иметь вид
<PRE><div class="code">
   template &lt;список_параметров_шаблона&gt;
   тип_результата
   имя_класса&lt;параметры_шаблона&gt;::
   имя_функции(параметры_функции) {
      //
      // Тело функции
      //
  }</div>
</PRE>
<p>Пример параметризации класса с внешним определением функций-элементов:
<PRE><div class="code">
   #ifndef ANY_TYPE_ARRAY_H
   #define ANY_TYPE_ARRAY_H
   // Шаблон класса с описанием функций-элементов
   template &lt;class Type, int Size&gt;
   class any_type_array {
   protected:
      Type *area;
   public:
      any_type_array();
      ~any_type_array();
   };

   // Внешние определения функций-элементов шаблона класса

   template &lt;class Type, int Size&gt; // Шаблон конструктора
   any_type_array&lt;Type,Size&gt;::any_type_array() {
      area=new Type[Size];
      printf("\n+ Size=%d %d",Size,sizeof(Type));
   }

   template &lt;class Type, int Size&gt; // Шаблон деструктора
   any_type_array&lt;Type,Size&gt;::~any_type_array() {
      printf("\n- Size=%d %d",Size,sizeof(Type));
      delete[] area;
   }

   #endif // ANY_TYPE_ARRAY_H
</div></PRE>
<p>(для дальнейших ссылок предполагается наличие этого текста в файле tarray.h).
<p>Вложенность определений шаблонов классов не допускается, однако  внутри элемента "определение_класса" можно объявить вложенный класс с параметрами определяемого шаблона класса.
     Ограничений на содержание  определения  параметризуемого
класса нет. Допускается использование статических элементов данных и функций, дружественных функций и вложенных классов.
<P>
<div class="header"><A NAME="REF_2_2_5"></A>
                 7.5. Использование шаблонов классов
</div>
<p>
     Шаблон класса используется для создания его представителей
в местах употребления имени класса как имени типа (в языке C++
понятие класса -  синоним  типа,  определяемого  пользователем).
Например, имя типа необходимо в операторах декларации объектов,
приведения типа, переопределения типа (typedef) и т.п.
     Имя представителя образуется из имени шаблона класса и заключенного в угловые скобки списка аргументов.  В списке аргументов  каждому  типовому  параметру шаблона должно соответствовать известное в этой точке имя типа, а нетиповому - константное выражение ожидаемого типа.
<P>
     Пример использования шаблона класса any_type_array:
<pre><div class="code">
   #include &lt;stdio.h&gt;
   #include "tarray.h"
   void main() {
      any_type_array&lt;int, 50&gt;  x;
      any_type_array&lt;long,25&gt;  y;
   }</div></pre>
     Результаты работы программы:
<PRE>
   + Size=50 2
   + Size=25 4
   -  Size=25 4
   -  Size=50 2
</PRE>
<p>Программирование шаблонов может проводиться с учетом возможностей  автоматического  образования  представителей  производных классов:
<pre><div class="code">
   #include &lt;iostream.h&gt;
   template &lt;class Type&gt;
   class array {
   protected:
      Type *area;
      int number;
   public:
      class invalid_index {}; // Исключение при нарушении границ
      virtual ~array();
      array() {};
      array(int size);
      Type &operator[](int index) {
         if ((index&gt;=0)&amp;&amp;(index&lt;number)) return array::area[index];
         throw invalid_index; // Порождение исключения (см. 3.1)
      }
      operator int() { return area &amp;&amp; number; }
   };

   template &lt;class Type&gt;
   array&lt;Type&gt;::array(int size): number(size), area(new Type[size]) {}

   template &lt;class Type&gt;
   array&lt;Type&gt;::~array() {
      delete[] area;
   }

   template &lt;class Type, int size&gt;
   class any_array: public array&lt;Type&gt; {
   public:
      any_array():array&lt;Type&gt;(size) {}
   };

   void main(void) {
      array&lt;int&gt; X(10);
      if (X) cout&lt;&lt;endl&lt;&lt;"X: OK...";
     
      any_array&lt;any_array&lt;int,10&gt;,15&gt Y;
      if (Y) cout&lt;&lt;endl&lt;&lt;"Y: OK...";
   }</div></pre>
     Результаты работы программы:
<PRE>
   X: OK...
   Y: OK...
</PRE>
<a href="7_5.exe">Выполнить</a>
<p>Обратите внимание  на оператор декларации объекта Y: в качестве параметра представителя шаблона использован также  представитель шаблона.
<P>
<div class="header"><A NAME="REF_2_2_6"></A>
             7.6  Специализация параметризованных классов
</div>
<p>Подобно специализации шаблонов функций,  возможна специализация и шаблонов классов.
Специализация класса может быть  частичной  либо полной.  Частичная специализация предполагает явное определение представителей некоторых  функций-элементов.  Полная специализация  соответствует переопределению самого класса с изменением состава его элементов.    
<p>Особенности синтаксиса специализации шаблонов отражены в следующем примере программы:
<pre><div class="code">
   #include &lt;stdio.h&gt;
   #include &lt;string.h&gt;
   // Параметризация класса
   template &lt;class Type, int Size&gt; // Шаблон класса
   class any_type_array {
   protected:
      Type *area;
   public:
      any_type_array();
      ~any_type_array();
   };

   template &lt;class Type, int Size&gt; // Шаблон класса
   any_type_array&lt;Type,Size&gt;::any_type_array() {
      area=new Type[Size];
      printf("\n+ Size=%d * %d",Size,sizeof(Type));
   };

   template &lt;class Type, int Size&gt; // Шаблон класса
   any_type_array&lt;Type,Size&gt;:: ~any_type_array() {
      printf("\n- Size=%d * %d",Size,sizeof(Type));
      delete[] area;
   }

   // Частичная специализация класса

   any_type_array&lt;int,11&gt;::any_type_array() {
      area=new Type[Size];
      printf("\n+ Size=%d * %d ???",Size,sizeof(Type));
  }

   any_type_array&lt;long,25&gt;:: ~any_type_array() {
      printf("\n- Long Size=%d * %d",Size,sizeof(Type));
      delete[] area;
   }

   // Полная специализация класса

   class any_type_array&lt;char,100&gt; {
      char buffer[100];  // Новый элемент данных
   protected:
      char *area;
   public:
      any_type_array&lt;char,100&gt;() {
         area=new char[100];
         area[0]=0;
         printf("\n+ Char Size=100 * %d",sizeof(char));
      }
      any_type_array&lt;char,100&gt;(char *s) {
         area=new char[100];
         strcpy(area,s);
         printf("\n+ Char Size=100 * %d",sizeof(char));
      }
      void print() { // Новая функция
         printf("\n Area=\"%s\"",area);
      }
        
      ~any_type_array() {
         printf("\n- Char Size=%d %d ???",100,sizeof(char));
         delete[] area;
      }
   };

   void main() {
      any_type_array&lt;int,50&gt;  x1;
      any_type_array&lt;int,11&gt;  x2; // Специализация
      any_type_array&lt;long,25&gt; y0;
      
      any_type_array&lt;char,100&gt; z1("z1"), z2;  // Специализация
      z1.print();
      z2.print();
      any_type_array&lt;char,30&gt; z3;
   }</div></pre>
     Результаты работы программы:
<PRE>
   + Size=50 * 2
   + Size=11 * 2 ???
   + Size=25 * 4
   + Char Size=100 * 1
   + Char Size=100 * 1
   Area="z1"
   Area=""
   + Size=30 * 1
   -  Size=30 * 1
   -  Char Size=100 1 ???
   -  Char Size=100 1 ???
   -  Long Size=25 * 4
   -  Size=11 * 2
   -  Size=50 * 2
</PRE>
<a href="7_6.exe">Выполнить</a>
<p>Отметим, что специализированные функции шаблона класса могут быть  переопределены многократно,  но шаблон класса переопределять нельзя. Например, одновременное наличие в тексте программы определений
<PRE><div class="code">
   template &lt;class Type, int Size&gt;
   class any_type_array { /* ... */ };

   template &lt;int Size, class Type&gt;
   class any_type_array { /* ... */ };

   template &lt;class Type&gt;
   class any_type_array { /* ... */ };

   template &lt;int Size&gt;
   class any_type_array { /* ... */ };
</div></PRE>
считается ошибочным.
<p> Последнее отмеченное  ограничение  не является обременительным, так как можно просто использовать новое имя класса. Более того,  даже  непараметризованный  класс - достаточно сложный элемент любой программы.  Многократное переопределение класса  чаще  всего свидетельствут  о недостаточно продуманном проектировании иерархии классов.
<P>
Ключевое слово typename используется только в определении шаблона  
<PRE >
     template &lt;class T&gt; class X
     {
       typename T::Y m_y;   // treat Y as a type
     };

     template &lt;class T1, class T2&gt; ...
     template &lt;typename T1, typename T2&gt; ...
</PRE>

<div class="header"><A NAME="REF_2_2_7"></A>
                  7.7. Характеристика шаблонов
</div>
<P>
     Достоинства шаблонов:
<DL>
<DD>высокая эффективность работы с различными типами объектов класса по сравнению с полиморфизмом;
<DD>безопасное использование типов.
</DL>
     Недостатки шаблонов:
<DL>
<DD>увеличение размера исполняемого модуля программы из-за наличия представителей шаблона для каждого порожденного типа;
<DD>реализация шаблона может оказаться оптимальной только для некоторого набора типов.
</DL>
     Очевидно, что отмеченные черты не могут быть причиной отказа от использования шаблонов, так как возможность их специализации позволяет добиться требуемого качества программы.
<P>
      Например, шаблоны функций минимума и максимума в форме
<PRE><div class="code">
   template &lt;class T&gt;
   inline const T& min(const T &x, const T &y) {
      return x&gt;y ? y:x;
   }

   template &lt;class T&gt;
   inline const T& max(const T &x, const T &y) {
      return x&gt;y ? x:y;
   }</div>
</PRE>
<p>(подобное определение имеется в файле stdlib.h системы программирования Borland C++ 4.0) применимы ко всем типам, но для базовых типов данных недостаточно эффективны:  ссылки на параметры и результат порождают дополнительные машинные команды косвенных обращений.
<p>
<div class="header"><A NAME="REF_2_2_8"></A>
                  7.8. Стандартная библиотека шаблонов
</div>
<p>
<div class="tablediv"><table cellspacing="0" class="dtTABLE">

<TR VALIGN="top">
<TD width=33%><A HREF="vclrfalgorithm_header.htm">&lt;algorithm&gt;</A></TD>
<TD width=33%><A HREF="vclrfbitset_header.htm">&lt;bitset&gt;</A></TD>
<TD width=34%><A HREF="vclrf_cassert_header.htm">&lt;cassert&gt;</A></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><A HREF="vclrf_cctype_header.htm">&lt;cctype&gt;</A></TD>
<TD width=33%><A HREF="vclrf_cerrno_header.htm">&lt;cerrno&gt;</A></TD>
<TD width=34%><A HREF="vclrf_cfloat_header.htm">&lt;cfloat&gt;</A></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><A HREF="vclrf_ciso646_header.htm">&lt;ciso646&gt;</A></TD>
<TD width=33%><A HREF="vclrf_climits_header.htm">&lt;climits&gt;</A></TD>
<TD width=34%><A HREF="vclrf_clocale_header.htm">&lt;clocale&gt;</A></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><A HREF="vclrf_cmath_header.htm">&lt;cmath&gt;</A></TD>
<TD width=33%><A HREF="vclrf_complex_header.htm">&lt;complex&gt;</A></TD>
<TD width=34%><A HREF="vclrf_csetjmp_header.htm">&lt;csetjmp&gt;</A></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><A HREF="vclrf_csignal_header.htm">&lt;csignal&gt;</A></TD>
<TD width=33%><A HREF="vclrf_cstdarg_header.htm">&lt;cstdarg&gt;</A></TD>
<TD width=34%><A HREF="vclrf_cstddef_header.htm">&lt;cstddef&gt;</A></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><A HREF="vclrf_cstdio_header.htm">&lt;cstdio&gt;</A></TD>
<TD width=33%><A HREF="vclrf_cstdlib_header.htm">&lt;cstdlib&gt;</A></TD>
<TD width=34%><A HREF="vclrf_cstring_header.htm">&lt;cstring&gt;</A></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><A HREF="vclrf_ctime_header.htm">&lt;ctime&gt;</A></TD>
<TD width=33%><A HREF="vclrf_cwchar_header.htm">&lt;cwchar&gt;</A></TD>
<TD width=34%><A HREF="vclrf_cwctype_header.htm">&lt;cwctype&gt;</A></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><A HREF="vclrfdeque_header_file.htm">&lt;deque&gt;</A></TD>
<TD width=33%><A HREF="vclrf_exception_header.htm">&lt;exception&gt;</A></TD>
<TD width=34%><A HREF="vclrf_fstream_header.htm">&lt;fstream&gt;</A></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><A HREF="vclrf_functional_header.htm">&lt;functional&gt;</A></TD>
<TD width=33%><A HREF="vclrfhash_map_header_file.htm">&lt;hash_map&gt;</A></TD>
<TD width=34%><A HREF="vclrfhash_set_header_file.htm">&lt;hash_set&gt;</A></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><A HREF="vclrf_iomanip_header.htm">&lt;iomanip&gt;</A></TD>
<TD width=33%><A HREF="vclrfios_header.htm">&lt;ios&gt;</A></TD>
<TD width=34%><A HREF="vclrf_iosfwd_header.htm">&lt;iosfwd&gt;</A></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><A HREF="vclrf_iostream_header.htm">&lt;iostream&gt;</A></TD>
<TD width=33%><A HREF="vclrf_istream_header.htm">&lt;istream&gt;</A></TD>
<TD width=34%><A HREF="vclrf_iterator_header.htm">&lt;iterator&gt;</A></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><A HREF="vclrf_limits_header.htm">&lt;limits&gt;</A></TD>
<TD width=33%><A HREF="vclrflist_header_file.htm">&lt;list&gt;</A></TD>
<TD width=34%><A HREF="vclrf_locale_header.htm">&lt;locale&gt;</A></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><A HREF="vclrfmap_header_file.htm">&lt;map&gt;</A></TD>
<TD width=33%><A HREF="vclrf_memory_header.htm">&lt;memory&gt;</A></TD>
<TD width=34%><A HREF="vclrf_new_objects.htm">&lt;new&gt;</A></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><A HREF="vclrf_numeric_header.htm">&lt;numeric&gt;</A></TD>
<TD width=33%><A HREF="vclrf_ostream_header.htm">&lt;ostream&gt;</A></TD>
<TD width=34%><A HREF="vclrfqueue_header_file.htm">&lt;queue&gt;</A></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><A HREF="vclrfset_header_file.htm">&lt;set&gt;</A></TD>
<TD width=33%><A HREF="vclrf_sstream_header.htm">&lt;sstream&gt;</A></TD>
<TD width=34%><A HREF="vclrfstack_header_file.htm">&lt;stack&gt;</A></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><A HREF="vclrf_stdexcept_header.htm">&lt;stdexcept&gt;</A></TD>
<TD width=33%><A HREF="vclrf_streambuf_header.htm">&lt;streambuf&gt;</A></TD>
<TD width=34%><A HREF="vclrf_string_header.htm">&lt;string&gt;</A></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><A HREF="vclrf_strstream_header.htm">&lt;strstream&gt;</A></TD>
<TD width=33%><A HREF="vclrf_utility_header.htm">&lt;utility&gt;</A></TD>
<TD width=34%><A HREF="vclrf_valarray_header.htm">&lt;valarray&gt;</A></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><A HREF="vclrfvector_header_file.htm">&lt;vector&gt;</A></TD>
<TD width=33%>&nbsp;</TD>
<TD width=34%>&nbsp;</TD>
</TR>
</table></div>
<p>
<P><HR WIDTH="100%" SIZE="1">
<a href="#REF_1_C">Начало</a>
<p>
<div class="header"><A NAME="REF_2_3"></A>
              8. ОБРАБОТКА ИСКЛЮЧИТЕЛЬНЫХ СИТУАЦИЙ
</div>
<div class="header"><A NAME="REF_2_3_1"></A>
             8.1. Схема обработки исключений в С++
</div>
<p>Термин "исключениe" (exception) в  C++ принято использовать для  обозначения  особых ситуаций,  когда продолжение выполнения естественной последовательности операторов требуется безвозвратно переключить на блок завершающей части такой последовательности.  Выявление особых ситуаций выполняется программным  способом путем  проверки  некоторых  условий  нормального  хода программы (например, наличие выделенной памяти по ненулевому значению указателя).  Порождение  (выброс) исключения программируется специальным оператором throw, синтаксис которого имеет вид:
<PRE><div class="code">
   throw выражение;
</div></PRE>
<p>(такой оператор подобен оператору возврата из функции и может быть использован в любом месте программы).
<p> Местоположение оператора  throw иногда называют точкой выброса исключения:
<PRE><div class="code">
   // Фрагмент программы с порождением исключений

   int *int_array=new int[1000];
   if (!int_array)
      throw 1000; /////////////// Выброс исключения типа int
   ofstream output("e:\temp\data");
   if (!output)
      throw "e:\temp\data"; ///// Выброс исключения типа char *
</div></PRE>
<p>Очевидно, что при нормальном ходе программы точки выброса
исключений обходятся.
     Управление исключениями согласно стандарту ANSI C++ строится по схеме завершающего выхода из контролируемого  блока  программы.  Контролируемый  блок  программы  оформляется посредством
синтаксической конструкции вида
<PRE><div class="code">
   try {
      //
      // Операторы контролируемого блока, включая throw
      //
   }
   // Определение ловушек исключений - операторы catch
</div></PRE>
<p>Среди операторов контролируемого блока может быть любое количество операторов throw.  Контролируемые блоки могут быть вложенными.  Тело любой функции,  вызываемой прямо либо косвенно из контролируемого блока, считается принадлежащим этому блоку.
     Непосредственно за  контролируемым блоком размещаются в любом количестве блоки обработки исключительных ситуаций,  синтаксис которых может иметь одну из трех форм:
<DL>
<DD>1) параметризованный специализированный блок
<PRE><div class="code">
   catch (имя_типа имя_параметра) {
      //
      // Операторы блока обработки исключения
      //
   }</div>
</PRE>
<p>(специализации блока соответствует элемент "имя_типа", а элемент 
"имя_параметра" обозначает локальный в теле этого блока объект);
<DD>2) непараметризованный специализированный блок
<PRE><div class="code">
   catch (имя_типа) {
      //
      // Операторы блока обработки исключения
      //
   }</div>
</PRE>
<p>(здесь специализации блока соответствует элемент "имя_типа", но
параметр этого типа в блок не передается);
<DD>3) неспециализированный блок
<PRE><div class="code">
   catch (...) {
      //
      // Операторы блока обработки исключения
      //
   }</div>
</PRE>
<p>(многоточие здесь  - синтаксический элемент, обозначающий способность 
блока обрабатывать не обслуженные предшествующими блоками исключения,
поэтому такой блок должен размещаться последним).
</DL>
     Операторы catch  -  ловушки  исключений,  всегда следуют за оператором try,  образуя единую синтаксическую конструкцию обработки исключений, порождаемых операторами throw в контролируемом блоке.</P>
<p>Набор блоков  операторов catch в процессе выполнения операторов программы обходится,  если в контролируемом блоке исключение не порождено.
<p>Порождение исключения означает:</P>
<UL>
<LI>создание копии объекта, представляющего выражение оператора trow (ограничений на тип выражения нет, но конструктор копирования должен быть доступен);
<LI>вызов деструкторов объектов,  порожденных от начала контролируемого блока до точки выброса исключения;
<LI>поиск подходящего блока обработки исключения, выбираемого по <STRONG>типу  выражения</STRONG>  в операторе throw.
</UL>
     <p>Если такой выбор успешно <STRONG>однозначно</STRONG>  выполнен среди  специализированных или наличного неспециализированного блока, то управление передается выбранному блоку подобно оператору вызова функции с одним параметром. После исполнения операторов блока исключение считается обработанным и управление передается оператору, непосредственно  расположенному за последним блоком catch активного контролируемого блока.
     В случае  неудачи выбора блока обработки исключения в некотором контролируемом блоке поиск последовательно продолжается  в блоках предшествующих уровней вложенности (деструкторы порожденных локальных объектов продолжают также вызываться).  Переход на предшествующий уровень вложенности может программироваться явно:
оператор throw без выражения перебрасывает текущее исключение на такой уровень с тем же значением выражения.
     При неудаче поиска подходящего блока  обработки  исключения программа завершается аварийно - функция среды эпилога программы terminate по умолчанию организует вызов функции  abort().  Можно назначить  собственную функцию,  которая будет вызвана перед завершением программы. Такое назначение реализуется определенной в файле eh.h функцией
<PRE><div class="code">
   terminate_function set_terminate(terminate_function);
</div></PRE>
<p>Здесь тип  terminate_function - указатель функции - обработчика аварийного выхода,  которая не должна иметь параметры и
возвращать результат:
<PRE><div class="code">
   typedef void (*terminate_function)();
</div></PRE>
<p>Функция set_terminate может вызываться несколько раз, устанавливая новый обработчик и возвращая в качестве результата  указатель прежнего обработчика.
     Пример управления исключениями в Visual C++:
<pre><div class="code">
   #include &lt;iostream.h&gt;
   #include &lt;eh.h&gt;
   #include &lt;process.h&gt;
   class CTest {
      int m;
   public:
      CTest():m(0) {
         cout&lt;&lt;endl&lt;&lt;"Ctest(0) создан...";
      }
      CTest(int i):m(i) {
         cout&lt;&lt;endl&lt;&lt;"Ctest("&lt;&ltm&lt;&lt;") создан...";
      }
      CTest(CTest &t):m(-t.m) {
         cout&lt;&lt;endl&lt;&lt;"Ctest("&lt;&ltt.m&lt;&lt;")&lt;=Ctest("&lt;&ltm&lt;&lt;")...";
      }
       
      ~CTest() {
         cout&lt;&lt;endl&lt;&lt;"Ctest("&lt;&ltm&lt;&lt;") разрушен...";
         m=0;
      }

      friend ostream& operator&lt;&lt(ostream &, CTest &);
   };

   ostream & operator&lt;&lt(ostream &out, CTest &item) {
      out&lt;&lt;"Исключение CTest("&lt;&ltitem.m&lt;&lt;")... ";
      return out;
   }

   class CDemo {
   public:
      CDemo() { cout&lt;&lt;endl&lt;&lt;"Создание CDemo."; }
      ~CDemo() { cout&lt;&lt;endl&lt;&lt;"Разрушение CDemo."; }
   };

   void Aproc() {
      CDemo D;
      CTest X(2);
      cout&lt;&lt;endl&lt;&lt;"Aproc: Выброс исключения CTest(1).";
      throw CTest(1);
      cout&lt;&lt;endl&lt;&lt;"Aproc: Что после исключения CTest(1) ?";
   }

   void proc_1() {
      cout&lt;&lt;endl&lt;&lt;"Начало proc_1.";
      try {
         cout&lt;&lt;endl&lt;&lt;"Блок try, вызов Aproc.";
         Aproc();
      }

     catch (CTest E) {
        cout&lt;&lt;endl&lt;&lt;"Ловушка исключения типа Ctest." &lt;&lt;endl <br>            &lt;&lt;"Поймано исключение: "&lt;&lt;E;
     }
     catch (char *str) {
        cout&lt;&lt;endl&lt;&lt;"Поймано исключение типа (char *): "&lt;&lt;str;
     }
     cout&lt;&lt;endl&lt;&lt "Завершение proc_1.";
   }

   void proc_2() {
      cout&lt;&lt;endl&lt;&lt;"Начало proc_2.";
      try {
         cout&lt;&lt;endl &lt;&lt;"Контролируемый блок: Выброс исключения int(0).";
         throw int(0);
      }
      catch (CTest E) {
         cout&lt;&lt;endl&lt;&lt;"Ловушка исключения типа Ctest."&lt;&lt;endl<br>            &lt;&lt;"Поймано исключение: "&lt;&lt;E;
      }
      catch (char *str) {
         cout&lt;&lt;endl&lt;&lt;"Поймано исключение типа (char *): "&lt;&lt;str;
      }
      catch (...) {
         cout&lt;&lt;endl&lt;&lt;"Что это такое ??? Переброс дальше!";
         throw;
      }
      cout&lt;&lt;endl&lt;&lt;"Завершение proc_2.";
   }

   void term_func() {
      cout&lt;&lt;endl&lt;&lt;"Обработчик завершения программы."&lt;&lt;endl<br>            &lt;&lt;"Возврат в порождающий процесс...";
      exit (-1);
   }

   void main() {
      cout&lt;&lt;endl&lt;&lt;"Начало программы: шаг 1.";
      try {
         cout&lt;&lt;endl&lt;&lt;"Вызов proc_1 из контролируемого блока.";
         proc_1();
      }
      catch (...) {
         cout&lt;&lt;endl&lt;&lt;"Шаг 1 прерван каким-то исключением...";
      }
      cout&lt;&lt;endl&lt;&lt;"Продолжение программы: шаг 2.";
      try {
         cout&lt;&lt;endl&lt;&lt;"Вызов proc_2 из контролируемого блока.";
         proc_2();
      }
      catch (...) {
         cout&lt;&lt;endl&lt;&lt;"Шаг 2 прерван каким-то исключением...";
      }

      cout&lt;&lt;endl&lt;&lt;"Заключительный шаг программы."&lt;&lt;endl<br>           &lt;&lt;"Установлен обработчик аварийного завершения.";

      set_terminate(term_func);
      cout&lt;&lt;endl&lt;&lt;"Выброс непредусмотренного исключения...";
      throw 1;
      cout&lt;&lt;endl&lt;&lt;"Последнее сообщение программы";
   }</div></pre>
     Результаты работы программы:
<PRE>
   Начало программы: шаг 1.
   Вызов proc_1 из контролируемого блока.
   Начало proc_1.
   Блок try, вызов Aproc.
   Создание CDemo.
   Ctest(2) создан...
   Aproc: Выброс исключения CTest(1).
   Ctest(1) создан...
   Ctest(1)&lt;=Ctest(-1)...

   Ctest(2) разрушен...
   Разрушение CDemo.
   Ловушка исключения типа Ctest.
   Поймано исключение: Исключение CTest(-1)...
   Ctest(-1) разрушен...
   Ctest(1) разрушен...
   Завершение proc_1.
   Продолжение программы: шаг 2.
   Вызов proc_2 из контролируемого блока.
   Начало proc_2.
   Контролируемый блок: Выброс исключения int(0).
   Что это такое ??? Переброс дальше!
   Шаг 2 прерван каким-то исключением...
   Заключительный шаг программы.
   Установлен обработчик аварийного завершения.
   Выброс непредусмотренного исключения...
   Обработчик завершения программы.
   Возврат в порождающий процесс...
</PRE>
<a href="8_1.exe">Выполнить</a>
<P>
<div class="header"><A NAME="REF_2_3_2"></A>
        8.2. Понятие структурного управления исключениями
</div>
<p>В современных  системах программирования на языках C/C++ существует механизм так называемого структурного управления  исключениями (Structured Exception Handling, SEH),  где  исключения  идентифицируются только типом unsigned int. Структурное управление исключениями позволяет наряду с обработкой потока явно порождаемых программой исключений обрабатывать и исключения, порождаемые операционной системой в аварийных ситуациях. Этим объясняется наличие единственного типа идентификации исключений и, как следствие, единственного блока обработки исключений в контролируемом блоке программы.</P>
<P>Различают две разновидности структурного управления исключениями:</P>
<UL>
<LI><A HREF="#REF_2_3_3">кадрированное управление</A> - блок обработки исключений активизируется только в момент порождения исключения;
<LI><A HREF="#REF_2_3_4">завершающее управление</A> - любой вид выхода из контролируемого блока программы завершается активизацией предопределенного блока операторов.
</UL><p> Операторы контролируемого блока могут явно породить исключение, используя функцию
<PRE><div class="code">
   WINBASEAPI VOID WINAPI RaiseException (
      DWORD dwExceptionCode,
      DWORD dwExceptionFlags,
      DWORD nNumberOfArguments,
      CONST DWORD *lpArguments );
</div></PRE><p>(здесь типы параметров соответствуют системе программирования Visual C++).
     Интерпретация параметров функции RaiseException:
<PRE><div class="code">
   dwExceptionCode - код исключения;
   dwExceptionFlags - флаг возобновления исключения;
   nNumberOfArguments - количество аргументов детализации описания
        исключения в массиве lpArguments.
</div></PRE>
<p> Предопределенные коды исключений:
<PRE><div class="code">
   EXCEPTION_ACCESS_VIOLATION
   EXCEPTION_DATATYPE_MISALIGNMENT
   EXCEPTION_BREAKPOINT
   EXCEPTION_SINGLE_STEP
   EXCEPTION_ARRAY_BOUNDS_EXCEEDED
   EXCEPTION_FLT_DENORMAL_OPERAND
   EXCEPTION_FLT_DIVIDE_BY_ZERO
   EXCEPTION_FLT_INEXACT_RESULT
   EXCEPTION_FLT_INVALID_OPERATION
   EXCEPTION_FLT_OVERFLOW
   EXCEPTION_FLT_STACK_CHECK
   EXCEPTION_FLT_UNDERFLOW
   EXCEPTION_INT_DIVIDE_BY_ZERO
   EXCEPTION_INT_OVERFLOW
   EXCEPTION_PRIV_INSTRUCTION
   EXCEPTION_IN_PAGE_ERROR
   EXCEPTION_ILLEGAL_INSTRUCTION
   EXCEPTION_NONCONTINUABLE_EXCEPTION
   EXCEPTION_STACK_OVERFLOW
   EXCEPTION_INVALID_DISPOSITION
   EXCEPTION_GUARD_PAGE
</div></pre>
<p>Таким образом,  предопределенные исключения достаточно подробно представляют ошибки, обнаруживаемые операционной системой.
<P>
<div class="header"><A NAME="REF_2_3_3"></A>
          8.3. Кадрированное управление исключениями
</div>
<p> Синтаксис определения кадрированного управления исключениями:
<PRE><div class="code">
   __try {
      //
      // Операторы контролируемого блока
      //
   } 
   __except (выражение_фильтра) {
      //
      // Операторы блока обработки исключения
      //
   }</div>
</PRE>
<p>Блок обработки  исключения можно рассматривать как условный оператор, где решение о продолжении процесса определяется вычисляемым после порождения исключения выражением фильтра.
     Выражение фильтра может принимать одно из значений:
<PRE><div class="code">
   EXCEPTION_EXECUTE_HANDLER (1) - обработать исключение;
   EXCEPTION_CONTINUE_SEARCH (0) - продолжение поиска обработчика
         исключения на предшествующем уровне вложенности оператора __try;
   EXCEPTION_CONTINUE_EXECUTION (-1) - возврат управления в точку
         выброса исключения.
</div></PRE>
<p>Как в выражении фильтра, так и в блоке обработки исключения можно получить детальную информацию о причине исключения,  вызывая функции
<pre><div class="code">
   unsigned long GetExceptionCode(void) - код исключения;
   (struct _EXCEPTION_POINTERS *)
   GetExceptionInformation(void) - указатель на структуру с детальным<br>                 описанием исключения.
</div></pre>
     Пример демонстрационной программы:
<pre><div class="code">
   #include &lt;afxwin.h&gt;
   #include &lt;fstream.h&gt;
   ofstream x("test.txt");

   void samples() {
      if (x) {
         x&lt;&lt;endl&lt;&lt;"Начало samples. Шаг 1.";
         __try {
            x&lt;&lt;endl&lt;&lt;"Контролируемый блок 1.";
              &lt;&lt;endl&lt;&lt;"Преднамеренное исключение: код 19970405";
         RaiseException(19970405L, EXCEPTION_NONCONTINUABLE,0,0);
         x&lt;&lt;endl&lt;&lt;"Завершение шага 1.";
      }  __except (x&lt;&lt;endl&lt;&lt;"Фильтр 1 активен", 1) {
         x&lt;&lt;endl&lt;&lt;"Прерывание шага 1: код "&lt;&ltGetExceptionCode();
      }

      x&lt;&lt;endl&lt;&lt;"Продолжение samples. Шаг 2.";

      __try {
         x&lt;&lt;endl&lt;&lt;"Контролируемый блок 2.";
           &lt;&lt;endl&lt;&lt;"Демонстративное деление на нуль...";
         int i=2, j=0;
         i/=j;
         x&lt;&lt;endl&lt;&lt;"Завершение шага 2.";
      } __except (x&lt;&lt;endl&lt;&lt;"Фильтр 2 активен", 1) {
      x&lt;&lt;endl&lt;&lt;"Прерывание шага 2: код "
       &lt;&lt;GetExceptionCode();
      }  
     
      x&lt;&lt;endl&lt;&lt;"Продолжение samples. Шаг 3.";
      
      __try {
         x&lt;&lt;endl&lt;&lt;"Контролируемый блок 3.";
           &lt;&lt;endl&lt;&lt;"Попытка нарушения защиты памяти...";
         int *p = 0; // Пустой указатель !
         *p = 1997;
         x&lt;&lt;endl&lt;&lt;"Завершение шага 3.";
      } __except (x&lt;&lt;endl&lt;&lt;"Фильтр 3 активен", 1) {
           x&lt;&lt;endl&lt;&lt;"Прерывание шага 3: код "
             &lt;&ltGetExceptionCode();
      }
      x&lt;&lt;endl&lt;&lt;"Завершение samples";
     }
  }

   class DemoTryExcept: public CWinApp {
   public:
      BOOL InitInstance() {
         AfxMessageBox("ДЕМОНСТРАЦИЯ ОБРАБОТКИ ИСКЛЮЧЕНИЙ");
         samples();
         return FALSE;
   }
  } main; // Аналог функции main() в Visual C++
</div></pre>
     Результаты работы программы (файл test.txt):
<PRE>
   Начало samples. Шаг 1.
   Контролируемый блок 1.
   Преднамеренное исключение: код 19970405
   Фильтр 1 активен
   Прерывание шага 1: код 19970405
   Продолжение samples. Шаг 2.
   Контролируемый блок 2.
   Демонстративное деление на нуль...
   Фильтр 2 активен
   Прерывание шага 2: код 3221225620
   Продолжение samples. Шаг 3.
   Контролируемый блок 3.
   Попытка нарушения защиты памяти...
   Фильтр 3 активен
   Прерывание шага 3: код 3221225477
   Завершение samples
</PRE>
<P>
<div class="header"><A NAME="REF_2_3_4"></A>
            8.4. Завершающее управление исключениями
</div>
<p>
     Синтаксис определения завершающего управления исключениями:
<PRE><div class="code">
   __try {
      //
      // Операторы контролируемого блока
      //
   } __finally {
      //
      // Операторы блока обработки факта завершения
      // контролируемого блока
      //
      //
   }</div></PRE>
<p>Завершение контролируемого  блока может быть нормальным или преждевременно прерванным.
<UL>Причины досрочного выхода:
<LI>выполнение оператора return, goto, break или continue;
<LI>вызов функции, подобной longjump();
<LI>порождение исключения;
<LI>выполнение оператора выхода из контролируемого блока __leave;
</UL>
<p>Любой исход завершения  контролируемого  блока  безусловно приводит к гарантированному выполнению операторов блока finally. Очевидно,  что допускается совмещение кадрированного и завершающего управления исключениями.
    Пример демонстрационной программы:
<pre><div class="code">
   #include &lt;stdio.h&gt;
   void main() {
      puts("Начало программы");
      int *p = 0x00000000; // Пустой указатель !
      
      __try {
         puts("Начало блока контроля исключения");
         __try {
            puts("Начало блока контроля завершения");
            puts("Попытка нарушения защиты памяти...");
            *p = 13;
            puts("Продолжение работы");
         } __finally {
         puts("Блок завершения активен");
         }
         puts("Конец блока контроля исключения");
         }__except(puts("Фильтр активен"), 1) {
         puts("Исключение обработано");
         }
         puts("Завершение программы");
    }</div></pre>
     Результаты работы программы:
<PRE>
   Начало программы
   Начало блока контроля исключения
   Начало блока контроля завершения
   Попытка нарушения защиты памяти...
   Фильтр активен
   Блок завершения активен
   Исключение обработано
   Завершение программы
</PRE>
<a href="8_4.exe">Выполнить</a>
<p>В блоке __finally можно проверить состояние контролируемого блока - функция 
<PRE><div class="code">
   BOOL AbnormalTermination(VOID);
</div></PRE>
<p>возвращает истину, если контрольный блок завершен нормально. По соображениям эффективности кода в контролируемый блок не рекомедуется помещать операторы преждевременного выхода return, goto, break или continue.  
<P>
<div class="header"><A NAME="REF_2_3_5"></A>
           8.5. Иерархическое управление исключениями
</div>
<p>Производные классы  в языке C++ образуют основу определения сложных иерархий объектов, но функции, использующие такие объекты, не лишены возможности быть источниками исключений. Схема управления исключениями остается неизменной. Однако механизм динамической  связи  базовых и производных классов в языке C++ через указатели и/или ссылки открывает путь для  детализации  процесса обработки исключений.
     Пример демонстрационной программы:
<PRE><div class="code">
   #include &lt;iostream.h&gt;
   class TIO { // Буфер ввода вывода
   protected:
      int data;
   public:
      TIO():data(0) {}
      virtual void is_error() {
         cout&lt;&lt;endl&lt;&lt;"Какая-то ошибка ввода-вывода ????";
      }
   };

   class Read: public TIO { // Процесс ввода
   public:
      Read() {}
      void read() {
         cout&lt;&lt;endl&lt;&lt;"Значения данных -? ";
         cin&gt;&gt;data;
         if (!cin) throw *this;
      }
      virtual void is_error() {
         cout&lt;&lt;endl&lt;&lt "Ошибка ввода...";
      }
   };

   class Write: public Read { // Процесс ввода-вывода
   public:
      Write() {}
      void write() {
         cout&lt;&lt;endl&lt;&lt;"Значение элемента данных: "&lt;&lt;data;
         if (data&lt;0) throw *this;
      }

      virtual void is_error() {
         cout&lt;&lt;endl&lt;&lt "Некорректное значение данных";
      }
   };

   class Work: public Write { // Создание данных
   public:
      operator int() { return data!=0; }
      Work() {}
      virtual void is_error() {
         cout&lt;&lt;endl&lt;&lt "Ошибка создания данных";
      }
   };

   void main() {
      try {
         Work x;
         x.read();
         x.write();
         if (!x) throw x;
      } catch (TIO& ioerror) {
         ioerror.is_error();
      }
  }</div></PRE>
<p> Здесь в  контролируемом  блоке  выполняется несколько шагов преобразования данных,  сохраняемых в буфере - представителе базового класса TIO. Многочисленные исключения, порождаемые разными уровнями наследования производными  классами,  обрабатываются единственной ловушкой со ссылкой на класс TIO.  Однако виртуальная функция is_error(), определенная в каждом классе, будет вызвана в точном соответствии с причиной ошибки.
<P>
<div class="header"><A NAME="REF_2_3_6"></A>
             8.6. Особенности порождения исключений в конструкторах и деструкторах
</div>
<p> Отличительная черта  конструкторов и деструкторов - отсутствие возможности возврата значений, что создает определенные неудобства  для фиксации ошибки в процессе их явного либо неявного вызова. Выделение же в конструируемом объекте некоторого признака  ошибочного состояния либо громоздко,  либо принципиально невозможно.  Порождение исключений в рассматриваемых функциях-элементах  класса  - элегантный прием моделирования возврата значений.
     Пример демонстрационной программы:
<pre><div class="code">
   #include &lt;iostream.h&gt;
   class SomeClass {
      int variant; // Переключатель источника исключений
   public:
      SomeClass(int i);
      ~SomeClass();
      class ErrorClass { // Класс ошибок
      public:
         int ErrorCode; // Код ошибки
         ErrorClass(int error): ErrorCode(error) {
            cout&lt;&lt;endl&lt;&lt;"КОД ОШИБКИ: "&lt;&lt;ErrorCode;
         }
      };
   };
 
   // Версия конструктора с порождением исключений

   SomeClass::SomeClass(int i):variant(i) {
      //...
      if (variant&gt;0) throw ErrorClass(1);
      //...
   }

   // Версия деструктора с порождением исключений

   SomeClass::~SomeClass() {
      //...
      if (variant&lt;0) throw ErrorClass(2);
      //...
   }

   void main(void) {
      //...
      cout&lt;&lt;endl&lt;&lt;"Начало программы"&lt;&lt;endl;
      try {
         //...
         cout&lt;&lt;endl&lt;&lt;"Провоцирование исключения в конструкторе";
         SomeClass error_in_construct(1);
         cout&lt;&lt;endl&lt;&lt;"Объект \"error_in_construct\" создан...";
         //...
      } catch (SomeClass::ErrorClass)  {
            cout&lt;&lt;endl&lt;&lt;"Исключение в конструкторе обработано";
      }
      
      cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;"Продолжение программы"&lt;&lt;endl;

      try {
         //...
         cout&lt;&lt;endl&lt;&lt;"Провоцирование исключения в деструкторе";
         SomeClass error_in_destruct(-1);
         cout&lt;&lt;endl&lt;&lt;"Объект \"error_in_destruct\" создан...";
         //...
      } catch (SomeClass::ErrorClass Error_Object) {
            cout&lt;&lt;endl
                    &lt;&lt;"Исключение в деструкторе обработано"
                    &lt;&lt;endl
                    &lt;&lt;"Код исключения "&lt;&ltError_Object.ErrorCode&lt;&lt;" ???";
      }
      cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;"Завершение программы";
   }</div></pre>
     Результаты работы программы:
<PRE>
   Начало программы

   Провоцирование исключения в конструкторе
   КОД ОШИБКИ: 1
   Исключение в конструкторе обработано

   Продолжение программы

   Провоцирование исключения в деструкторе
   Объект "error_in_destruct" создан...
   КОД ОШИБКИ: 2
   Исключение в деструкторе обработано
   Код исключения 2 ???

   Завершение программы
</PRE>
<p>При порождении  исключений  в последней программе создается объект класса SomeClass::ErrorClass,  размещаемый в стековой памяти.  Так  как  здесь  в первом операторе catch такой объект не идентифицируется, то отображение ошибки реализуется лишь выводом сообщения  в  конструкторе класса SomeClass::ErrorClass.  Объект такого или подобного класса может быть использован для  передачи
детальной  информации о причине порождаемого исключения из конструктора и/или деструктора.
<p>
<div class="header"><A NAME="REF_2_3_7"></A>
             8.7. Спецификация исключений в функциях
</div>
<p>
Спецификацией исключений называется перечисление всех исключений при объявлении функции, которые она может выбросить.  Спецификации исключений   должны совпадать в определении и во всех объявлениях одной и той же функции.
<p>
<pre>
Синтаксис:

возвращаемый_тип имя_функции(список_параметров) throw (список_типов_исключений)
</pre>
<pre><div class="code">
void foo(void) throw(char*,int);
</div></pre>
<p>
Если список типов исключений пуст то это значит функция не выбрасывает никаких исключений. 
<pre><div class="code">
void foo(void) throw();
</div></pre>
<p>
Если в объявлении функции спецификация исключений отсутствует, то функция может выбросить исключение любого типа. 
Если функция выбрасывает исключение, тип которого не описан в спецификации исключений, то вызывается функция <b>void unexpected()</b> из стандартной библиотеки C++, которая вызывает в свою очередь функцию <b>terminate()</b>. Такие исключения называются неожидаемыми или непредусмотренными. Для обработки этих исключений можно установить "свой обработчик" при помощи функции <b>set_unexpected()</b> (описана в &lt;eh.h&gt;)
<p>
Спецификатор исключений можно также задавать при объявлении указателя на функцию.
<pre><div class="code">
void (*pf)(void) throw (int,double);
</div></pre>
<p>
Присваемое такому указателю значение должно указывать на функцию, которая может выбросить только исключения (возможно не все) из спецификации исключений в указателе.
<p>
<pre><div class="code">
void f() throw(int); 
pf=f;
</div></pre>
<p>
<div class="header"><A NAME="REF_2_3_8"></A>
8.8 Стандартные исключения
</div>
<p>
Некоторые функции из стандартных библиотек C++ выбрасывают исключения, которые могут быть обработаны. Эти исключения называются стандартными и описываются производными классами (наследниками) от класса: 
<p>
Std::exeption  <exeption>
<p>
Иерархия стандартных исключений:
<pre>

 Exeption                              кто выбрасывает      заголовок

|-bad_alloc                            new                          &lt;new&gt;
|-bad_cast                            dynamic_cast            &lt;typeinfo&gt;
|-bad_typeid                          typeid                       &lt;typeinfo&gt;	
|-bad_exeption                       нет catch                  &lt;exception&gt;
|-logic_error
|         |-domain_error             bitset                         &lt;stdexcept&gt;
|         |-invalid_argument
|         |-length_error
|         |-out_of_range
|-runtime_error
|         |-overflow_error            bitset                         &lt;stdexcept&gt;
|         |-range_error
|         |-inderflow_error
|-ios_base::failure_ios::clear	ios::clear	                    &lt;ios&gt;
</pre>
<p>
Так как это иерархия классов, то любое из этих исключений можно словить, включив обработчик класса exeption 
<pre><div class="code">
#include &lt;iostream&gt;
#include &lt;exeption&gt;
#include &lt;typeinfo&gt;

using namespace std;

class Demo
{
 virtual f() {};
};

int main()
{
 Demo* a=NULL;
 try
 {
  typeid(*a);
 }
 catch(exeption& e)
 {
  cout&lt;&lt;"exeption:"&lt;&lt;e.what()&lt;&lt;endl;
 }
 return 1;
}
</div></pre>
<P><HR WIDTH="100%" SIZE="1">
<a href="#REF_1_C">Начало</a>
<p>
<div class="header"><A NAME="REF_2_4"></A>
        9. ДИНАМИЧЕСКАЯ ИДЕНТИФИКАЦИЯ И ПРИВЕДЕНИЕ ТИПА
</div>
<div class="header"><A NAME="REF_2_4_1"></A>
             9.1. Динамическая идентификация типа
</div>
<p>Динамическая идентификация типа базируется на информации  о типе  во  время  исполнения программы (Runtime Type Information, RTTI).  Поддержка RTTI введена в С++ сравнительно недавно и реализована, например, в системах программирования Borland C++ 4.0, Microsoft Visual C++ 4.0 и их более поздних версиях.
     Основу механизма поддержки RTTI составляют:
<UL>
<LI>определенный в файле typeinfo.h класс Type_info;
<LI>специальная операция typeid, результат выполнения которой -
объект типа const Type_info &amp;.
</UL>
<p>Необходимый для понимания RTTI фрагмент определения класса
Type_info имеет вид:
<PRE><div class="code">
   class Type_info {
   public:
      virtual ~Type_info();
      int operator==(const Type_info &) const;
      int operator!=(const Type_info &) const;

      int before(const Type_info&) const;
      const char* name() const;
      const char* raw_name() const;
   private:
   // Запрет создания и копирования объектов пользователем
      Type_info(const Type_info &);
      Type_info& operator=(const Type_info &);
      //
      // Определение других элементов
      //
   };</div>
</PRE>
<p>Назначение неочевидных по определению элементов класса Type_info:
<DD>before - cравнение имен типов посредством посимвольного сопоставления;
<DD>name - имя типа в тексте программы;
<DD>raw_name - расширенное (декорированное) имя типа -  обычное имя типа дополнено системно зависимой информацией об особенностях типа.
<P>
     Синтаксис операции typeid:
<PRE><div class="code">
   typeid(имя_типа)
   typeid(выражение)
</div></PRE>
<p>Таким образом,  операция typeid применима как к  объекту  - результату  вычисления  выражения,  так и к идентификатору типа. Так как ее использование порождает определенные надстройки в коде объектного модуля программы, то поддержка RTTI обычно требует запроса соответствующего режима компиляции (ключ /GR в Microsoft Visual С++).
     Демонстрационный пример идентификации типов:
<pre><div class="code">
   #include &lt;iostream.h&gt;
   #include &lt;typeinfo.h&gt;
   class test { int data; /* ... */ };

   void main() {
      int  i, *pi=&i, &ri=i;
      test x, *px=&x, &rx=x;

      cout&lt;&lt;endl&lt;&lt;"  1. "&lt;&lt;typeid(i).name()
          &lt;&lt;endl&lt;&lt;"  2. "&lt;&lt;typeid(pi).name()
          &lt;&lt;endl&lt;&lt;"  3. "&lt;&lt;typeid(*pi).name()
          &lt;&lt;endl&lt;&lt;"  4. "&lt;&lt;typeid(ri).name()
          &lt;&lt;endl&lt;&lt;"  5. "&lt;&lt;typeid(int).name()
          &lt;&lt;endl&lt;&lt;"  6. "&lt;&lt;typeid(double *).name()
          &lt;&lt;endl&lt;&lt;"  7. "&lt;&lt;typeid(1997).name()
          &lt;&lt;endl&lt;&lt;"  8. "&lt;&lt;typeid(x).name()
          &lt;&lt;endl&lt;&lt;"  9. "&lt;&lt;typeid(*px).name()
          &lt;&lt;endl&lt;&lt;" 10. "&lt;&lt;typeid(rx).name()
          &lt;&lt;endl&lt;&lt;" 11. "&lt;&lt;typeid(test).name();
   }</div></pre>
     Результаты работы программы:
<PRE>
   1. int
   2. int *
   3. int
   4. int
   5. int
   6. double *
   7. int
   8. class test
   9. class test
  10. class test
  11. class test
</PRE>
<a href="9_1.exe">Выполнить</a>
<p>Можно заметить,  что  правила  формирования имени типа для базовых типов и классов различаются.  Действительная полезность RTTI проявляется для  <STRONG>полиморфных</STRONG> типов, т.е. классов с виртуальными функциями. Для таких типов указатели и ссылки существенно определяют выбор наследуемых  <STRONG>производными</STRONG> классами функций. Однако значение указателя не содержит информацию о типе реально существующего объекта. Подобная информация, как результат операции typeid, часто оказывается весьма полезной при программировании на основе иерархии производных классов.
<p>Пример программы выявления и сравнения типов объектов во время исполнения программы:
<pre><div class="code">
   #include &lt;iostream.h&gt;
   #include &lt;typeinfo.h&gt;
   // Базовый класс без виртуальных функций
   class C1_base {
      int data_b;
   public:
      // ...
   };

   // Производный класс без переопределения виртуальных функций
   class C1_derived: public C1_base {
      int data_d;
   public:
      // ...
   };

   // Базовый класс c виртуальными функциями (полиморфный класс)
   class C2_base {
      int data_b;
   public:
      virtual ~C2_base() {}
      // ...
   };

   // Производный класс с переопределением виртуальных функций
   class C2_derived: public C2_base {
      int data_d;
   public:
      // ...
   };

   void main(void) {
      C1_derived d1; // Объект производного класса
      C1_base &br1=d1; // Ссылка на объект производного класса
      cout&lt;&lt;typeid(br1).name()&lt;&lt;endl
          &lt;&lt;typeid(C1_base).name()&lt;&lt;endl
          &lt;&lt;typeid(C1_derived).name()
          &lt;&lt;endl;
      cout&lt;&lt;"typeid(br1) "
          &lt;&lt;(typeid(br1)==typeid(C1_base)? "==":"!=")
          &lt;&lt;" typeid(C1_base)"
          &lt;&lt;endl;
      cout&lt;&lt;"typeid(br1) "
          &lt;&lt;(typeid(br1)==typeid(C1_derived)? "==":"!=")
          &lt;&lt;" typeid(C1_derived)"
          &lt;&lt;endl;
      C2_derived d2; // Объект производного класса
      C2_base &br2=d2; // Ссылка на объект производного класса
      cout&lt;&lt;endl&lt;&lt;typeid(br2).name()&lt;&lt;endl
          &lt;&lt;typeid(C2_base).name()&lt;&lt;endl
          &lt;&lt;typeid(C2_derived).name()
          &lt;&lt;endl;
      cout&lt;&lt;"typeid(br2) "
          &lt;&lt;(typeid(br2)==typeid(C2_base)? "==":"!=")
          &lt;&lt;" typeid(C2_base)"
          &lt;&lt;endl;
      cout&lt;&lt;"typeid(br2) "
          &lt;&lt;(typeid(br2)==typeid(C2_derived)? "==":"!=")
          &lt;&lt;" typeid(C2_derived)"
          &lt;&lt;endl;
   }</div></pre>
     Результаты работы программы:
<PRE>
   class C1_base
   class C1_base
   class C1_derived
   typeid(br1) == typeid(C1_base)
   typeid(br1) != typeid(C1_derived)
 
   class C2_derived
   class C2_base
   class C2_derived
   typeid(br2) != typeid(C2_base)
   typeid(br2) == typeid(C2_derived)
</PRE>
<p> Очевидно различие в результатах операции typeid  в  зависимости  от  наличия виртуальных функций в базовых классах.  Здесь класс C1_base не является полиморфным и ссылка на него (br1) соответствует имени его типа.  Класс C2_base является полиморфным, а ссылка на него (br2)  через  производный  класс  соответствует имени типа использованного для инициализации ссылки объекта производного класса.
     Операция typeid для полиморфных классов может применяться как альтернатива виртуальным функциям:
<PRE><div class="code">
   #include &lt;typeinfo.h&gt;
   class Base {
      //...
   public:
      virtual ~Base() {} // Полиморфный класс
   };

   class Derive_1: public Base {
   public:
      void action() { /* ... */ }
   };
   class Derive_2: public Base {
   public:
      void action() { /* ... */ }
   };
   class Derive_N: public Base {
   public:
      void action() { /* ... */ }
   };

   void selector(Base *pobj) {
      //...
      Type_info &obj_type=typeid(pobj);
      if (obj_type==typeid(Derive_1))
         ((Derive_1 *)pobj)-&gt;action();
      else if (obj_type==typeid(Derive_2)) action_2();
         ((Derive_2 *)pobj)-&gt;action();
      //...
      else if (obj_type==typeid(Derive_N)) action_N();
         ((Derive_N *)pobj)-&gt;action();

      //...
   }</div>
</PRE>
<p>Однако использование механизма позднего связывания виртуальных функций более элегантно и эффективно в вычислительном отношении:
<PRE><div class="code">
   #include &lt;typeinfo.h&gt;
  class Base {
      //...
  public:
     virtual ~Base() {} // Полиморфный класс
     virtual void action() {} // Переопределяемая виртуальная
                              // функция может быть строго
                              // виртуальной
   };

   class Derive_1: public Base {
   public:
      virtual void action() { /* ... */ }
   };
   class Derive_2: public Base {
   public:
      virtual void action() { /* ... */ }
   };
   //...
   class Derive_N: public Base {
   public:
      virtual void action() { /* ... */ }
   };

   void selector(Base *pobj) {
      //...
      pobj-&gt;action(); // Автоматическая классификация возможна
                      // из-за наличия виртуальной функции
                      // action в базовом классе
      //...
   }</div>
</PRE>
<p>Очевидно, что  классификация  функций на основе обращения к операции typeid вместо виртуальных функций удобна в случаях  невозможности либо нежелания модификации базового класса.
     Использование операции typeid часто можно исключить, применяя вместо этого динамическое приведение типа <A HREF="#REF_2_4_3">(смотри 4.3)</A>.
<P>
<div class="header"><A NAME="REF_2_4_2"></A>
         9.2. Обзор новых возможностей приведения типа
</div>
<p>Традиционное приведение типа в языках C и C++ страдает следующими существенными недостатками:

<UL>
<LI><p>разрешение программисту производить не контролируемые компилятором преобразования типов,  которые могут породить ошибку на этапе выполнения программы;
<LI><P>синтаксис традиционных операций приведения типа не отражает действительные намерения программиста;
<LI><p>указатель на базовый класс не может быть явно  преобразован в указатель на производный класс, в котором базовый класс объявлен виртуальным.
</UL>
<PRE><div class="code">
   // Некорректные последствия преобразования типов
   int *pvi=new int[512];
   //...
   const int *pci=pvi;
   //...
   delete[] (int *)pci; // Подавление сообщения об ошибке
   // Недопустимость преобразования указателей
   class Base {};
   class D1: public virtual Base {};
   class D2: public virtual Base {};
   class D12: public D1, public D2 {};
   void f(Base *pb) {
      D12* dp=(D12 *)pb; // Подавление сообщения об ошибке
      //...
   }

   void main() {
      //...
      D12 d_object;
      //...
      f(&d_object);
      //...
   }</div>
</PRE>
<p>Новые возможности приведения типа устраняют  указанные  недостатки путем использования:
<UL>
<LI><P>однозначно интерпретируемого синтаксиса операций;
<LI><P>контроля ошибок как на этапе компиляции, так и этапе выполнения программы;
<LI><p>разрешения преобразования указателей на базовый виртуальный класс  в  указатели  на  наследующий его производный класс.
</UL>
<P>
<div class="header"><A NAME="REF_2_4_3"></A>
               9.3. Динамическое приведение типа
</div>
<p>
     Динамическое приведение  типа  опирается на механизм RTTI и позволяет автоматизировать контроль корректности  преобразования указателей  и  ссылок  на объекты полиморфных классов без явного применения операции typeid.
     Синтаксис операции динамического приведения типа:
<PRE><div class="code">
   dynamic_cast&lt;type&gt;(expression)
</div></PRE>
<p>Здесь type - тип, а expression - выражение, подлежащее преобразованию к типу type, удовлетворяющие следующим требованиям:
<UL>
<LI><p>type должен определять указатель либо ссылку (допустимо использование типа void *);
<LI><p>преобразуемое выражение expression должно быть  указателем, если type - указатель;  в противном случае expression может быть только ссылкой.
</UL>
<p>Результат успешно выполненной  операции  dynamic_cast&lt;type&gt; имеет тип type. Неудача преобразования проявляется в зависимости от вида модификатора в определении типа type:
<UL>
<LI>возврат нулевого указателя, если type - указатель;
<LI>порождение исключения bad_cast, если type - ссылка.
</UL>
<p> Класс bad_cast определен в файле typeinfo.h в следующем
виде:
<PRE><div class="code">
   typedef const char *__exString;
   class  exception {
   public:
      exception();
      exception(const __exString&);
      exception(const exception&);
      exception& operator=(const exception&);
      virtual ~exception();
      virtual __exString what() const;
   private:
      __exString _m_what;
      int _m_doFree;
   };

   class bad_cast: public exception {
   public:
      bad_cast(const __exString& what_arg):exception(what_arg) {}
   };</div>
</PRE>
<p>Наследуемая из  базового  класса  exception функция-элемент what() возвращает строку комментария причины исключения.
     Пример программы нисходящего приведения типа:
<pre><div class="code">
   #include &lt;iostream.h&gt;
   #include &lt;eh.h&gt;
   #include &lt;typeinfo.h&gt;
   class A {
   public: 
      virtual ~A() {}
   };

   class B: public A {};

   class B1: virtual public A {};
   class B2: virtual public A {};

   class C: public B1, public B2 {};

   void f1(A *pa) { // Приведение ссылки
      try {
         cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;"R-test: ";
         B& rb=dynamic_cast&lt;B&amp;&gt;(*pa);
         cout&lt;&lt;"OK";
      } catch (bad_cast &x) {
          cout&lt;&lt;x.what();
      }
   }

   void f2(A *pa) { // Приведение указателя
      try {
         cout&lt;&lt;endl&lt;&lt;"P-test: ";
         B* pb=dynamic_cast&lt;B *&gt;(pa);
         if (!pb) throw "Bad cast";
         cout&lt;&lt;"OK";
      } catch (char *msg) {
           cout&lt;&lt;msg;
      }
   }

   void f3(A *pa) { // Приведение указателя
      try {
         cout&lt;&lt;endl&lt;&lt;"P-test: ";
         C* pb=dynamic_cast&lt;C *&gt;(pa);
         if (!pb) throw "Bad cast";
         cout&lt;&lt;"OK";
      } catch(char *msg) {
          cout&lt;&lt;msg;
      }
   }

   void main() {
      A* pa=new A; // Указатель на объект базового класса

      f1(pa);      // Преобразование в объект производного
      f2(pa);      // класса должно быть запрещено...
      delete pa;
      pa=new B;   // Указатель на объект базового класса в
                  // объекте производного класса

      f1(pa);     // Преобразование в объект производного
      f2(pa);     // класса должно быть разрешено...
      delete pa;

      pa=new C;   // Указатель на объект базового класса в
                  // объекте производного класса

      f1(pa);     // Преобразование в объект производного
      f2(pa);     // класса должно быть разрешено...
      f3(pa);     // Преобразование в объект производного
                  // класса должно быть разрешено...
      delete pa;
   }</div></pre>
     Результаты работы программы:
<PRE>
   R-test: Bad dynamic_cast!
   P-test: Bad cast

   R-test: OK
   P-test: OK
 
   R-test: Bad dynamic_cast!
   P-test: Bad cast
   P-test: OK
</PRE>
<p>Здесь продемонстрировано  и нисходящее приведение типа виртуального базового класса.
<p> Одно из полезных применений операции dynamic_cast - так называемое  перекрестное  приведение  типа,  позволяющее безопасно связывать классы, созданные в разные моменты времени:
<pre><div class="code">
   #include &lt;iostream.h&gt;
   class my_out {
   public:
      virtual ~my_out() {}
      void output(char *s) { cout&lt;&lt;endl&lt;&lt;s; }
   };

   class Complex{
   protected:
      int re, im;
   public:
      Complex(int r=0, int i=0):re(r), im(i) {}
      friend ostream & operator&lt;&lt(ostream &out,Complex &x);
      virtual ~Complex() {}
   };
   //
   //  Переопределение операции вывода основано на несвязанных до
   //  этого момента классах Complex и my_out
   //
   ostream & operator&lt;&lt(ostream &out,Complex &x) {
      my_out *px=dynamic_cast&lt;my_out *&gt;(&x);
      if (px) px-&gt;output("Class Complex: ");
      out&lt;&lt;"re="&lt;&lt;x.re&lt;&lt;", im="&lt;&lt;x.im;
      return out;
   }
   //
   //  Варианты связей классов Complex и my_out
   //
   class test_1: public Complex, public my_out { // Вариант 1
   public:
      test_1(int r=0, int i=0):Complex(r,i) {}
   };

   class test_2: public my_out { };
     
   class test_3: public Complex, public test_2 { // Вариант 2
   public:
      test_3(int r=0, int i=0):Complex(r,i) {}
   };

   void main() {
      cout&lt;&lt;Complex(1,2);
      cout&lt;&lt;test_1(3,4);
      cout&lt;&lt;test_3(5,6);
   }</div></pre>
     Результаты работы программы:
<PRE>
   re=1, im=2
   Class Complex: re=3, im=4
   Class Complex: re=5, im=6
</PRE>
<p> Подобно ранее рассмотренному примеру использования операции typeid,  операция dinamic_cast позволила отказаться от модификации базового класса.
<P>
<div class="header"><A NAME="REF_2_4_4"></A>
               9.4. Статическое приведение типа
</div>
<p>Ранее рассмотренное динамическое приведение  типа  действительно полезно для полиморфных типов,  но в других случаях может быть заменено более точно отражающим существо задачи статическим приведением.
     Реализующая статическое приведение новая в языке С++ операция 
<PRE><div class="code">
   static_cast&lt;идентификатор_типа&gt;(выражение) 
</div></PRE>
<p>преобразует выражение к заданному типу на этапе компиляции. Статическое приведение  типа не предполагает проверку безопасности преобразования
на этапе исполнения.
     Примеры использования операции static_cast:
<PRE><div class="code">
   int i;
   long l=static_cast&lt;long&gt;(i);

   float f=static_cast&lt;float&gt;(i);

   enum set {One, Two, Tree, Four,Five} estim;

   char c=static_cast&lt;char&gt;(estim);

   Base *pb=static_cast&lt;Base *&gt;(&amp;d);

   Derived &amp;dr=static_cast&lt;Derived &amp;&gt;(b);
</div></PRE>
<p>Статическое приведение типа по последствиям аналогично традиционному приведению типа, но использование синтаксиса операции static_cast  означает  отказ от использования RTTI и,  что более важно, отражает явно намерения программиста.
     Преобразования указателей и ссылок на объекты иерархии производных классов рекомендуется  выполнять  посредством  операции dynamic_cast, которая более надежна и универсальна. Для безопасных вариантов ее реализация полностью  совпадает  с  реализацией операции static_cast.
<P>
<div class="header"><A NAME="REF_2_4_5"></A>
           9.5. Преобразования типа с сохранением значений
</div>
<p> Для пояснения намерений программиста,  кроме  рассмотренных выше, в языке C++ существуют другие виды операций преобразования типа:
<PRE><div class="code">
   const_cast&lt;идентификатор_типа&gt; (выражение) -  игнорирование
              атрибутов const, volatile или __unaligned заданного выражения; 
   reinterpret_cast&lt;идентификатор_типа&gt; (выражение)  - изменение
              точки зрения компилятора на тип объекта без модификации объекта.
</div></PRE>
<p>Результат этих  операций - преобразованное к заданному типу значение указанного выражения.
     Пример использования операции const_cast:
<PRE><div class="code">
   int *ipv=new int[100];
   //...
   const int *ipc=ipv;
   //...
   delete[] const_cast&lt;int *&gt;(ipc);
</div></PRE>
<p> Последний оператор при традиционном приведении типа в форме
<PRE><div class="code">
   delete[] (int *)(ipc);
</div></PRE>
<p>не отражал бы действительную сущность преобразования.
     Пример использования операции reinterpret_cast:
<PRE><div class="code">
   unsigned long dwData=0x01020304L;
   //...
   char *pointer;
   //...
   dwData=reinterpret_cast&lt;unsigned long&gt;(pointer);
   //...
   pointer=reinterpret_cast&lt;char *&gt;(dwData);
</div></PRE>
<p>Ответственность программиста за корректность преобразования при этом не снимается:
<PRE><div class="code">
   class Base {} base_object;

   class Derived: public Base {};

   Derived *pd=reinterpret_cast&lt;Derived *&gt;(&amp;base_object);
</div></PRE>
<p>Последний оператор  не будет считаться синтаксически неверным,  но использование результата преобразования далее наверняка приведет к нежелательному исходу.  Однако намерение программиста зафиксировано явно, что облегчает поиск ошибок.
<P>
<P><HR WIDTH="100%" SIZE="1">
<a href="#REF_1_C">Начало</a>
<p>
<div class="header"><A NAME="REF_2_Z"></A>
                           ЗАКЛЮЧЕНИЕ
</div>
<p>Язык С++  считается  одним из сложнейших для изучения и использования [4]. Хотя набор синтаксических конструкций, расширяющий язык C, незначителен, трудность заключается в том, что язык С++ ориентирован на совершенно отличную от технологии  структурно-организованного процедурного программирования технологию объектно-ориентированного программирования. Идеология объектно-ориентированного проектирования программ - отдельный вопрос, требующий самостоятельного изучения [2].  Строго говоря, язык С++ для объектно-ориентированного стиля программирования не является идеальным, но его популярность объясняется наследованной от языка C чрезвычайной  гибкостью  и  мобильностью.  Трудности же освоения языка для его профессионального использования, естественно, приходится преодолевать.
     Рассмотренный в  настоящем пособии материал отражает основные концепции построения и возможности  новых  языковых  средств систем программирования на языке С++.  Следует отметить,  что их реализация в разных системах программирования отличается некоторыми деталями.
     В популярных  в  последнее  время системах программирования Borland C++ версий 4.5 и 5.0,  Microsoft C++ версий 4.0-4.2 поддерживаются все упомянутые в представленном пособии возможности.
Механизм шаблонов уже был реализован в Borland C++ версии 3.1, а в настоящее время широко используется в библиотеках классов. Обработка исключений, динамическая идентификация типа и новые формы операций приведения типа интенсивно применяются в библиотеках Microsoft Foundation Class (MFC) [7,8].
     Язык С++ к настоящему времени продолжает развитие [1,2-4]. В современных системах программирования на языке С++ доминирует тенденция использования дружественных интегрированных сред разработки программ. Детальные сведения об элементах языка, особенностях реализации можно получить, пользуясь средствами оперативной подсказки. Однако необходимый начальный набор базовых сведений требуется накопить, изучив представленное пособие и/или упомянутые литературные источники.
<P><HR WIDTH="100%" SIZE="1">
<a href="#REF_1_C">Начало</a>
<p>
<div class="header"><A NAME="REF_2_R"></A>
                           ЛИТЕРАТУРА
</div>
<p>
     Представленный ниже список содержит перечень русскоязычных
источников, использованных при написании данного пособия c момента выхода первой части пособия [5].
<OL>
<LI><P>Биллинг В.А.,  Мусикаев И.Х.  Visual C++ 4. Книга для программистов. - М.: Изд. отдел "Русская редакция" ТОО "Channel Trading Ltd", 1996. - 352 c.
<LI><P>Бруно Бабэ. Просто и ясно о Borland C++: Пер. с англ. -
М.: БИНОМ, 1995. - 400 с.
<LI><P>Буч Г. Обьектно-ориентированное проектирование с примерами
применения: Пер с англ. - М.: Конкорд, 1992. - 519 с.
<LI><P>Голуб А.И. C и C++. Правила программирования. - М.: БИНОМ,
1995. - 272 с.
<LI><P>Ревотюк М.П. Объектно-ориентированное программирование
на языке C++. Ч.1. Переход от языка C к языку C++: Учеб.пособие.-
Мн.: БГУИР, 1994. - 160 с.
<LI><P>От C к C++/Е.И.Козел, Л.М.Романовская, Т.В.Русс и др. -
М.: Финансы и статистика, 1993. - 272 с.
<LI><P>Фролов А.В., Фролов Г.В. Microsoft Visual C++ и MFC.
Программирование для Windows 95 и Windows NT. - М.: ДИАЛОГ-МИФИ,
1996. - 288 с.
<LI><P>Фролов  А.В., Фролов Г.В. Microsoft Visual C++ и MFC. Ч.2.
Программирование для Windows 95 и Windows NT. - М.: ДИАЛОГ-МИФИ,
1997. - 272 с.
<LI><P>Эллис М., Строуструп Б. Справочное руководство по языку
программирования С++ с комментариями: Пер с англ. - М.: Мир,
1992. - 445 с.
<LI><P>Строуструп Б. Язык программирования С++, 3-е изд./Пер с англ. - СПб.; М.: "Невский диалект" - "Издательство БИНОМ", 1999. - 991 с.
<LI>С++: Язык программирования. М.: ИВК-СОФТ, 1991. - 315 с.
<LI>Скляров В.А. Программное и лингвистическое обеспечение
персональных ЭВМ: Новые системы: Справ. пособие. - Мн.:Выш. шк.,
1992. - 334 с.
<LI>Касаткин А.И.,  Вальвачев А.Н. Профессиональное программирование на языке Си: От Turbo-C к Borland C++: Справ. пособие;
Под общ. ред. Касаткина А.И. - Мн.: Вышэйшая школа, 1992. -240 с.
<LI>Рассохин Д.Н. От Си к Си++. Часть 1. Новые возможности
Си++, не связанные с ООП. - Мир ПК, 6/92. - С. 120-129.
<LI>Рассохин Д.Н. От Си к Си++. Часть 2. Основы объектно-ориентированного программирования. - Мир  ПК, 7/92. - С. 116-128.
<LI>Рассохин Д.Н. От Си к Си++. Часть 2. Основы объектно-
ориентированного программирования. - Мир ПК, 8/92. - С. 115-129.
<LI>Неформальное введение в С++ и Turbo Vision. Галерея
"Петрополь", 1992. - 381 с.
<LI>Романов В.Ю. Программирование на языке С++. М.: Компьютер, 1993. - 160 с.
</OL>
</p>
</body>
</p>
</html>



 C++ Language Reference   

Template SpecificationsSee Also
Templates | C++ Keywords
The template declaration specifies a set of parameterized classes or functions.

Grammar 

template-declaration : 
template < template-argument-list > declaration 
template-argument-list : 
template-argument
template-argument-list , template-argument 
template-argument : 
type-argument
argument-declaration 
type-argument : 
class identifier
typename identifier 
The template declaration specifies a set of parameterized classes or functions.

The template-argument-list is a comma-separated list of types (in the form class identifier, typename identifier, or template type) or a non-type to be used in the template body. The declaration field must be a declaration of a function or class.

You can instantiate a class template much like you would instantiate a normal class, but you must include the template arguments within angle brackets. No special syntax is required to call a function template.

With function templates, each template-argument must appear at least once in the template-argument-list of the function being declared.

The template-argument-list is a list of arguments used by the template function that specifies which parts of the following code will vary. For example:

template< class T, int i > class MyStack...
In this case the template can receive a type (class T) and a constant parameter (int i). The template will use type T and the constant integer i upon construction. Within the body of the MyStack declaration, you must refer to the T identifier.

Examples

// template_specifications1.cpp
template <class T, int i> class TestClass {
public:
   char buffer[i];
   T testFunc(T* p1 );
};

template <class T, int i>
T TestClass<T,i>::testFunc(T* p1) {
    return *(p1++)
};

// To create an instance of TestClass
TestClass<char, 5> ClassInst;
int main()
{
}
The following example shows how to pass a parameter to a template:

// template_specifications2.cpp
template<typename T>
class X
{
};

template<template<typename U> class T1, typename T2>
class Y
{
};

Y<X, int> aY;

int main()
{
}
The typename keyword can be used in the template-argument-list. The following template declarations are identical:

template< class T1, class T2 > class X...
template< typename T1, typename T2 > class X...
Template arguments of the following form are allowed:

template<typename Type> class allocator {};
template<typename Type, 
   typename Allocator = allocator<Type> > class stack {
};
stack<int> MyStack;
Visual C++ supports the reuse of template parameters in the template parameter list. For example, the following code is now legal:

// template_specifications3.cpp
class Y {
};
template<class T, T* pT> class X1 {
};
template<class T1, class T2 = T1> class X2 {
};

Y aY;

X1<Y, &aY> x1;
X2<int> x2;

int main()
{
}
A template declaration itself does not generate code; it specifies a family of classes or functions, one or more of which will be generated when referenced by other code. 

Template declarations have global or namespace scope.

Visual C++ performs syntax checking of template definitions. Visual C++ 5.0 and later can detect errors that previous versions cannot. The compiler can now detect syntax errors of templates that are defined but never instantiated. 

Here is a list of common errors which could compile with the Visual C++ 4.0 compiler, but not with Visual C++ 5.0 or later: 

A user-defined type is used in a template declaration before it is declared, but it is declared before the first instantiation or use of the template. For example: 
template<class T> class X {
   //...
   Data m_data;   // Error Visual C++ 5.0 or later, Data not defined
};

class Data {
};

void g() { X<int> x1; }
Move the declaration of Data before the class template X to fix this problem. 

A member function is declared outside a class template, whereas it is never declared inside the class. For example: 
template<class T> class X {
   //no mf declared here
};

//This definition did not cause an error with Visual 
//C++ 4.0, but it will cause an error with Visual 
//C++ 5.0 or later
//
template<class T> void X<T>::mf() {...};
A class identifier is considered to be a normal class unless declared to be a class template. For example, the following code generates an error with Visual C++ 5.0 or later but not with Visual C++ 4.0: 
template<class T> class X {
   friend class Y<T>;   //Parsed as Y 'less-than' //T 'greater-than';
   Z<T> mf( );            //Parsed as Z 'less-than' T 'greater-than';
};

template<class T> class Y {...};
template<class T> class Z {...};

X<int> x;
To fix the problem, forward declare Y and Z before the definition of X.

template<class T> class Y {...};
template<class T> class Z {...};

template<class T> class X {...};
In Visual C++ .NET, it is now possible to use template parameters:

// template_specifications4.cpp
#include <stdio.h>
template <class T> struct str1 {
   T t;
};

template <template<class A> class T> struct str2 {
   T<int> t;
};

int main() {
   str2<str1> mystr2;
   mystr2.t.t = 5;
   printf("%d\n", mystr2.t.t);
}
Output
5
See Also
Templates | C++ Keywords



--------------------------------------------------------------------------------

Send feedback on this topic to Microsoft

© Microsoft Corporation. All rights reserved.
