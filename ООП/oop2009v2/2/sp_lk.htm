<html>
<head>
<title>Конспект лекций "СИСТЕМНОЕ ПРОГРАММИРОВАНИЕ"</title>
<link href=style.css rel=stylesheet type=text/css>
</head>
<body>
<div class="header"><center>
		<P>Министерство образования Республики Беларусь<p> 
Учреждение образования<br>
		БЕЛОРУССКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ<br> 
		ИНФОРМАТИКИ И РАДИОЭЛЕКТРОНИКИ<br> 
		<P>Кафедра информационных технологий автоматизированных систем 
		<P>
		<P>М.П.Ревотюк 
</center></div><br>
<div class="title">
		<P>
		<P>
		<P>
		<P>
		<P>
		<P>&nbsp;</P>
		<P><font color = "#004D77">СИСТЕМНОЕ ПРОГРАММИРОВАНИЕ
		<P>
</font></div>
<p>
<P>
<P>
<P>&nbsp;</P>
<div class="header"><center>Конспект лекций<BR>для студентов специальности 
I-53 01 02<BR>&quot;Автоматизированные системы обработки информации&quot;<BR>
<P>
<P>
<P>
<P>
<P>
<P>
<P>&nbsp;</P>
<P>
<P>Минск 1999 
</center></div>
<P>
<HR SIZE=1 width="100%">
</p>
<P>
<P>
<P><font color = "#004D77">
УДК 681.3.06 
<P alight ="justify">Ревотюк М.П. Системное программирование. Ч.1: 
Язык системного программирования C: Конспект лекций для студентов специальности 
Т.10.01.00 &quot;Автоматизированные системы обработки информации&quot; В 2-х ч. - Мн.: 
БГУИР, 1999. - 96 с. ISBN 985-444-004-4 (ч.1). Табл. 1, список лит. - 22 назв.


<p>Ревотюк М.П. Системное программирование. Ч.2: Применение языка программирования C: Конспект лекций для студентов специальности Т.10.01.00 "Автоматизированные системы обработки информации". В 2-х ч. - Мн.: БГУИР, 1999. - 99 с. ISBN 985-444-113-Х (ч.2). 


<P align="justify">Курс &quot;Системное программирование&quot; 
базируется на материале курсов &quot;Программирование&quot; и &quot;Операционные системы&quot;. 
Предполагается наличие знаний и умений практической алгоритмизации прикладных 
задач, знакомство с методами организации вычислительных процессов в современных 
операционных системах, технологией подготовки программ в интегрированных и 
пакетных средах систем программирования. В первой части предлагаемого конспекта 
лекций рассматривается один из основных рабочих языков системного программиста - 
язык программирования С. Приемы и примеры решения задач системного 
программирования будут изложены во второй части конспекта. Конспект не 
претендует на замену учебника. Изучение курса наряду с обращением к 
рекомендуемой литературе требует и практической работы в рамках лабораторного 
практикума и курсовой работы.</P>
<P align="justify">Предназнается для студентов специальности 
&quot;Автоматизированные системы обработки информации&quot; всех форм обучения для 
подготовки к лекциям, практическим занятиям и самостоятельной работы по курсам 
&quot;Системное программирование&quot; и &quot;Объектно-ориентированное 
программирование&quot;.
<P align="justify">Рецензент - зав.кафедрой робототехнических систем БГПА, канд. техн. наук, 
доцент Плюгачев К.В. 
<P>
<P>
<P>
<P>C М.П.Ревотюк, 1999</P>
</font>
<P>
<P>
<P>
<hr width = 100% size="1">
<CENTER>
<div class="title"><A name="REF_1_C"></A>СОДЕРЖАНИЕ 
</div></CENTER>
<P>
<DL>
  <p align="justify">
  <div class="header">
  	<DT><A href="#REF_0">ВВЕДЕНИЕ</A>
  </div>	 
 <p>&nbsp;</P>
   	<div class="header"><A href="#REF_1">1. ОБЗОР ЯЗЫКА 
  ПРОГРАММИРОВАНИЯ C</A> 
  </div>
  <P>
 	 <DD>
 <div class="header">1.1. <A href="#REF_1_1">Характеристика 
  языка С</A></div>
     	 <DD>
  <div class="header">1.2. <A href="#REF_1_2">Основные сведения 
  о синтаксисе языка C</A></div>
       <DD>
  <div class="header">1.3. <A href="#REF_1_3">Структура программ 
  на языке С</A></div> 
  	 <DD>
  	<div class="header">1.4. <A href="#REF_1_4">Функции и 
  библиотеки функций языка С</A></div>
  <P align="justify">&nbsp;</P>
  
  <DT><div class="header"><A href="#REF_2">2. ДЕКЛАРАЦИЯ ОБЪЕКТОВ 
  ПРОГРАММЫ НА ЯЗЫКЕ С</A>
  </div> 
  <P>
  	<DD>
	<P>
	<div class="header">2.1. <A href="#REF_2_1">Операционные 
  объекты в языке C</A></div> 
  	<DD>
	<div class="header">2.2. <A href="#REF_2_2">Понятие типа 
  объекта в языке С</A></div> 
  	<DD>
	<div class="header">2.3. <A href="#REF_2_3">Базовые типы 
  данных в языке С</A></div> 
  	<DD>
	<div class="header">2.4. <A href="#REF_2_4">Массивы в языке 
  С</A></div> 
  	<DD>
	<div class="header">2.5. <A href="#REF_2_5">Структуры и 
  объединения в языке C</A></div> 
  	<DD>
	<div class="header">2.6. <A href="#REF_2_6">Перечисления</A></div> 
  	<DD>
	<div class="header">2.7. <A href="#REF_2_7">Оператор 
  переопределения типа</A></div> 
  	<DD>
	<div class="header">2.8. <A href="#REF_2_8">Константы в 
  программах на языке C</A></div> 
  <P>&nbsp;</P>
 
	<DT><div class="header"><A href="#REF_3">3. ОПЕРАТОРЫ И 
  ВЫРАЖЕНИЯ</A>
  </div> 
  <P>
  <DD>
	<P>
	<div class="header">3.1. <A href="#REF_3_1">Обзор операций 
  языка С</A></div> 
  <DD>
	<div class="header">3.2. <A href="#REF_3_2">Операции 
  присваивания</A></div> 
  <DD>
	<div class="header">3.3. <A href="#REF_3_3">Арифметические 
  операции</A></div> 
  <DD>
	<div class="header">3.4. <A href="#REF_3_4">Операции 
  отношений</A></div> 
  <DD>
	<div class="header">3.5. <A href="#REF_3_5">Логические 
  операции</A></div> 
  <DD>
	<div class="header">3.6. <A href="#REF_3_6">Операции над 
  битами</A></div> 
  <DD>
	<div class="header">3.7. <A href="#REF_3_7">Условное 
  вычисление</A></div>
  <DD>
	<div class="header">3.8. <A href="#REF_3_8">Определение 
  размера объекта</A></div> 
  <DD>
	<div class="header">3.9. <A href="#REF_3_9">Операция 
  приведения типа</A></div> 
  <DD>
	<div class="header">3.10. <A href="#REF_3_10">Последовательное 
  вычисление выражений</A></div> 
  <DD>
	<div class="header">3.11. <A href="#REF_3_11">Операции над 
  указателями</A></div> 
  <DD>
	<div class="header">3.12. <A href="#REF_3_12">Операция вызова 
  функции</A></div> 
  <DD>
	<div class="header">3.13. <A href="#REF_3_13">Приоритет и 
  порядок выполнения операций</A></div> 
  <P>&nbsp;</P>
	  <DT><div class="header"><A href="#REF_4">4. УПРАВЛЯЮЩИЕ 
  ОПЕРАТОРЫ</A>
  </div> 
  <P>
  <DD>
	<div class="header">4.1. <A href="#REF_4_1">Условные 
  операторы</A></div> 
  <DD>
	<div class="header">4.2. <A href="#REF_4_2">Операторы 
  цикла</A></div> 
  <DD>
	<div class="header">4.3. <A href="#REF_4_3">Оператор выбора 
  альтернатив (переключатель)</A></div> 
  <DD>
	<div class="header">4.4. <A href="#REF_4_4">Операторы передачи 
  управления</A></div> 
  <P>&nbsp;</P>
  
  <DT><div class="header"><A href="#REF_5">5. СТРУКТУРИЗАЦИЯ 
  ПРОГРАММ И ДАННЫХ</A> 
  <P>
  <DD>
  <div class="header">5.1. <A href="#REF_5_1">Области действия 
  объектов программ</A></div> 
  <DD>
	<div class="header">5.2. <A href="#REF_5_2">Классы памяти 
  объектов программ</A></div> 
  <DD>
	<div class="header">5.3. <A href="#REF_5_3">Инициализации 
  объектов программ</A></div> 
  <DD>
	<div class="header">5.4. <A href="#REF_5_4">Управляемая 
  память</A></div> 
  <P>&nbsp;</P>
  
  <DT><div class="header"><A href="#REF_6">6. ПРЕПРОЦЕССОР ЯЗЫКА 
  C</A>
  </div> 
  <P>
  <DD>
	<div class="header">6.1. <A href="#REF_6_1">Возможности 
  препроцессора и его вызов</A></div> 
  <DD>
	<div class="header">6.2. <A href="#REF_6_2">Операторы 
  лексемного замещения идентификаторов</A></div> 
  <DD>
	<div class="header">6.3. <A href="#REF_6_3">Макрозамещение</A></div> 
  <DD>
	<div class="header">6.4. <A href="#REF_6_4">Оператор включения 
  файлов исходного текста</A></div> 
  <DD>
	<div class="header">6.5. <A href="#REF_6_5">Условная 
  компиляция</A></div>
  <DD>
	<div class="header">6.6. <A href="#REF_6_6">Изменение 
  нумерации строк и имени файла</A></div> 
  <DD>
	<div class="header">6.7. <A href="#REF_6_7">Расширенные 
  возможности современных процессоров</A></div>
 <P>&nbsp;</P>


 <dt><div class="header"><A href="#REF_7">7. ЗАПУСК И ЗАВЕРШЕНИЕ 
  ПРОГРАММ</A> 
  </div>
  <P>
 	 <DD>
 <div class="header">7.1. <A href="#REF_7_1">Головная функция 
  программ на языке C</A></div>
     	 <DD>
	<div class="header">7.2. <A href="#REF_7_2">Порождение и 
  идентификация задач</A></div>
       <DD>
	<div class="header">7.3. <A href="#REF_7_3">Завершение 
  программ</A></div> 
  	 <DD>
  <P>
	<div class="header">7.4. <A href="#REF_7_4">Идентификация 
  задач и виды межзадачных взаимодействий</A></div>
  <P align="justify">&nbsp;</P>
  
  <DT><div class="header"><A href="#REF_8">8. СИСТЕМНО ЗАВИСИМЫЕ 
  КОНСТРУКЦИИ ЯЗЫКА С</A>
  </div> 
  <P>
  	<DD>
	<P>
	<div class="header">8.1. <A href="#REF_8_1">Системно 
  зависимые расширения языка C</A></div> 
  	<DD>
	<div class="header">8.2. <A href="#REF_8_2">Понятие 
  псевдо-регистров</A></div> 
  	<DD>
	<div class="header">8.3. <A href="#REF_8_3">Функции - 
  обработчики прерываний</A></div> 
  	<DD>
	<div class="header">8.4. <A href="#REF_8_4">Дополнительные 
  атрибуты указателей</A></div> 
  	<DD>
	<div class="header">8.5. <A href="#REF_8_5">Модификаторы типа 
  объектов</A></div> 
  	<DD>
	<div class="header">8.6. <A href="#REF_8_6">Использование 
  ассемблера</A></div> 
  <P>&nbsp;</P>
 
	<DT><div class="header"><A href="#REF_9">9. ВВОД-ВЫВОД ДАННЫХ НА 
  ЯЗЫКЕ C</A>
  </div> 
  <P>
  <DD>
	<P>
	<div class="header">9.1. <A href="#REF_9_1">Организация 
  ввода-вывода данных в C</A></div> 
  <DD>
	<div class="header">9.2. <A href="#REF_9_2">Бесформатный 
  ввод-вывод</A></div> 
  <DD>
	<div class="header">9.3. <A href="#REF_9_3">Форматный 
  ввод-вывод</A></div> 
   <P>&nbsp;</P>

	  <DT><div class="header"><A href="#REF_10">10. СТРУКТУРЫ ДАННЫХ</A>
  </div> 
  <P>
  <DD>
	<div class="header">10.1. <A href="#REF_10_1">Виды организации 
  хранения данных в памяти</A></div> 
  <DD>
	<div class="header">10.2. <A href="#REF_10_2">Абстрактные 
  структуры данных</A></div> 
  <DD>
	<div class="header">10.3. <A href="#REF_10_3">Отображение 
  структур данных в памяти</A></div> 
  <DD>
	<div class="header">10.4. <A href="#REF_10_4">Примеры 
  представления структур данных</A></div> 
  <P>&nbsp;</P>
  
  <DT><div class="header"><A href="#REF_11">11. СОРТИРОВКА И ПОИСК 
  ДАННЫХ</A> 
  <P>
  <DD>
  <div class="header">11.1. <A href="#REF_11_1">Характеристика 
  проблемы сортировки</A></div> 
  <DD>
	<div class="header">11.2. <A href="#REF_11_2">Методы внутренней 
  сортировки</A></div> 
  <DD>
	<div class="header">11.3. <A href="#REF_11_3">Поиск данных</A></div> 
  <DD>
	<div class="header">11.4. <A href="#REF_11_4">Cтандартные 
  процедуры сортировки и поиска данных</A></div> 
  <P>&nbsp;</P>
  
  <DT><div class="header"><A href="#REF_12">12. ПРИМЕРЫ РЕШЕНИЯ ЗАДАЧ 
  СИСТЕМНОГО ПРОГРАММИРОВАНИЯ</A>
  </div> 
  <P>
  <DD>
	<div class="header">12.1. <A href="#REF_12_1">Анализ схемы 
  распределения памяти в MS-DOS</A></div> 
  <DD>
	<div class="header">12.2. <A href="#REF_12_2">Вывод списка 
  установленных драйверов устройств</A></div> 
  <DD>
	<div class="header">12.3. <A href="#REF_12_3">Получение 
  информации о системных ресурсах</A></div> 
  <DD>
	<div class="header">12.4. <A href="#REF_12_4">Обработка 
  прерываний в ПЭВМ типа IBM PC/XT/AT</A></div> 
  <DD>
	<div class="header">12.5. <A href="#REF_12_5">Понятие системы 
  типа "клиент-сервер"</A></div>
  <DD>
	<div class="header">12.6. <A href="#REF_12_6">Пример построения 
  системы "клиент-сервер" в QNX</A></div> 
  <DD>
	<div class="header">12.7. <A href="#REF_12_7">Защита файлов от 
  копирования</A></div> 
  <P>&nbsp;</P>
<DT><div class="header"><A href="#REF_13">13. ИНТЕРПРЕТАЦИЯ СИСТЕМ 
  ПРОДУКЦИЙ НА ЯЗЫКЕ С</A>
  </div> 
  <P>
  <DD>
	<div class="header">13.1. <A href="#REF_13_1">Сетевое 
  представление системы продукций</A></div> 
  <DD>
	<div class="header">13.2. <A href="#REF_13_2">Входное описание 
  систем продукций</A></div> 
  <DD>
	<div class="header">13.3. <A href="#REF_13_3">Интерпретация 
  систем продукций</A></div> 
  <P>&nbsp;</P>

  <DT><div class="header"><A href="#REF_Z">ЗАКЛЮЧЕНИЕ</A></div></DT>
<P></P>

  <DT><div class="header"><A href="#REFERENCE">ЛИТЕРАТУРА</A></div>
</DT></DL>
<P>
<P>
<HR SIZE=1 width="100%">
<div class="header"><A href="#REF_1_C">Начало</A></div>
<p> 
<div class="header"><center><A name=REF_0></A>ВВЕДЕНИЕ</CENTER></div>
<p>
Системными программами называют набор программ, используемых в процессе 
подготовки прикладных программ на этапах от постановки задачи до выполнения на 
ЭВМ. Примеры системных программ - трансляторы, редакторы связей, текстовые 
редакторы, загрузчики, отладчики, канальные программы, драйверы. 
<P>Системное программирование - разработка, настройка и прагматическое 
использование системных программ в конкретной вычислительной среде. 
<P>Принципиальное отличие системного программирования от прикладного - 
зависимость от вычислительной системы. Системное програмирование непосредственно 
связано с особенностями аппаратуры ЭВМ и механизмов операционной системы. 
<P>
<UL>Основные вопросы системного программиста по архитектуре ЭВМ, построенной 
  на идее совместно запоминаемых программы и данных (Дж.фон Нейман): 
  <LI>память - минимальная адресуемая единица памяти, объем памяти, схема 
  адресации; 
  <LI>регистры - количество регистров, их размер, функция и взаимосвязь; 
  <LI>данные - обрабатываемые типы и формат представления в памяти 
  арифметических, символьных и логических данных; 
  <LI>команды - классы команд ЭВМ, набор команд обработки арифметических, 
  логических и символьных данных, команд управления, формат команд и схема их 
  хранения в памяти; 
  <LI>специальные средства - структура системы прерываний, механизмы защиты и их 
  доступность для пользователя, организация ввода-вывода. </LI></UL>
<P>
<P>Современные вычислительные системы, как правило, представляются наслоением 
программного обеспечения на аппаратуру. Работа в вычислительной среде конкретной 
операционной системы требует знания спецификации интерфейсов связи с ее модулями 
на разных уровнях детализации. В последнее время наблюдается тенденция смещения 
массовых задач системного программирования на программный уровень[13]. 
<P>
<P>В настоящее время задачи системного программирования решаются с 
использованием чаще всего языка ассемблера либо языка С. 
<P>Под <font color = "#004D77">а с с е м б л е р о м </font>(автокодом, системой символического кодирования) 
понимают систему программирования, включающую: язык символического кодирования 
программы на машинном уровне в терминах мнемонических обозначений команд и 
символических обозначений операндов; транслятор программ на языке ассемблера в 
перемещаемые (объектные) модули. Функции ассемблера: отображение символических 
объектов исходного текста программы на память с учетом формата команд, форм 
представления данных и системы адресации; подготовка объектного модуля программы 
стандартного вида; предоставление программисту высокоуровневых услуг по 
автоматизации кодирования программы (вычислительные операции, макросредства, 
диагностика ошибок). 
<P align=DEFAULT>Ассемблер применяют после убедительного обоснования в редких 
классах задач: создание базовых элементов системного программного обеспечения; 
решение задач со специальными требованиями по вычислительной эффективности либо 
методам использования вычислительных ресурсов; комплексирование разнородных 
программных продуктов. Языком ассемблера представляют: заключительный уровень 
детализации результатов транслятором языка высокого уровня либо генератором 
прикладных программ; элементы настройки операционных систем и сложных пакетов 
прикладных программ на конкретные условия применения; фрагменты адаптируемых 
посредством дизассемблирования чужих программ при отсутствии исходного текста. 
Язык C, в отличие от языка ассемблера, ориентирован на переносимость программ, 
по крайней мере, на уровне исходного текста с одной вычислительной системы на 
другую. Это обеспечивается наличием трансляторов языка С практически на всех 
современных вычислительных системах. 
<P>
<P>
<P>
<HR SIZE=1 width="100%">
<A href="#REF_1_C">Начало</A>
<p> 
<div class="header"><center><A name=REF_1></A>1. ОБЗОР ЯЗЫКА ПРОГРАММИРОВАНИЯ C </center></div>
<P>
<div class="header"><A name=REF_1_1></A>1.1. Характеристика языка С </div>
<P>Язык C первоначально доминировал в среде мини-ЭВМ, работающих под управлением 
ОС UNIX, но в дальнейшем получил широкое распространение и в других классах 
вычислительных систем. Сейчас трудно найти вычислительную систему без поддержки 
такого языка. 
<P>Достоинства языка С [1,2,18]: 
<DL>
  <DD><LI>это современный, эффективный, переносимый, мощный и гибкий, удобный и 
  обладающий рядом присущих ассемблеру управляющих конструкций язык. 
  <P></P>
  <DD><LI>наиболее важное положительное качество языка С - переносимость (мобильность), обеспечиваемая наличием 
стандарта языка и, следовательно, совместимых на уровне исходного текста систем 
программирования. 
</DD></DL>
Недостаток языка C - относительно плохая "читаемость" текста программ 
  из-за неоднозначности синтаксиса. 
<P>Области применения языка C - системное программирование и прикладные задачи с 
жесткими требованиями по скорости и памяти. 
<P>Язык С относится к классу языков процедурного типа с адресной арифметикой и 
формально является подмножеством языка объектно-ориентированного 
программирования C++. Освоение языка C создает фундамент для изучения языка C++ 
[2,3]. 
<P>
<P>

<div class="header"><A name=REF_1_2>1.2. Основные сведения о синтаксисе языка C</A>
</div>
<P>Начальные сведения о синтаксисе любого языка программирования включают 
элементарные правила записи исходного текста программы - идентификация объектов 
программы, комментарии, формат исходного текста. 
<p>Идентификаторы объектов программы на языке C могут включать:
  <UL> 
  <LI>цифры 0...9; 
  <li>латинские прописные и строчные буквы A...Z, a...z; 
  <li>символ подчеркивания _. </UL>
<P>Первый символ идентификатора не может быть цифрой. Длина идентификатора 
определяется реализацией транслятора C и редактора связей (компоновщика). 
Современная тенденция - снятие ограничений длины идентификатора. 
<P>Разделители идентификаторов объектов программы: 
  <ul>
  <li>пробелы; 
  <li>символы табуляции, перевода строки и страницы; 
  <li>комментарии (играют роль пробелов). </UL>
<P>Комментарий - любая последовательность символов, начинающаяся парой символов 
/* и заканчивающаяся парой символов */. 
<P>Формат записи исходного текста программ на языке C - свободный. 
<P>
	<pre><div class="code">
     /* ПРИМЕР ПРОГРАММЫ ТЕСТА ГЕНЕРАТОРА СЛУЧАЙНЫХ ЧИСЕЛ */
     
     #include &lt;stdio.h&gt;
     #include &lt;stdlib.h&gt;
     
     #define RANGE 100
     
     void main() {
      int i,j,k,s;
     
      /* Запрос объема выборки */

      while (printf("\n K-? "), !scanf(" %d",&amp;k);

      /* Генерация случайных чисел */

      printf("\n Значения %d случайных чисел:\n",k);
      for (s=i=0; i &lt; k; i++) 
       s+=(j=random(RANGE)+1);
       printf("\n %3d) %d",i,j);
      }
      printf("\n\n Сумма %d, среднее %f",s,(float)s/k);
     }
</div></pre>
<P>
<P>
<P>
<P>

<div class="header"><A name=REF_1_3></A>1.3. Структура программ на языке С </div>
<P>Программа на языке С включает операторы декларации объектов, преобразования 
объектов и управления вычислительным процессом. Программирование процесса 
преобразования объектов программы производится посредством записи выражений. 
Выражение включает один или несколько операндов и символов операций. Любое 
выражение, заканчивающееся символом ';', является оператором. 
<p>Простейший вид операторов - операторы-выражения: 
<ul>
  <li>оператор <A href="#REF_3_2">присваивания</A> - выполнение 
  операций присваивания; 
  <li>оператор <A href="#REF_3_12">вызова 
  функции</A> - операция вызова функции; 
  <li>пустой оператор. </ul>
<P>Классы управляющих операторов в языке С: 
<ul>
  <li>операторы <A href="#REF_4_1">условного и 
  безусловного перехода;</A> 
  <li>операторы <A href="#REF_4_2">организации 
  циклов;</A> 
  <li>оператор <A href="#REF_4_3">выбора 
  альтернатив (переключатель);</A> 
  <li>оператор <A href="#REF_4_4">выхода из 
  функции.</A> </ul>
<p>Каждый из управляющих операторов имеет конкретную 
лексическую конструкцию, образуемую из ключевых слов языка С, выражений и 
символов-разделителей '{','}',',',':','(',')'. Операторы языка С записываются в 
свободном формате с использованием разделителей между ключевыми словами. 
Допустима вложенность операторов. Любой оператор может помечаться меткой - 
идентификатором и символом ':'. Область действия метки - функция, где эта метка 
определена. В случае необходимости можно использовать составной оператор (блок) 
- последовательность любых операторов, заключенная в фигурные скобки { и } 
(после закрывающей скобки символ ';' не требуется). Элементарным модулем 
программы на языке С является функция. Любая программа должна содержать, как 
минимум, головную функцию со стандартным именем main. 
<P>Пример исходного текста программы: 

<P><pre><div class="code">     #include &lt;stdio.h&gt;
     
     /* ПРОГРАММА ПЕЧАТИ КОДОВ НАЖАТЫХ КЛАВИШ */
     
     void main () {
      int i;
      
      while ((i=getch())!=27) {
      if (i==0) printf("\n* %d",getch());
       else printf("\n  %d",i);
      }
     }
</div></pre>
<P>
<P>

<div class="header"><A name=REF_1_4></A>1.4. Функции и библиотеки функций языка С </div>
<P>Большинство трансляторов языка C - компиляторы. Технология подготовки 
программы к выполнению включает эпапы трансляции исходного текста в объектный 
модуль и получение после редактирования его связей с другими оъектными модулями 
исполняемого (загрузочного) модуля. Объектные модули могут размещаться в так 
называемой библиотеке - файле со специальным методом доступа. Редактор связей 
может выполнять выборку объектных модулей из библиотеки непосредственно. 
Включение объектных модулей в библиотеку, их удаление и контроль содержания 
библиотеки выполняет отдельная программа - библиотекарь. Система 
программирования Turbo-C включает препроцессор, компилятор, редактор связей, 
библиотекарь, редактор текста, отладчик и интегрированную управляющую среду [6]. 

<P>Программирование на языке C связано с интенсивным использованием библиотечных 
функций. Мобильность программ на языке C потребовала при его разработке 
исключения операторов, реализация которых каким-либо образом связано с 
организацией вычислительной среды. Можно заметить, что операционные средства 
языка находятся науровне машинных команд, простейших базовых типов данных, 
непосредственно отображаемых на регистры процессора. 
<P>Библиотеки функций на языке С обычно отражают конкретную вычислительную 
среду. Структуризация библиотечных функций на уровне пользователя проявляется 
системой так называемых заголовочных файлов, содержащих описания функций 
средствами языка. Заголовочные файлы с описаниями фактически используемых 
функций обычно включатся посредством директивы препроцессора #include в исходный 
текст программы. Заголовочные файлы имеют содержательные имена. 
<P>Пример именования заголовочных файлов в системе программирования Borland C++ 
3.1 (MS-DOS) [6-8]: 
<P>
<ul>
<li>alloc.h - функции управления памятью; 
<li>bios.h - функции интерфейса BIOS; 
<li>conio.h - функции консольного ввода-вывода DOS; 
<li>ctype.h - информация для классификации и преобразования символов; 
<li>dir.h - средства доступа к директориям и именам файлов; 
<li>direct.h - POSIX директорий; 
<li>dos.h - константы и объявления DOS; 
<li>errno.h - мнемонические константы и коды ошибок; 
<li>fcntl.h - символические константы функции открытия файлов; 
<li>float.h - интерфейс функций арифметики с плавающей точкой; 
<li>graphics.h - функции для работы с графикой; 
<li>io.h - функции низкоуровневого ввода-вывода; 
<li>limits.h - информация об ограничениях и диапазонах значений параметров 
вычислительной среды; 
<li>locale.h - информация о поддержке страны и языка; 
<li>malloc.h - функции управления памятью; 
<li>math.h - математические функции и структуры сообщений об ошибках; 
<li>mem.h, memory.h - функции манипулирования блоками памяти; 
<li>process.h - структуры и функции порождения задач; 
<li>search.h - функции сортировки и поиска; 
<li>setjmp.h - структуры данных и функции нелокального перехода; 
<li>share.h - интерфейс доступа к разделяемым файлам; 
<li>signal.h - порождение исключительных ситуаций; 
<li>stdarg.h - средства поддержки списка аргументов функций переменной длины; 
<li>stddef.h - разнообразные стандартные типы данных; 
<li>stdio.h - функции стандарного ввода-вывода и предопределенные файлы 
ввода-вывода stdin, stdout, stdprn и stderr; 
<li>stdlib.h - массовые вспомогательные функции; 
<li>string.h - операции со строками символов; 
<li>sys\stat.h - символические константы процедур открытия и создания файлов; 
<li>sys\types.h - декларация характеристик некоторых типов данных; 
<li>time.h - структуры данных и функции для работы со временем; 
<li>values.h - важные системно зависимые константы.</ul> 
<P>Легко заметить, что приведенное типичное для систем программирования 
группирование функций отражает весьма важные в практическом программировании 
действия. Проведя эксперимент с любой из реальных систем программирования, можно 
убедиться в наличии тысяч функций и связанных с ними определений. Таким образом, 
знание собственно лингвистических конструкций языка С не означает обладание 
профессиональным уровнем работы в конкретной вычислительной среде [6-7, 9, 12]. 
Иногда говорят, что язык С - язык функций. 
<P>Интегрированные среды разработки программ современных систем программирования 
включают, как правило, системы оперативной подсказки, позволяющие получать 
исчерпывающую информацию об использовании библиотечных функций. "Точками входа" 
в справочный материал во многих справочных системах является имя заголовочного 
файла из приведенного списка. Можно заметить, что состав заголовочных файлов 
отражает базовый набор интуитивно ожидаемых понятий, характеризующих 
вычислительную среду. 
<P>Исторически язык С создан в период использования текстового режима 
ввода-вывода информации программы, поэтому представленные в файле stdio.h 
функции стандарного ввода-вывода предполагают поддержку именно такого режима. 
Работа в графическом режиме отображения информации, а также с манипулятором 
"мышь" или другими нестандартными устройствами требует специальных библиотек.
<P>Подобные обстоятельства заставляют с повышенным вниманием относиться к этапу 
инсталяции и настройки систем программирования на языке С. Следует учитывать, 
что результат компиляции программ на языке С зависит от параметров настройки, 
связанных с учетом характеристик вычислительной среды (например, модели памяти в 
MS-DOS,режим выравнивания, контроль стека, диагностика). 
<P>Изучение языка программирования С можно вести с проведением сеансов работы в 
любой доступной системе программирования. На персональных ЭВМ удобными для 
обучения и легкодоступными являются разработки фирмы Borland - Turbo-C, Borland 
C++ версий 3.1 и выше [6-8]. 
<P>
<P>
<HR SIZE=1 width="100%">
<A href="#REF_1_C">Начало</A> 
<p>
<div class="header"><CENTER><A name=REF_2></A>2. ДЕКЛАРАЦИЯ ОБЪЕКТОВ ПРОГРАММЫ НА ЯЗЫКЕ C </CENTER></div>
<P>
<div class="header"><A name=REF_2_1></A>2.1. Операционные объекты в языке C </div>
<P>Любые действия программы связаны с понятием операционного объекта. 
<P>
<P>Классы операционных объектов программ на языке C: 
<UL>
  <LI>константы; 
  <LI>простые переменные; 
  <LI>массивы; 
  <LI>структуры; 
  <LI>объединения; 
  <LI>указатели объектов; 
  <LI>функции. </LI></UL>
<P>Объекты программы в общем случае имеют атрибуты: 
<UL>
  <LI><A href="#REF_2_2">тип</A> - 
  характеристика механизма интерпретации данных; 
  <LI><A href="#REF_5_2">класс памяти</A> - 
  характеристика способа организации размещения объектов в памяти (статическая и 
  динамическая память); 
  <LI><A href="#REF_5_1">область действия</A> - 
  характеристика области использования объектов функциями программы (локальные и 
  глобальные объекты). </LI></UL>
Единственная разновидность объектов, определяемая 
в исходном тексте непосредственно по месту использования - константы. Иногда 
используют термин "самоопределенные константы". Остальные объекты программы 
должны быть явно описаны в виде 
<P>&lt;атрибуты&gt; &lt;список_идентификаторов_объектов&gt;; 
<P>(элементы списка разделены запятыми, а атрибуты - разделителями). 
<p>Предварительно отметим следующее: 
<UL>
  <LI>в языке C <A href="#REF_2_2">атрибуты 
  типа</A> описываются всегда явно; 
  <LI><A href="#REF_5_2">класс памяти</A> можно 
  не указывать, используя назначение по умолчанию; 
  <LI><A href="#REF_5_1">область действия</A> 
  объекта специальным ключевым словом не задается. </LI></UL>
<P>
<P>&nbsp;</p>
<div class="header"><A name=REF_2_2></A>2.2. Понятие типа объекта в языке С </div>
<P>Тип объекта <STRONG>рекурсивно</STRONG> определяется на основе любого <A 
name=REF_2_3>базового</A> и производного типа посредством использования: 
<UL>
  <LI>символов модификации текущего типа; 
  <LI>предписания размещения объектов известных типов в памяти. 
</LI></UL>Модификаторы текущего типа: 
<UL>
  <LI>символ * перед идентификатором - описание указателя на объект исходного 
  типа; 
  <LI>символы [ и ] после идентификатора объекта - описание массива объектов; 
  <LI>символы ( и ) после идентификатора объекта - описание функции. 
</LI></UL>Отметим, что обязательное условие использования скобочных 
модификаторов любого вида - баланс открывающих и закрывающих скобок. Внутри 
скобок может размещаться детализирующая описание типа информация, например, 
размерность массива или список параметров. Допускается использование более 
одного модификатора типа c учетом следующих правил: 
<DL>
  <DD>1) чем ближе модификатор к идентификатору, тем выше его приоритет; 
  <DD>2) модификаторы [] и () обладают приоритетом перед *; 
  <DD>3) дополнительно вводимые круглые скобки позволяют увеличить приоритет 
  объединяемых ими элементов описания. </DD></DL>
<P>Примеры описания объектов: 
<P><pre><div class="code">type a0;        /* Элемент типа type */
type a1[5];     /* Массив элементов типа type */
type *a2;       /* Указатель на элемент типа type */
type **a3;      /* Указатель на указатель элемента типа type */
type *a4[5];    /* Массив указателей на элементы типа type */
type (*a5)[10]; /* указатель на массив элементов типа type */
type *a6[3][4]; /* 3-элементный массив указателей
                   на 4-элементный массив элементов типа type */
type a7[5][2];  /* Массив массивов элементов типа type */
type a8();      /* Функция, вычисляющая значение типа type */
type *a9();     /* Функция, вычисляющая указатель
                   на элемент типа type */
type (*aa)();   /* Указатель на функцию, вычисляющую
                   значение типа type */
type *ab()[6];  /* Функция, вычисляющая указатель
                   на массив элементов типа type */
type *aс[4]();  /* Массив указателей на функцию, вычисляющую
                   значение типа type */
</div></pre>
<P>Здесь type - некоторый известный текущий тип объектов. Возможности 
определения размещения объектов известных типов в памяти в языке C представлены 
понятиями массивов, структур и объединений (см. 2.4-2.5). 
<P>
<P>&nbsp;</p>
<div class="header"><A name=REF_2_3></A>2.3. Базовые типы данных в языке С </div>
<P>Перечень базовых типов данных: 
<DL>
<DT>a) целые числа:
  <DD>int - целое (слово); 
  <DD>short - короткое целое (полуслово либо слово); 
  <DD>long - длинное целое (слово либо двойное слово); 
  <DD>unsigned - неотрицательное целое (слово);
  <DT>б) символы: 
  <DD>char - символ (байт); 
  <DT>в) числа с плавающей точкой: 
  <DD>float - число с плавающей точкой ординарной точности; 
  <DD>double - число с плавающей точкой двойной точности. </DD></DL>Атрибут 
unsigned может сочетаться с атрибутами char, int, short, long. Атрибут int можно 
добавлять к атрибутам short и long без последствий. Примеры описания простых 
объектов: 
<P><pre><div class="code">     int i,j,k;
     char r;
     double gfd;

</div></pre>
<P>К основным типам объектов формально относится и тип void - отсутствие 
значения. Очевидно, что реальные объекты типа void в памяти не могут быть 
созданы. Варианты применения ключевого слова void: 
<UL>
  <LI>нейтрализация значения, возвращаемого функцией (в отличие от других 
  языков, где существуют два вида процедурных модулей - подпрограммы и функции, 
  в языке C исполнимым модулем программы является функция); 
  <LI>явная пометка пустого списка параметров функции; 
  <LI>декларация указателей на область памяти без назначения типа хранящихся 
  данных. </LI></UL>Примеры описания функций: 
<p><pre><div class="code">     int sigma(char x, int y);
     void betta(void);
     char *gamma(int);
</div></pre>
<P>&nbsp;</p>

<div class="header"><A name=REF_2_4></A>2.4. Массивы в языке С </div>
<P><strong>Массив</strong> - простейший вид структурного типа, представляющий поименованную 
совокупность последовательно размещаемых в памяти данных <STRONG>одного</STRONG> 
типа. Примеры описания массивов: 
<P><pre><div class="code">     char s[20];       /* Одномерный массив */
     int  x[10][20];   /* Двумерный массив  - массив массивов */
</div></pre>
<P>
<P>Особенность индексации элементов массива в языке C - нулевой индекс первого 
элемента по каждому измерению. Доступ к отдельному элементу массива выполняется 
после указания его целочисленного индекса двумя способами: использование 
операции индексации - s[10], x[5][6]; косвенное обращение по указателю - 
*(s+10), *(*(x+5)+6). 
<P>&nbsp;</p>

<div class="header"><A name=REF_2_5></A>2.5. Структуры и объединения в языке C </div>
<P><strong>Структура</strong> - поименованная совокупность логически связанных данных не 
обязательно одинаковых типов, размещаемых в смежных областях памяти. 
<P>Структурный тип данных может быть описан в виде: 
<P>struct имя_структуры { описание_элементов }; 
<P>(между символами } и ; иногда помещают список декларируемых структурных 
переменных, при этом "имя_структуры" можно опустить). "Описание_элементов" 
производится обычным способом, ограничений на тип элементов нет. Пример 
определения структурного типа: 
<P><pre><div class="code">     struct person {
      char fio[72];
      int  dlg;
      struct person *next;
     };
</div></pre>
<P>Интерпретация объекта типа struct person: 
<P><PRE>                  ==============================================
                 ¦           fio          ¦  dlg  ¦    next     ¦
 Длина в байтах  ¦==============================================¦
 ---------------&gt;¦&lt;-----------72---------&gt;¦&lt;--2--&gt;¦&lt;-----4-----&gt;¦
</PRE>

<P>Структурный тип "struct имя_структуры" можно использовать для декларации 
структурных переменных, массивов, функций и т.д. 
<P><PRE><div class="code">struct person teacher;      /* Структурная переменная */
struct person student[100]; /* Массив структур */
struct person *inplst();    /* Функция - указатель на структуру */
</div></PRE>
<P>Предыдущий пример можно записать кратко: 
<P><pre><div class="code">     struct person {
      char fio[72];
      int  dlg;
      struct person *next;
     } teacher, student[100], *inplst();
</div></PRE>
<P>
<P>Имя структуры здесь также можно опустить: 
<P><PRE><div class="code">     struct {
      char fio[72];
      int  dlg;
      void *next;  /* Cм. операции над указателями */
     } teacher, student[100], *inplst();
</div></PRE>
<P>
<P>Элементом структуры могут быть битовые поля (строки битов): 
<P><PRE><div class="code">     struct fields {
      unsigned int flag:1;
      unsigned int mask:10;
      unsigned int code:5;
     };
</div></PRE>
<P>(после символа ':' указывается длина битового поля, не превышающая 
разрядность поля типа int). <p>Битовые поля размещаются последовательно в поле типа 
int, при нехватке места для очередного битового поля - переход на следующее поле 
типа int. Возможно объявление безымянных битовых полей, а длина поля 0 означает 
необходимость перехода на очередное поле int: 
<P><PRE><div class="code">     struct areas {
      unsigned f1:1;
                 :2;   /* Безымянное поле длиной 2 бита */
      unsigned f2:5;
                 :0    /* Признак перехода на след. поле int */
      unsigned f3:5;
      float data;      /* Структура может содержать   */
      char buffs[100]; /* элементы любых типов данных */
     };
</div></PRE>
<P>
<P>Битовые поля могут использоваться в выражениях как целые числа 
соответствующей длине поля разрядности в двоичной системе исчисления. 
Единственное отличие этих полей от обычных объектов запрет операции определения 
адреса (&amp;)(см. 3.11). Следует учитывать, что использование битовых полей 
снижает быстродействие программы по сравнению с представлением данных в полных 
полях из-за необходимости выделения битового поля. Элементы структур в общем 
случае размещаются в памяти последовательно с учетом выравнивания начальных 
адресов. Выравнивание - установка значения адреса, кратного некоторой величине, 
определяемой особенностами адресации данных на аппаратном уровне. Например, в 
системе 360/370 используется выравнивание на границу полуслова (2 байта), слова 
(4 байта) или двойного слова (8 байт). Часто выравнивание не обязательно, но при 
этом скорость обращения к объекту может снижаться. В системе программирования 
Turbo-C можно выбирать режим выравнивания. Включение режима выравнивания 
становится заметным при использовании структур и объединений, где объявлены 
объекты с разнымиграницами выравнивания. Компиляторы языка С не меняют порядок 
элементов структуры, поэтому в поле размещения структуры могут появиться 
неиспользуемые участки памяти. В итоге размер структуры может отличаться от 
суммы размеров ее элементов. Структурный тип данных удобно применять для 
группового управления манипулирования логически связанными объектами. 
Параметрами таких операций являются адрес и размер структуры. Примеры групповых 
операций: 
<UL>
  <LI>захват и освобождение памяти для объекта, представленного совокупностью не 
  обязательно однотипных данных (см. struct person); 
  <LI>запись и чтение данных, хранящихся на внешних носителях как физические 
  и(или) логические записи с известной структурой. </LI></UL>
<P>Oбъединение - поименованная совокупность данных разных типов, размещаемых с 
учетом выравнивания в одной и той же области памяти, размер которой достаточен 
для хранения наибольшего элемента. объединенный тип данных декларируется подобно 
структурному типу: 
<P><PRE><div class="code">     union имя_объединения {
       описание_элементов
     };
</div></PRE>
<P>(между символами } и ; иногда помещают список декларируемых переменных 
объединенного типа, тогда "имя_объединения" можно опустить). 
<P>Пример описания объединенного типа: 
<P><PRE><div class="code">     union word {
      int bin;
      char byte[2];
     };
</div></PRE>
<P>
<P>Интерпретация объекта типа union word: 
<P><PRE>                  ===================
                 ¦        bin        ¦
                 ¦===================¦
                 ¦ byte[0] ¦ byte[1] ¦
 Длина в байтах  ¦===================¦
----------------&gt;¦&lt;---1---&gt;¦&lt;---1---&gt;¦
</PRE>
<P>Пример объявления объектов объединенного типа: 
<P><PRE><div class="code">     union word *area, buffer[100];
</div></PRE>
<P>Объединения применяют для экономии памяти в случае, когда объединяемые 
элементы логически существуют в разные моменты времени либо требуется 
разнотипная интерпретация поля данных. Например, поток сообщений по каналу связи 
пусть содержит сообщения трех видов: 
<P><PRE><div class="code">     struct m1 {
      char code;
      float data[100];
     };

     struct m2 {
      char code;
      int mode;
     };

     struct m3 {
      char code, note[80];
     };
</div></PRE>
<P>
<P>Элемент code - признак вида сообщения. Удобно описать буфер для хранения 
сообщений в виде 
<P><PRE><div class="code">     struct m123 {
      char code;
      union {
       float data[100];
       int mode;
       char note[80];
      };
     };
</div></PRE>
<P>
<P>Обращение к элементам структур или объединений производится посредством 
операции принадлежности (.) в виде 
<P><div class="code"><font color = "black">имя_структуры_или_объединения.имя_элемента </font></div>или 
<div class="code"><font color = "black">(*указатель_структуры_или_объединения).имя_элемента</font></div> 
<P>либо операции косвенной адресации (-&gt;) в виде 
<P><div class="code"><font color = "black">указатель_структуры_или_объединения-&gt;имя_элемента</font></div> 
<P>Примеры обращения: 
<P><PRE><div class="code">     teacher.next
     area-&gt;bin
     buffer[i].byte[1]
</div></PRE>
<P>&nbsp;</p>

<div class="header"><A name=REF_2_6></A>2.6. Перечисления </div>
<P><STRONG>Перечисления</STRONG> - средство создания типа данных посредством задания 
ограниченного множества значений. Определение перечислимого типа данных имеет 
вид 
<P><PRE><div class="code">     enum имя_перечисляемого_типа {
      список_значений
     };
</div></PRE>
<P>(между символами } и ; иногда помещают список декларируемых переменных 
перечисляемого типа, а "имя_перечисляемого_типа" можно опустить). Значения 
данных перечисляемого типа указываются идентификаторами: 
<P><PRE><div class="code">     enum marks {
      absence, two, three, four, five
     };
</div></PRE>
<P>Транслятор последовательно присваивает идентификаторам списка значений 
целочисленные величины 0,1,... . При необходимости можно явно задать значение 
идентификатора, тогда очередные элементы списка будут получать последующие 
возрастающие значения: 
<P><PRE><div class="code">     enum level {
      low=100, medium=500, high=1000, limit
     };
</div></PRE>
<P>
<P>(значение limit будет равно 1001). 
<br>Пример объявления переменной 
перечисляемого типа: 
<P><PRE><div class="code">     enum marks estimation;
     enum level state;
</div></PRE>
<P>Переменная marks может принимать только значения из множества {absence, two, 
three, four, five}. Возможные операции с данными перечисляемого типа: 
<UL>
  <LI>присваивание переменных и констант одного типа; 
  <LI>сравнение для выявления равенства либо неравенства. </LI></UL>Практическое 
назначение перечислений - определение множества <STRONG>различающихся</STRONG> 
символических констант целого типа. Назначить значения элементов перечисления 
можно любым константным выражением, включая ранее определенные значения даже 
определяемого типа: 
<P><PRE><div class="code">     enum proces_status {
      passive=0x01,            /* Пассивный элемент трассы    */
      actived=0x02,            /* Активный элемент трассы     */
      goalset=actived+passive, /* Фильтр меток решения        */
      visited=0x04,            /* Просмотренная вершина сети  */
      storage=0x08,            /* Пропускаемая вершина трассы */
      labeled=visited+storage, /* Фильтр меток поиска решения */
      tempset=~labeled,        /* Фильтр временных меток      */
      pathset=~goalset         /* Фильтр меток трассы         */
     };
</div></PRE>
<P>
<P>Очевидно, что элементы перечисления не хранятся в памяти, а лишь становятся 
известными компилятору. Только их упоминание в выражениях приводит к размещению 
в памяти соответствующего целочисленного значения. 
<P>&nbsp;</p>

<div class="header"><A name=REF_2_7></A>2.7. Оператор переопределения типа </div>
<P>Обязательность явной декларации типов объектов в языке С в случае 
использования производных типов требует повышенного внимания при записи 
идентификаторов базовых типов. Часто новому образуемому посредством 
модификаторов производному типу удобно назначить уникальный идентификатор, 
учитывая его содержательный смысл. Например, представлением комплексных чисел 
может быть структура 
<P><PRE><div class="code">     struct complex {
      float real, image;
     };
</div></PRE>
<P>
<P>Именем типа здесь выступает пара слов - struct complex, поэтому декларация 
скалярной переменной, массива и указателя такого типа имеет вид 
<P><div class="code"><font color = "black">struct complex x,y[10],*z;</font></div> 
<P>Вариант декларации тех же объектов в форме записи 
<P><div class="code"><font color = "black">COMPLEX x,y[10],*z;</font></div> 
<P>выглядит предпочтительнее для чтения исходного текста программы. Здесь 
выполнена формальная замена текста struct complex идентификатором COMPLEX. 
Соответствующая такой замене так называемая операция лексемного замещения может 
быть предписана оператором препроцессора языка С 
<P><div class="code"><font color = "black">#define COMPLEX struct complex</font></div> 
<P>(подробности см. в 6.2). Однако по отношению к идентификации типов более 
удобен оператор переопределения типа <STRONG>компилятора</STRONG> языка C: 
<P><div class="code"><font color = "black">typedef старый_тип новый_тип;</font></div> 
<P>(здесь старый_тип, новый_тип - имена типов объектов). Область действия такого 
оператора определяется его расположением аналогично операторам описания типа 
объектов. Примеры переопределения типа и использования новых имен типов: 
<P><PRE><div class="code">typedef int INTEGER;

     INTEGER a,b,c;

typedef struct {
 float real;
 float image;
} COMPLEX;

     COMPLEX x,y[10],*z;

typedef void interrupt (*HANDLER)(void);

     HANDLER old_int_0c;

typedef unsigned int (STREAM)[2];

     STREAM input;
</div></PRE>
<P>
<P>Два последних примера показывают, что формальное отношение между элементами 
текста "старый_тип" и "новый_тип" может быть более сложным, чем при 
использовании оператора препроцессора #define. Любые виды модификаторов типа 
могут окружать фразу "новый_тип". Оператор typedef может определять несколько 
новых типов, если использовать запятые в качестве разделителя: 
<P><PRE><div class="code">    typedef struct _COMSTAT {  /*  Назначение типу        */
     DWORD fCtsHold : 1;       /*  struct _COMSTAT        */
     DWORD fDsrHold : 1;       /*  идентификатора         */
     DWORD fRlsdHold : 1;      /*  COMSTAT,               */
     DWORD fXoffHold : 1;      /*  а типу                 */
     DWORD fXoffSent : 1;      /*  (struct _COMSTAT *) -  */
     DWORD fEof : 1;           /*  идентификатора         */
     DWORD fTxim : 1;          /*  LPCOMSTAT              */
     DWORD fReserved : 25;     /***************************/
     DWORD cbInQue;
     DWORD cbOutQue;
    } COMSTAT, *LPCOMSTAT;
<P>
    typedef struct _PROCESS_INFORMATION {
     HANDLE hProcess;          /***************************/
     HANDLE hThread;           /* Здесь                   */
     DWORD dwProcessId;        /* PPROCESS_INFORMATION    */
     DWORD dwThreadId;         /* и                       */
    } PROCESS_INFORMATION,     /* LPPROCESS_INFORMATION - */
     *PPROCESS_INFORMATION,    /* синонимы имени типа     */
     *LPPROCESS_INFORMATION;   /* (PROCESS_INFORMATION *) */
</P></div></PRE>
<P>
<P>
<P>Использование оператора typedef позволяет улучшить читаемость и переносимость 
программы. 
<P>
<P>

<div class="header"><A name=REF_2_8></A>2.8. Константы в программах на языке C </div>
<P><strong>Константы</strong> - объекты, не подлежащие использованию в левой части оператора 
присваивания. 
<P>В языке С константами являются: 
<UL>
  <LI>самоопределенные <A 
  href="#REF_281">арифметические</A>, <A 
  href="#REF_282">символьные</A> и <A 
  href="#REF_283">строковые</A> константы; 
  <LI>имена <A href="#REF_2_4">массивов</A> и <A 
  href="#REF_3_12">функций</A>; 
  <LI><A href="#REF_2_6">элементы 
  перечислений</A>. </LI></UL>
<P></P><A name=REF_281><strong>Арифметические</strong></A> константы могут быть целого типа или 
числами с плавающей точкой. Целые константы: 
<DL>
  <DD>а) десятичные - последовательность цифр 0...9, первая из которых не должна 
  быть 0; 
  <DD>б) восьмеричные - последовательность цифр 0...7, первая из которых должна 
  быть 0; 
  <DD>в) шестнадцатеричные - последовательность цифр 0...9 или букв A...F 
  (a...f), начинающаяся символами 0x (0X). </DD></DL>
Память для перечисленных 
видов констант выделяется в зависимости от значения. Можно предписать размещение 
константы по требуемому формату, добавив после значения константы символ l(L) - 
long и(или) u(U) unsigned. Примеры целочисленных констант: 
<P><div class="code"><font color = "black">1992, 13, 777, 1000L - десятичные; 0777, 00033, 01l - восьмеричные; 0x123, 
0X00ff, 0xb8000l - шестнадцатеричные.</font></div> 
<P>Константы с плавающей точкой размещаются в памяти по формату double, а во 
внешнем представлении состоят из частей: 
<ul>
  <li>целая часть - цифры 0...9; 
  <li>десятичная точка; 
  <li>дробная часть - цифры 0...9; 
  <li>символ экспоненты e либо E; 
  <li>порядок - целая десятичная константа, возможно со знаком. </ul>
<P>Примеры констант с плавающей точкой: 
<P><div class="code"><font color = "black">1.0, .125, 100е-10, .125E+13</font></div> 
<P><A name=REF_282><strong>Символьные</strong></A> константы - заключенные в апострофы символы 
кода ASCII, рассматриваемые как данные типа int. Целочисленному значению кода 
символа в диапазоне 0...255 (0...0377 или 0...0xff) может соответствовать: 
<UL>
  <LI>изображаемый текстовой символ (алфавитно-цифровой, пробел, символы 
  пунктуации, знаки операций); 
  <LI>специальный символ (псевдографика, национальный алфавит); 
  <LI>управляющий символ (разделители блоков данных, управление обменом и др.). 
  </LI></UL>Текстовые символы можно непосредственно вводить с клавиатуры,а 
специальные и управляющие приходится в исходном тексте представлять парами 
текстовых символов. 
<P>Примеры представления управляющих символов: 
<P>
<DL>
  <DD>\n - новая строка; 
  <DD>\t - горизонтальная табуляция; 
  <DD>\v - вертикальная табуляция; 
  <DD>\b - возврат на шаг; 
  <DD>\r - возврат каретки; 
  <DD>\f - новая страница; 
  <DD>\a - звуковой сигнал. </DD></DL>Примеры представления специальных символов 
языка С: 
<DL>
  <DD>\\ - обратная косая черта; 
  <DD>\' - апостроф; 
  <DD>\" - кавычки; 
  <DD>\0 - нулевой символ (пусто). </DD></DL>Любой символ может быть представлен 
определением значения кода в форматах: 
<uL>
  <li>восьмеричного числа \ddd, где ddd - значение кода символа (0...377). 
  <li>шестнадцатеричного числа \xdd, где dd - значение кода символа (0...ff). 
  </ul>
<p>Примеры символьных констант:<div class="code"><font color = "black"> 'А', '9', '$', '\n', '\072','\x6a'</font></div> 
<P><A name=REF_283><strong>Строковые</strong></A> константы - заключенная в кавычки 
последовательность символов кода ASCII. Во внутреннем представлении к 
строковойконстанте добавляется нулевой символ '\0', отмечающий конец строки. 
Примеры строковых констант: 
<P><div class="code"><font color = "black">"Система", "\n Аргумент %d\n", "Состояние \"WAIT\""</font></div> 
<P>Внутреннее представление строковой константы "01234\0ABCDEF" будет 
<P>'0','1','2','3','4','\0','A','B','C','D','E','F','\0' 
<P>
<P>
<P>
<HR SIZE=1 width="100%">

<A href="#REF_1_C">Начало</A>
<p> 

<div class="header"><CENTER><A name=REF_3></A>3. ОПЕРАТОРЫ И ВЫРАЖЕНИЯ </CENTER></div>
<P>
<div class="header"><A name=REF_3_1></A>3.1. Обзор операций языка С </div>
<P><strong>Операции</strong> - атомарные на уровне любого языка действия над операндами, 
приводящие к получению некоторого результата и возможному изменению состояния 
операнда. 
<P>В языке С можно выделить следующие группы операций:<BR>
<UL>
  <LI><A href="#REF_3_2">операции 
  присваивания;</A><BR>
  <LI><A href="#REF_3_3">арифметические 
  операции;</A><BR>
  <LI><A href="#REF_3_4">операции 
  отношений;</A><BR>
  <LI><A href="#REF_3_5">логические 
  операции;</A><BR>
  <LI><A href="#REF_3_6">операции над 
  битами;</A><B#REF_3_7">условное 
  вычисление;</A><BR>
  <LI><A href="#REF_3_8">определение размера 
  объекта по имени или типу;</A><BR>
  <LI><A href="#REF_3_9">операция приведения 
  типа;</A><BR>
  <LI><A href="#REF_3_10">последовательное 
  вычисление выражений;</A><BR>
  <LI><A href="#REF_3_11">операции над 
  указателями;</A><BR>
  <LI><A href="#REF_3_12">операция вызова 
  функции.</A><BR></LI></UL>
<P>

<div class="header"><A name=REF_3_2></A>3.2. Операции присваивания </div>
<P>Присваивание значения в языке C в отличие от традиционной интерпретации 
<P>идентификатор=выражение; 
<P>рассматривается как <STRONG>выражение</STRONG>, имеющее значение левого 
операнда после присваивания. <STRONG>Оператор присваивания</STRONG>, таким 
образом, может включать несколько операций присваивания и, как следствие, 
изменить значения нескольких операндов как побочный результат вычисления 
выражения: 
<P><PRE><div class="code">     int i,j,k;
     float x,y,z;
     char a,b;
     ...
     x=i+(y=3)-(z=0);  &lt;===&gt;  z=0; y=3; x=i+y-z;
     i=j=k=0;          &lt;===&gt;  k=0; j=k; i=j;
     a=(i+b);          &lt;===&gt;  a=i+b; /* Результат - ? */
</div></PRE>
<P>Очевидно, что в случае использования в выражении неодинаковых операций или 
разнотипных операндов возникают вопросы: 
<UL>
  <LI>порядок выполнения операций в выражении; 
  <LI>последовательность вычисления операндов; 
  <LI>корректность преобразования операндов. </LI></UL>Предварительные ответы: 
<OL>
  <LI>порядок выполнения операций можно определять круглыми скобками и(или) 
  учитывать их <STRONG>приоритет</STRONG>, а в случае одинакового приоритета - 
  <STRONG>направление</STRONG> выполнения каждой операции; 
  <LI>последовательность вычисления операндов большинства операций стандартом 
  языка С не регламентирована, а для коммутативных операций может 
  оптимизироваться компилятором даже при наличии круглых скобок; 
  <LI>корректность преобразования операндов гарантируется в рамках реальных 
  аппаратных возможностей, подозрительные ситуации стремится обнаружить 
  компилятор, а любые неопределенности устраняются явным использованием операции 
  <STRONG>приведения типа</STRONG> (см. 3.9). </LI></OL>Таким образом, 
конструирование выражений в языке С следует проводить с нетрадиционной для 
языков высокого уровня осторожностью. Из выделенных понятий только приоритет и 
направление выполнения операций стандартны в языке С, а остальные в общем случае 
являются системно зависимыми. Традиционная форма <STRONG>операции 
присваивания</STRONG> 
<P><div class="code"><font color = "black">v = e</font></div> 
<P>(здесь v - операнд-переменная, e - выражение). В языке C допускается две 
разновидности сокращений записи операции присваивания: 
<DL>
  <P>
  <DD>1) вместо записи 
  <P><div class="code"><font color = "black">v = v operator_ab e</font></div> 
  <P>рекомендуется использовать запись 
  <P><div class="code"><font color = "black">v operator_ab = e</font></div> 
  <P>(здесь operator_ab - арифметическая операция либо операция над битовым 
  представлением операндов); 
  <P></P>
  <DD>2) вместо записи 
  <P><div class="code"><font color = "black">ipv = ipv + 1</font></div> 
  <p>либо 
  <P><div class="code"><font color = "black">ipv = ipv - 1</font></div> 
  <P>рекомендуется использовать запись 
  <P><div class="code"><font color = "black">ipv++&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;либо&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ipv--,</font></div> 
  <P>а также 
  <p><div class="code"><font color = "black">++ipv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;либо&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--ipv</font></div> 
  <P>(здесь cимвол '+' обозначает операцию инкремента, cимвол '-' операцию 
  декремента, ipv - целочисленная переменная или переменная - указатель). 
  </P></DD></DL>Значением выражения ++x или --x является значение x после операции 
инкремента или декремента, а значением выражения x++ или x-- - значение x до 
операции (подробности операций над указателями см. ниже). Примеры использования 
сокращений: 
<P><PRE><div class="code">     int i,j,k;
     float x,y;
     ...
<P>

     x*=y;     &lt;===&gt;  x=x*y;
     i+=2;     &lt;===&gt;  i=i+2;
     x/=y+15;  &lt;===&gt;  x=x/(y+15);
     k--;      &lt;===&gt;  k=k-1;
     --k;      &lt;===&gt;  k=k-1;
     j=i++;    &lt;===&gt;  j=i; i=i+1;
     j=--i;    &lt;===&gt;  i=i-1; j=i;
</P></div></PRE>
<P>Рекомендации использования сокращений обоснованы возможностью оптимизации 
программы. Например, схема выражения вида 
<P><div class="code"><font color = "black">v operator_ab = e</font></div> 
<P>соответствует схеме выполнения многих машинных команд типа "регистр-память". 
Ограничения на целочисленность операндов операций вида ++ipv (--ipv) или ipv++ 
(ipv--) следуют из наличия машинных команд инкремента и декремента целочисленных 
операндов. Отметим, что левым операндом операции присваивания может быть только 
именованная либо косвенно адресуемая указателем переменная (в диагностических 
сообщения компилятора - LVALUE). Примеры недопустимых выражений: 
<DL>
  <P>
  <DD>а) присваивание константе: 
  <P><div class="code"><font color = "black">2=x+y getch()=i z=&amp;y /* z - имя массива */ </font></div>
  <P></P>
  <DD>б) присваивание результату операции: 
  <P><div class="code"><font color = "black">(i+1)=(j=2+y); (float)i=1.012</font></div> 
  <P></P></DD></DL>Элементы массивов адресуются косвенно (операции над указателями 
см. в 3.11), поэтому допустимы выражения 
<P><PRE><div class="code">     int area[];
<P>
     area[i]=log2(i);
     area[i]++;
     area[i]*=125;
</P></div></PRE>
<P>Особенность языка С: любые операции допускаются только со 
<STRONG>скалярными</STRONG> объектами, причем небольшого размера порядка размера 
регистров процессора. Это объясняется ориентацией языка на задачи системного 
программирования. Любые действия с громоздкими объектами - массивами, строками 
(частный случай массива), структурами реализуются посредством операции вызова 
функций. Например, рассмотрим сложные объекты 
<P><PRE><div class="code">     int x[100], y[100];
     char c[80];
     struct {
      int code;
      float data[1000];
     } s1, s2;
</div></PRE>
<P>Примеры правильной реализации операций присваивания для таких объектов: 
<uL>
  <P>
  <li>содержимое массива y присвоить содержимому массива x 
  <P><div class="code"><font color = "black">memcpy(x,y,sizeof(x));</font></div> 
  <P></P>
  <li>массиву с присвоить значение строки "0123456789" 
  <P><div class="code"><font color = "black">strcpy(c,"0123456789");</font></div> 
  <P></P>
  <li>содержимое структуры s2 присвоить содержимому структуры s1 
  <P><div class="code"><font color = "black">memcpy(&amp;s1,&amp;s2,sizeof(s1));</font></div> 
  <P></P></li></uL>Операции присваивания в стиле языка PL/1 или dBASE вида 
<P><div class="code"><font color = "black">x=y, c="0123456789", s1=s2</font></div> 
<P>в языке С интерпретируются как присваивание значений указателей на объекты. 
Здесь в левой части - константы, поэтому приведенные операции обнаружит как 
ошибочные компилятор. 
<P>

<div class="header"><A name=REF_3_3></A>3.3. Арифметические операции </div>
<P>Перечень арифметических операций в языке С и их обозначений: 
<DL>
  <DD>+ - сложение; 
  <DD>- - вычитание либо изменение знака; 
  <DD>/ - деление (при целочисленных операндах - с отбрасыванием остатка) ; 
  <DD>* - умножение; 
  <DD>% - остаток от деления целочисленных операндов со знаком первого операнда 
  (деление по модулю). </DD></DL>Как и в других языках высокого уровня, допустимым 
являются унарные операции (+ -). Операндами арифметических операций могут быть 
любые арифметические выражения. Тип выражений при необходимости приводится к 
более масштабному для обеспечения правильности результата. Обязательные 
преобразования даже однотипных операндов перед выполнением арифметических 
операции: 
<P><div class="code"><font color = "black">float --&gt; double; char, short --&gt; int.</font></div> 
<P>Необязательные преобразования разнотипных операндов: 
<P><div class="code"><font color = "black">int --&gt; unsigned --&gt;long --&gt; double.</font></div> 
<P>Единственной исключительной ситуацией при выполнении арифметических операций 
считается деление на нуль, а другие виды ситуаций (переполнение, исчезновение 
порядка или потеря значимости) игнорируются. Операции (* / %) обладают 
приоритетом над операциями (+ -), поэтому при записи сложных выражений можно 
использовать общепринятые математические правила: 
<P><div class="code"><font color = "black">x+y*z-a/b &lt;===&gt; x+(y*z)-(a/b)</font></div> 
<P>

<div class="header"><A name=REF_3_4></A>3.4. Операции отношений </div>
<P>Перечень операций отношений между объектами в языке С и их обозначения: 
<P>
<DL>
  <DD>== - равно или эквивалентно; 
  <DD>!= - не равно; 
  <DD>&lt; - меньше; 
  <DD>&lt;= - меньше либо равно; 
  <DD>&gt; - больше; 
  <DD>&gt;= - больше либо равно. </DD></DL>
<P>Символы пар символов {==,!=,&lt;=,&gt;=} разделять нельзя. 
<P>Общий вид операций отношений 
<P><div class="code"><font color = "black">&lt;выражение_1&gt; &lt;знак_операции&gt; &lt;выражение_2&gt;</font></div> 
<P>Операндами могут быть любые скалярные типы. Значения операндов после 
вычисления перед сравнением преобразуются к одному типу. Арифметические операнды 
преобразуются по правилам, аналогичным для арифметических операций. 
Операнды-указатели преобразуются в целые числа необходимого типа. Результат 
сравнения указателей будет корректным в арифметическом смысле лишь для объектов 
одного массива (операции над указателями см. в 3.11). Результат операции 
отношения - целое значение 1, если отношение истинно, или 0 в противном случае. 
Следовательно, операция отношения может использоваться в любых арифметических 
выражениях. 
<P>Примеры использования операций отношений: 
<P><PRE><div class="code">     y&gt;0
     x==y
     x!=2
     y=x*(z&gt;2)+(d==1);
</div></PRE>
<P>Рассмотрим примеры ошибочного использования операций отношений в 
синтаксически правильных выражениях. 
<P>ПРИМЕР 1. Попытка конструирования выражений в математическом стиле записи: 
<P><PRE><div class="code">     0&lt;x&lt;100  &lt;===&gt; (0&lt;x)&lt;100  &lt;===&gt; 1 /* Тавтология */
</div></PRE>
<P>Правильные варианты выражения: 
<P><PRE><div class="code">      0&lt;x &amp;&amp; x&lt;100
     (0&lt;x)&amp;&amp;(x&lt;100)
     (0&lt;x) * (x&lt;100)  /* Допустимо, но неэффективно */
</div></PRE>
<P>(символы &amp;&amp; обозначают операцию конъюнкции - см. 3.5). 
<P>ПРИМЕР 2. Попытка сравнения сложных объектов в различных областях памяти по 
их адресам: 
<P><div class="code"><font color = "black">char x[40]; x=="Фамилия" &lt;===&gt; 0</font></div> 
<P>Отношения между нескалярными объектами приходится проверять посредством 
последовательного сравнения их элементов. Удобно для этих целей воспользоваться 
библиотечными функциями. Например, требуемое выше сравнение строк символов можно 
записать в виде 
<P><div class="code"><font color = "black">strсмр(x,"Фамилия")</font></div> 
<P>(функция int strcmp(char *x,char *y) выполняет лексикографическое сравнение 
двух строк: нуль - совпадение строк, положительное число - признак "x&gt;y", 
отрицательное число - признак "x&lt;y"). 
<P>Сложные объекты можно рассматривать как массивы символов типа unsigned char. 
Сравнение массивов s1 и s2 символов такого типа длиной n байт выполняет функция 
<P><div class="code"><font color = "black">int memcmp(void *s1, void *s2, unsigned n),</font></div> 
<P>(результат формируется подобно функции strcmp). 
<P>Например, рассмотрим сложные объекты 
<P><PRE><div class="code">     int x[100], y[100];

     struct {
      int code;
      float data[1000];
     } s1, s2;
</div></PRE>
<P>Примеры правильной реализации операций сравнения для таких объектов: 
<P><div class="code">memcmp(x,y,sizeof(x)) - сравнение массивов x и y; 
memcmp(&amp;s1,&amp;s2,sizeof(s1)) - сравнение структур s1 и s2.</div> 
<P>Упомянутые библиотечные функции могут правильно выявлять эквивалентность 
содержимого полей памяти. Использование их для установления отношений порядка 
для арифметических данных (напр., "больше", "меньше") приведет к ошибке, если 
игнорировать внутреннее представление данных. Например, рассмотрим два числа: 
0x01020304l и 0x00000005l. Их представление в памяти ППЭВМ на основе 
микропроцессора 8086/808286 &lt;04030201&gt; и &lt;05000000&gt;. Функция memcmp 
при упрощенной интерпретации ее результата "установит", что первое число больше 
второго. 
<P>

<div class="header"><A name=REF_3_5></A>3.5. Логические операции </div>
<P>Перечень логических операций в языке С в порядке убывания от носительного 
приоритета и их обозначения: 
<P>
<DL>
  <DD>! - отрицание (логическое НЕТ); 
  <DD>&amp;&amp; - конъюнкция (логическое И); 
  <DD>|| - дизъюнкция (логическое ИЛИ). </DD></DL>
<P>Символы пар символов {||,&amp;&amp;} разделять нельзя. 
<P>
<P>Общий вид операции отрицания 
<P><div class="code"><font color = "black">!&lt;выражение&gt;</font></div> 
<P>Общий вид операций конъюнкции и дизъюнкции 
<P><div class="code"><font color = "black">&lt;выражение_1&gt;&lt;знак_операции&gt;&lt;выражение_2&gt;</font></div> 
<P>Операндами логической операции могут быть любые скалярные типы. Ненулевое 
значение операнда трактуется как "истина", а нулевое - "ложь". Результатом 
операции может быть 1 либо 0 целого типа. 
<P><div class="code"><font color = "black">!0 &lt;===&gt; 1 !5 &lt;===&gt; 0</font></div> 
<P><div class="code"><font color = "black">int x,y; x=10; !((x=y)&gt;0) &lt;===&gt; 0</font></div> 
<P>Относительный приоритет логических операций позволяет пользоваться 
общепринятым математическим стилем запмси сложных логических выражений. 
Например, выражение 
<P><div class="code"><font color = "black">!x &amp;&amp; (y&gt;0) || (z==1) &amp;&amp; (k&gt;0)</font></div> 
<P>эквивалентно следующему варианту выражения со скобками 
<P><div class="code"><font color = "black">((!x) &amp;&amp; (y&gt;0)) ||((z==1) &amp;&amp; (k&gt;0))</font></div> 
<P>Особенность операций конъюнкции и дизъюнкции - экономное последовательное 
вычисление выражений-операндов: 
<UL>
  <LI>если выражение_1 операции конъюнкции равно нулю, то результат операции - 
  нуль, а выражение_2 не вычисляется; 
  <LI>если выражение_1 операции дизъюнкции не равно нулю, то результат операции 
  - единица, а выражение_2 не вычисляется. </LI></UL>
<P>Таким образом, появляется возможность записью логического выражения задать 
условную последовательность вычисления выражений в направлении слева направо: 
<P>scanf("%d",&amp;i)&amp;&amp;test1(i)&amp;&amp;test2(i) - нулевой результат 
одной из функций приведет к игнорированию вызова остальных; 
<P>search1(x)||search2(x)||search3(x) - только ненулевой результат одной из 
функций приведет к игнорированию вызова остальных; 
<p>char *p=NULL; /* ... */ p 
&amp;&amp; p[0]=='*' - проверить первый элемент массива, если указатель на 
массив не пустой. 
<P>

<div class="header"><A name=REF_3_6></A>3.6. Операции над битами </div>
<P>Перечень операций над битами в языке С и их обозначения: 
<DL>
  <DD>~ - инвертирование (одноместная операция); 
  <DD>&amp; - конъюнкция; 
  <DD>| - дизъюнкция; 
  <DD>^ - исключающее ИЛИ (сложение по модулю 2); 
  <DD>&gt;&gt; - сдвиг вправо; 
  <DD>&lt;&lt; - сдвиг влево. </DD></DL>Символы пар символов {&gt;&gt;,&lt;&lt;} 
разделять нельзя. 
<P>Общий вид операции инвертирования 
<P><div class="code"><font color = "black">~&lt;выражение&gt;</font></div> 
<P>Остальные операции над битами имеют вид 
<P><div class="code"><font color = "black">&lt;выражение_1&gt;&lt;знак_операции&gt;&lt;выражение_2&gt;</font></div> 
<P>Операндами операций над битами могут быть только выражения, приводимые к 
целому типу. Операции {~,&amp;,|,^} выполняются поразрядно над всеми битами 
операндов (знаковый разряд особо не выделяет ся): 
<P><PRE><div class="code">          ~ 0xF0 == 0x0F
     0xFF &amp; 0x0F == 0x0F
     0xF0 | 0x11 == 0xF1
     0xF4 ^ 0xF5 == 0x01
</div></PRE>
<P>Операции сдвига выполняются также для всех разрядов с потерей выходящих за 
границы битов: 
<P><PRE><div class="code">     0x8001&lt;&lt;1 == 0x0002
     0x8001&gt;&gt;1 == 0x4000
</div></PRE>
<P>Если "выражение_1" имеет тип unsigned, то при сдвиге вправо освобождающиеся 
разряды гарантированно заполняются нулями (логический сдвиг). Выражения типа 
signed могут, но не обязательно, сдвигаться вправо с копированием знакового 
разряда (арифметический сдвиг). При сдвиге влево освобождающиеся разряды всегда 
заполняются нулями. Если "выражение_2" отрицательно либо больше длины 
"выражения_1" в битах, то результат операции сдвига не определен и является 
системно зависимым. Операции сдвига вправо на k разрядов весьма эффективны для 
деления, а сдвиг влево - для умножения целых чисел на 2**k: 
<P><PRE><div class="code">     x&lt;&lt;1  &lt;===&gt; x*2
     x&gt;&gt;1  &lt;===&gt; x/2
     x&lt;&lt;3  &lt;===&gt; x*8
</div></PRE>
<P>Подобное применение операций сдвига безопасно для беззнаковых и положительных 
значений "выражения_1". Для ППЭВМ на базе микропроцессоров типа 8086/80286 
выигрыш во времени выполнения составляет 10...90 раз. Двухместные операции над 
битами (&amp;,|,^,&lt;&lt;,&gt;&gt;) могут использоваться в сокращенных формах 
записи операции присваивания: 
<P><PRE><div class="code">int i,j,k; ... 
<P>i|=j &lt;===&gt; i=i|j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Включение в поле i единиц из поля j */  
<P>
<P>i&amp;=0xFF &lt;===&gt; i=i&amp;0xFF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Выделение в поле i единиц по маске поля 0x00FF */ 
<P> 
<P>k^=j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Выделение в поле k отличающихся разрядов в полях k и j */ 
<P> 
<P>i^=i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Обнуление всех разрядов поля i */
</div></PRE> 
<P>Операции над битами реализуются, как правило, одной машинной командой и 
рекомендуются для использования во всех подходящих случаях. В математическом 
смысле операнды логических операций над битами можно рассматривать как 
отображение некоторых множеств с размерностью не более разрядности операнда на 
значения {0,1}. Пусть единица означает обладание элемента множества некоторым 
свойством, тогда очевидна теоретико-множественная интерпретация рассматриваемых 
операций: 
<P><div class="code"><font color = "black">~ - дополнение; | - объединение; &amp; - пересечение.</font></div> 
<P>Простейшее применение - проверка нечетности целого числа: 
<P><div class="code"><font color = "black">int i; ... if (i&amp;1) printf("значение i четно!");</font></div> 
<P>Комбинирование операций над битами с арифметическими операциями часто 
позволяет упростить выражения. Например, получение размера области в параграфах 
размером 16 байт для размещения объекта размером x байт: 
<P><div class="code"><font color = "black">(x+15)&gt;&gt;4</font></div> 
<P>Другие возможности оперирования над битами: 
<UL>
  <LI>использование структур с битовыми полями (см. 2.5); 
  <LI>доступ к битам как разрядам арифметических данных. </LI></UL>Например, байт 
атрибута символов, выводимых на экран в текстовом режиме работы дисплея, имеет 
структуру: 
<P><PRE><div class="code">     struct attr {
      unsigned m:1; /* Признак мерцания символа */
      unsigned b:3; /* Цвет фона */
      unsigned f:4; /* Цвет символа */
     };
</div></PRE>
<P>Содержимое байта атрибута можно определить выражением: 
<P><PRE><div class="code">     int bl; /* Признак мерцания символа */
     int bg; /* Цвет фона */
     int fg; /* Цвет символа */

     bg*16+fg+128*(bl&gt;0)
</div></PRE>
<P>

<div class="header"><A name=REF_3_7></A>3.7. Условное вычисление </div>
<P>Вид записи операции: 
<P><div class="code"><font color = "black">условие? выражение_1:выражение_2</font></div> 
<P>Результат операции - значение "выражения_1", если выражение "условие" отлично 
от нуля, иначе - значение "выражения_2". Условное вычисление применимо к 
арифметическим операндам или операндам-указателям: 
<P><PRE><div class="code">     int a,x;
     x=(a&lt;0)? -a: a
     printf("Значение %d %sнулевое !",x,x? "не":"");
</div></PRE>
<P>Отличительная особенность операции условного вычисления последовательное 
вычисление сначала выражения-условия, а затем выражения_1 или выражения_2. 
<P>Другая особенность операции условного вычисления - возможность использования 
результата операции в левой части оператора присваивания: 
<p><PRE><div class="code">#include "stdio.h"

int main(int argc, char* argv[])
{
 int i=1, j=2, k=3;

 (i&gt;0? j : k )=0;
 printf("\n i=%d, j=%d, k=%d",i,j,k);
 (i&gt;0? j : k )++;
 printf("\n i=%d, j=%d, k=%d",i,j,k);
 return 0;
}
</div></PRE>
<P>

<div class="header"><A name=REF_3_8></A>3.8. Определение размера объекта </div>
<P>Операция определения размера объекта требуется, например, на этапе 
программного управления памятью. Виды записи операции: 
<P><PRE><div class="code">     sizeof выражение
     sizeof(тип)
</div></PRE>
<P>Частным случаем выражения является имя объекта. Результат операции - число 
байт для размещения объекта с указанным именем либо заданного типа: 
<P><PRE><div class="code">     sizeof(int) /* Длина поля данных типа int */
     sizeof(a)   /* Длина поля объекта a */
     sizeof(2+3) /* Длина поля хранения результата суммирования */
</div></PRE>
<P>Операция sizeof - операция этапа компиляции. По существу, она является 
специальным обозначением константы типа unsigned int. Очевидно, что операция 
sizeof не может быть в левом операндом операции присваивания. Одно из полезных 
применений операции sizeof - определение количества элементов массива с 
объявленной размерностью: 
<P><PRE><div class="code">     char s[111];
     ...
     sizeof(s)/sizeof(*s) /* Количество элементов массива s */
</div></PRE>
<P>(применение подобного подхода для многомерных массивов рассмотрено в 3.11). 
Наиболее часто операция sizeof применяется при динамическом распределении 
памяти: 
<P><PRE><div class="code">     float *x; /* Указатель массива */
     int n;    /* Количество элементов массива */
<P>
     /* Захват и очистка памяти */
<P>
     x=calloc(n,sizeof(*x));
</P></div></PRE>
<P>Следует учитывать, что размер структуры при учете компилятором правил 
выравнивания адресов ее элементов может оказаться больше суммы размеров 
элементов. По этой причине планирование размещения в памяти составных объектов 
следует проводить на основе обращения к операции sizeof c именем объекта. 
Например, пусть требуется определить размер буфера для размещения различных 
структур данных: 
<P><PRE><div class="code">     struct s1 { ... };
     struct s2 { ... };
     ...
     struct sn { ... };
</div></PRE>
<P>Определив вспомогательный тип 
<P><PRE><div class="code">     union buffer {
      struct s1 x1;
      struct s2 x2;
      ...
      struct sn xn;
     };
</div></PRE>
<P>легко получить размер буфера: sizeof(union buffer); 
<P>

<div class="header"><A name=REF_3_9></A>3.9. Операция приведения типа </div>
<P>Вид записи операции: 
<P><div class="code"><font color = "black">(тип)выражение</font></div> 
<P>Ее результат - значение "выражения", преобразованное к заданному типу 
представления. Операция приведения типа вынуждает компилятор согласиться с 
выполнением указанного преобразования, но ответственность за последствия 
возлагается на программиста. Рекомендуется использовать эту операцию в 
исключительных случаях. Рассмотрим примеры таких случаев. 
<P>Ранее отмечалось, что результат арифметической операции в математическом 
отношении будет корректным в рамках конкретных аппаратных возможностей. 
Например: 
<P><PRE><div class="code">     unsigned char x=150, y=128;
     unsigned char z=x+y;         // z!=150+128
</div></PRE>
<P>Ошибка, появляющаяся здесь в операции присваивания, устраняется 
использованием другого типа поля для сохранения результата: 
<P><PRE><div class="code">     int  a;                // a==150+128
     a=x+y;                 // a==150+128
</div></PRE>
<P>Пример оправданного приведения типа: 
<P><PRE><div class="code">     float x;
     int n,l;
     ...
     x=(float)(n+l)/3;
</div></PRE>
<P>Использование операции приведения здесь позволяет избежать округления 
результата деления целочисленных операндов, т.к. после преобразования одного из 
операндов к типу float все операнды будут автоматически приведены к типу double. 
Корректными и прогнозируемыми являются операции сложения и вычитания над парами 
операндов (указатель_объекта_типа_X - арифме тическое_значение), а также 
вычитания указателей объектов одного массива). Потребность в операции приведения 
возникает в случае появления неопределенности типа операнда и при необходимости 
обхода запретов языка на комбинации операндов. Неопределенность типа операнда 
возникает, например, при передаче значения аргумента функции при отсутствии в ее 
описании описания списка параметров. Компилятор предупреждает программиста о 
подобных ситуациях, но иногда неопределенность порождена отсутствием достаточной 
информации. 
<P>Пример неопределенности связи параметров: 
<P><PRE><div class="code">     #include &lt;stdio.h&gt;
<P>
     void main() {
      float f=125.0;
<P>
     /* Надежда на интеллект компилятора */
<P>
      printf("\n??? %f %d %x %f",f,f,f,f);
<P>
     /* На компилятор надейся, но приводи тип в соответствие */
<P>
      printf("\n*** %f %d %x %f",f,(int)f,(int)f,f);
     }
</P></div></PRE>
<P>Результаты работы программы: 
<P><PRE>     ??? 125.000000 0 0 0.000000
     *** 125.000000 125 7d 125.000000
</PRE>
<P>
<P>Примеры запрещенных видов операции присваивания: 
<P><ul>
<li>указатель=арифметическое_значение;
<li>арифметическая_переменная=указатель;
<li>указатель_объекта_типа_1=указатель_объекта_типа_2, если 
(тип_1!=тип2)&amp;&amp;(тип_1!=void)&amp;&amp;(тип_2!=void). </ul>
<P>Многие задачи системного и прикладного программирования вынуждают 
использовать перечисленные операции. При этом приходится непосредственно 
сталкиваться с особенностями реализации вычислительной среды, а программы легко 
теряют свойство мобильности. Например, пусть необходимо получить доступ к 
видеопамяти текстового режима работы дисплея по известному адресу 0xb8000 для 
видеоадаптеров CGA, EGA или VGA ПЭВМ класса IBM PC/XT/AT: 
<P><PRE><div class="code">/* Правильный вариант описания видеопамяти */
<P>
     struct item {
      char byte; // отображаемый символ
      char attr; // атрибуты отображения
     } *screen_pointer=(struct item far *)MK_FP(0xb800,0);
</P></div></PRE>
<P>Здесь учтены: формат элемента видеопамяти; невозможность относительной 
адресации видеопамяти в сегментах программы пользователя ("близкими" указателями 
с атрибутом near); использование уникального способа представления "далекого" 
(far) указателя и т.д. 
<P>Игнорирование, например, последнего фактора приведено в синтаксически 
правильном операторе<p><PRE><div class="code"><font color = "black">
     screen_pointer=(struct item far *)0xb8000l;
</P></div></PRE>
<P>Попытка после этого очистить поле экрана 
<P><PRE><div class="code"><font color = "black">     for (int i=0; i&lt;2000; screen_pointer[i++].byte=' ');
</div></PRE>
<P>закончится крахом системы. Способ представления далеких указателей в системах 
программирования С и С++ фирмы Borland определен макрокомандой 
<P><PRE><div class="code"><font color = "black">     #define MK_FP(seg,ofs) \((void far *)(((unsigned long)(seg)&lt;&lt;16)|(unsigned)(ofs)))
</div></PRE>
<P>Результат преобразования объекта, не являющегося указателем, не может быть 
LVALUE, поэтому значение ему присваивать нельзя. Для указателя же допустимым 
является выражение 
<P>/* Правильный вариант установки указателя видеопамяти */ 
<P><PRE><div class="code"><font color = "black">     (unsigned long)screen_pointer=0xb8000000l;
</div></PRE>
<P>Подобные операции характерны для системного программирования, но при этом 
желательно максимально использовать высокоуровневые лингвистические конструкции 
(см. первоначальный вариант). 
<P>Явное приведение типов указателей позволяет получить адрес объекта любого 
типа: 
<P><PRE><div class="code"><font color = "black">     any_type* p;
<P>
     p=(any_type*)&amp;some_object;
</P></font></div></PRE>
<P>Известное значение указателя p позволяет работать с некоторым объектом 
some_object как объектом типа any_type: <P><PRE><div class="code">
   /* Пример программы печати представления числа типа long */
<P>
#include &lt;stdio.h&gt;
<P>
   long x=0xB8000000l;
   unsigned char *c;
<P>
   void main () {
    int i;
<P>
    c=(char *)&amp;x;
    for (i=0; i&lt;sizeof(x); i++)
     printf(" %02x",c[i]);
   }
</P></div></PRE>
<P>Результат работы программы: 
<P><PRE><div class="code"><font color = "black">    00 00 00 b8
</font></div></PRE>
<P>Явного преобразования типов рекомендуется, по возможности, из бегать. 
Появление неожиданных результатов операций во внешне правильных выражениях и 
исходных данных - сигнал для анализа и коррекции хода преобразований. 
Рекомендуется максимально использовать стандартные библиотечные функции и 
макрокоманды. 
<P>

<div class="header"><A name=REF_3_10></A>3.10. Последовательное вычисление выражений 
</div>
<P>Вид записи операции: 
<P><div class="code"><font color = "black">e1, e2, ..., eN</font></div> 
<P>Смысл операции - гарантированно последовательно вычисляются выражения e1... 
eN, а результат операции - значение выражения eN. 
<P>Пример: 
<P><PRE><div class="code">m=(i=1, j=i++, k=0, l=i+j); /* i=1; j=i++; k=0; l=i+j; m=l; */</div>
</PRE>
<P>
<div class="header"><A name=REF_3_11></A>3.11. Операции над указателями </div>
<P>Обращение к объектам любого типа как операндам операций в языке C может 
проводиться как по имени так и по указателю. Использование в исходном тексте 
операции косвенной адресации, записываемой в виде 
<P><div class="code"><font color = "black">*указатель_объекта</font></div> 
<P>позволяет получить доступ к полю объекта, адрес которого - 
"указатель_объекта". Значение адреса объекта указателю можно присвоить, 
например, используя операцию определения адреса, вид записи которой 
<P><div class="code"><font color = "black">&amp;идентификатор_объекта</font></div> 
<P>(здесь в качестве объекта нельзя использовать битовые поля структур или 
объединений, а также объекты с атрибутом класса памяти register). Пример 
идентификации объектов: 
<P><PRE><div class="code">      int i,  /* Переменная типа int */
          *x; /* Указатель на элемент данных типа int */
<P>
      x=&amp;i;  /* x &lt;- адрес переменной i */
      *x=1;  /* Косвенная адресация указателем поля i */
</P></div></PRE>
<P>Говорят, что использование указателя означает отказ от именования 
(разыменование) адресуемого им объекта: 
<P><PRE><div class="code">      int i,j,k, *x;
      x=&amp;i;
      *x=0;    /* i=0;  */
      x=&amp;j;
      *x+=i;   /* j+=i; */
      x=&amp;k;
      k+=*x;   /* k+=k; */
      (*x)++;  /* k++;  */
</div></PRE>
<P>Отказ от именования объектов при наличии возможности доступа по указателю 
приближает язык С по гибкости отображения "объект память" к языку ассемблера. 
При вычислении адресов объектов следует учитывать, что идентификатор массива и 
функции именует переместимую адресную константу(термин ассемблера) - константу 
типа указатель (термин языка C). Такую константу можно присвоить переменной типа 
указатель, но нельзя подвергать преобразованиям: 
<P><PRE><div class="code">      int x[100], *y;
      void getsn(), (*proc)();
<P>
      y=x;        /* Присваивание константы переменной */
      proc=getsn;
      /* ... */
      x=y;    /* Ошибка: в левой части - указатель-константа */
</P></div></PRE>
<P>Указателю-переменной можно присвоить значение другого указателя либо 
выражения типа указатель с использованием при необходимости операции приведения 
типа (приведение необязательно, если один из указателей имеет тип "void *"). 
<P><PRE><div class="code">      int i,*x;
      char *y;
<P>
      x=&amp;i;             /* x --&gt; поле типа int */
      y=(char *)x;      /* y --&gt; поле типа char */
      y=(char *)&amp;i;     /* y --&gt; поле типа char */
</P></div></PRE>
<P>Указатель может использоваться в выражениях вида 
<P><PRE><div class="code"><font color = "black">      p+ie, p-ie,
      ++p, --p,
      p++, p--,
      p+=ie, p-=ie,
</font></div></PRE>
<P>где p - указатель, ie - целочисленное выражение. Значение таких выражений - 
увеличенное или уменьшенное значение указателя на величину ie*sizeof(*p). 
Текущее значение указателя всегда ссылается на позицию некоторого объекта в 
памяти с учетом правил выравнивания для соответствующего типа данных. Таким 
образом, значение p [+|-] ie указывает на объект того же типа, расположенный в 
памяти со смещением на [+|-] ie позиций: 
<P><PRE><div class="code">#include &lt;stdio.h&gt;
void main() {
 int i;
 double *pd;
 char *pc;
 int  *pi;
 struct test {
  int x[10];
  char b[83];
  float c[15];
 } *ps;
 pd=(double *)&amp;i;
 pc=(char   *)&amp;i;
 pi=(int    *)&amp;i;
 ps=(struct test *)&amp;i;
 printf("\n pd %p %p %p %d",pd,pd+1,pd-1,sizeof(*pd));
 printf("\n pc %p %p %p %d",pc,pc+1,pc-1,sizeof(*pc));
 printf("\n pi %p %p %p %d",pi,pi+1,pi-1,sizeof(*pi));
 printf("\n ps %p %p %p %d",ps,ps+1,ps-1,sizeof(*ps));
}
</div></PRE>
<P>Результаты работы программы: 
<P><PRE><div class="code"><font color = "black"> pd 0FD0 0FD8 0FC8 8
 pc 0FD0 0FD1 0FCF 1
 pi 0FD0 0FD2 0FCE 2
 ps 0FD0 1073 0F2D 163
</font></div></PRE>
<P>Как следствие, разрешается сравнивать указатели и вычислять разность двух 
указателей. При сравнении могут проверятся отношения любого вида 
("&gt;","&gt;=","&lt;","&lt;=","==","!="). Наиболее важными видами проверок 
являются отношения равенства или неравенства. Отношения порядка имеют смысл 
только для указателей на последовательно размещенные объекты (элементы одного 
массива). Разность двух указателей дает число объектов адресуемого ими типа в 
соответствующем диапазоне адресов. Очевидно, что уменьшаемый и вычитаемый 
указатель также должны соответствовать одному массиву, иначе результат операции 
не имеет практической ценности. Любой указатель можно сравнивать со значением 
NULL, которое означает недействительный адрес. Значение NULL можно присваивать 
указателю как признак пустого указателя. NULL заменяется препроцессором на 
выражение (void *)0 (см. 6.2). Рассмотрим связь указателей и массивов. Пусть 
объявлены: 
<P><PRE><div class="code">     type p[100]; /* Массив 100 последовательно
                размещенных объектов типа type */
     type *q;     /* Указатель на объект типа type */
     int i;       /* Индекс элемента */
</div></PRE>
<P>Обращение к элементу массива в языке С возможно в традиционном для многих 
других языков стиле записи операции обращения по индексу (элементы массива 
нумеруются 0,1,...) : 
<P><PRE><div class="code">     p[0]=1; /* Первый элемент массивов имеет нулевой индекс */
     p[i]++; /* Инкремент элемента массива */
     p[3]=p[i]+p[i+1]; /* Ограничений на доступ к массиву нет */
</div></PRE>
<P>Если выполнен оператор 
<P><pre><div class="code">     q=p; /* Присваивание константы переменной */</div></pre> 
<P>то из раннее сказанного следует, что выражения p[i] и *(q+i) приводят к 
одинаковым результатам. Учитывая, что p и q - указатели, легко догадаться, что в 
языке С выражения p[i] и *(p+i) эквивалентны. Отсюда следует, что операция 
обращения к элементу массива по индексу применима и при его именовании 
указателем-переменной. Таким образом, для любых указателей можно использовать 
две эквивалентые формы выражений для доступа к элементам массива: q[i] и *(q+i). 
Первая форма удобнее для читаемости текста. Дополнительно отметим, что в языке С 
с целью повышения быстродействия программы отсутствует механизм контроля границ 
изменения индексов массивов. При необходимости такой механизм должен быть 
запрограммирован явно. Рассмотрим некоторые важные для практического 
программирования следствия. 
<P><strong>Следствие 1.</strong> Очевидна эквивалентность выражений 
<P><PRE><div class="code">     &amp;q[0] &lt;===&gt;&amp;(*q) &lt;===&gt; q
<P>
     *q &lt;===&gt; q[0]
</P></div></PRE>
<P>Последнее выражение объясняет правильность выражения для получения количества 
элементов массива с объявленной размерностью: 
<P><PRE><div class="code">     type x[100]; /* Размерность должно быть константой */
     ...
     int n=sizeof(x)/sizeof(*x);  /* n &lt;-- 100 */
</div></PRE>
<P><strong>Следствие 2.</strong> В языке С размерность массива при объявлении должна задаваться 
константным выражением. При необходимости работы с массивами переменной 
размерности вместо массива достаточно объявить указатель требуемого типа и 
присвоить ему адрес свободной области памяти. Библиотечные функции для получения 
памяти, ее освобождения и оценки размера остатка памяти описаны в файле alloc.h. 

<P><PRE><div class="code">/* Пример создания динамического массива */
<P>
     float *x;
     int    n;
     ...
     while (printf("\nРазмерность - ? "), !scanf(" %d",&amp;n));
<P>
     if ((x=calloc(n,sizeof(*x)))!=NULL) {
      printf("\nМассив создан и очищен!");
      ...
      for (i=0; i&lt;n; i++)
       printf("\n%f",x[i]);
      ...
      free(x); /* Освобождение памяти */
     } else {
      printf("\nПредел размерности %d",coreleft()/sizeof(*x));
      exit(1);
     }
</P></div></PRE>
<P><strong>Следствие 3.</strong> Ранее отмечалось, что строковые константы в памяти 
представляются массивом символов, дополненным символом конца строки '\0'. Отсюда 
следует допустимость выражений: 
<P><PRE><div class="code">     char *x;
     ...
     x="МРТИ";
     x=(i&gt;0)? "положительное":(i&lt;0)? "отрицательное":"нулевое";
</div></PRE>
<P>Сказанное относительно связи указателей и массивов с одним измерением 
справедливо и для массивов с большим числом измерений. Например, рассмотрим 
двумерный массив 
<P><pre><div class="code">     type name[5][10];</div></pre> 
<P>Если рассматривать его как массив пяти массивов размерностью по десять 
элементов каждый, то очевидна схема его размещения в памяти - последовательное 
размещение "строк". Обращению к элементам name[i][j] соответствует эквивалентное 
выражение 
<P><pre><div class="code">     *(*(name+i)+j),</div></pre> 
<p>а интерпретация такого массива указателем переменной выглядит 
в форме 
<P><PRE><div class="code">     type **pname;
</div></PRE>
<P>Таким образом, имя двумерного массива - имя указателя на указатель. 
Аналогичным образом можно установить соответствие между указателями и массивами 
с произвольным числом измерений: 
<P><PRE><div class="code">     type name[][][][]; &lt;===&gt; type ****pname;
</div></PRE>
<P>В последнем случае эквивалентными являются выражения: 
<P><PRE><div class="code">     name[i][j][k][l]
     *(*(*(*(name+i)+j)+k)+l)
     *(*(*(name+i)+j)+k)[l]
     *(*(name+i)+j)[k][l]
     *(name+i)[j][k][l]
</div></PRE>
<P>Приведем пример программы конструирования массива массивов: 
<P><PRE><div class="code">#include &lt;stdio.h&gt;
<P>
int x0[3]={ 1, 2, 3};    /********************************/
int x1[3]={11,12,13};    /*  Декларация и инициализация  */
int x2[3]={21,22,23};    /*     массивов целых чисел     */
int x3[3]={31,32,33};    /********************************/
<P>
int *y[4]={x0,x1,x2,x3}; /* Создание массива указателей  */
<P>
void main() {
 int i,j;
<P>
 for (i=0; i&lt;4; i++) {
  printf("\n %2d)",i);
  for (j=0; j&lt;3; j++)
   printf(" %2d",y[i][j]);
 }
}
</P></div></PRE>
<P>Результаты работы программы: 
<P><PRE><div class="code"><font color = "black">  0)  1  2  3
  1) 11 12 13
  2) 21 22 23
  3) 31 32 33
</font></div></PRE>
<P>Такие же результаты будут получены и следующей программой: 
<P><PRE><div class="code">#include &lt;stdio.h&gt;
<P>
int z[4][3]={{ 1, 2, 3},   /********************************/
             {11,12,13},   /*  Декларация и инициализация  */
             {21,22,23},   /* массива массивов целых чисел */
             {31,32,33}    /********************************/
             };
<P>
void main() {
 int i,j;
<P>
 for (i=0; i&lt;4; i++) {
  printf("\n %2d)",i);
  for (j=0; j&lt;3; j++)
   printf(" %2d",z[i][j]);
 }
}
</P></div></PRE>
<P>В последней программе массив указателей на массивы создается компилятором. 
Здесь собственно данные массива располагаются в памяти последовательно по 
строкам, что является основанием для декларации массива z в виде: 
<P><PRE><div class="code">int z[4][3]={  1, 2, 3, /********************************/
              11,12,13, /*  Декларация и инициализация  */
              21,22,23, /* массива массивов целых чисел */
              31,32,33  /********************************/
            };
</div></PRE>
<P>Замена скобочного выражения z[4][3] на z[12] здесь не допускается, так как 
массив указателей не будет создан. Таким образом, использование многомерных 
массивов в языке С связано с накладными расходами памяти на массивы указателей 
(этот недостаток в современных версиях устранен). Можно избежать таких расходов, 
если ввести адресную функцию для доступа к элементам одномерного массива по 
значениям индексов многомерного массива. Например, функция вывода двумерного 
массива произвольной размерности в стиле рассмотренных выше примеров имеет вид: 
<P><PRE><div class="code">print(int *array, int N_row, int N_col) {
 int i,j;
<P>
 for (i=0; i&lt;N_row; i++) {
  printf("\n %2d)",i);
  for (j=0; j&lt;N_col; j++)
   printf(" %2d",array[N_col*i+j]);
 }
}
</P></div></PRE>Нетрудно заметить, что после объявления многомерного массива, 
например, в виде 
<P><PRE><div class="code">     type s[10][5][3];
</div></PRE>
<P>синтаксически правильными будут выражения: 
<P><PRE><div class="code">     s[i]       &lt;===&gt;  *(s+i)           &lt;===&gt; &amp;s[i][0]
     s[i][j]    &lt;===&gt;  *(*(s+i)+j)      &lt;===&gt; &amp;s[i][j][0]
     s[i][j][k] &lt;===&gt;  *(*(*(s+i)+j)+k)
</div></PRE>
<P>Отсутствие контроля за значениями индексов влечет допустимость выражений 
<P><pre><div class="code"><font color = "black">     s[1][-2][4]</font></div></pre> 
<P>Отсюда следует, что ни количество измерений массива, ни диапазон значений 
индекса по отдельному измерению в языке С не контролируются, а имена массива и 
указателя на данные часто взаимозаменяемы. 
<P>Декларация массива перекладывает операции распределения памяти на компилятор 
(см. 5.3). К любым компонентам многомерного массива применима операция sizeof: 
<P><PRE><div class="code">int s[10][5][3];
<P>
    /* Истинные выражения:
<P>
       sizeof(s)==300
       sizeof(*s)==30
       sizeof(**s)==6
       sizeof(***s)==2
       sizeof(s)/sizeof(*s)==10
       sizeof(*s)/sizeof(**s)==5
       sizeof(**s)/sizeof(***s)==3
<P>
     */
</P></div></PRE>
<P>Здесь компилятор полностью осведомлен об интерпретации операндов. В случае 
косвенной ссылки на существующий массив, например, после записи оператора 
<P><div class="code">int ***t=s;</div> 
<P>синтакcически правильным будет только выражение sizeof(t). Указатели 
позволяют: 
<UL>
  <LI>работать с массивами переменной размерности и другими сложными структурами 
  данных; 
  <LI>заменить пересылку данных большого размера изменением значения указателя. 
  </LI></UL>
<P>

<div class="header"><A name=REF_3_12></A>3.12. Операция вызова функции </div>
<P>Операция вызова функции в общем случае требует наличия в файле исходного 
текста декларации функции в форме определения или описания. При отсутствии 
декларации функции предполагается, что вызывается функция, возвращающая значение 
типа int. 
<P>Определение функции как процедурного модуля включает: 
<DL>
  <DD>а) тип результата; 
  <DD>б) идентификатор (указатель-константа); 
  <DD>в) список формальных параметров c описанием их типов; 
  <DD>г) составной оператор (блок), представляющий выполняемые функцией 
  действия. </DD></DL>
<P>Пример определения функции: 
<P>а) классический [9] формат записи <PRE><div class="code">                               ----------------------------------
     int poly2(a,b,c,x)
      int a;                      Заголовок функции
      int b;
      int c;
      int x;
     {                         ----------------------------------
      return (c+x*(b+x*a));       Тело функции
     }                         ----------------------------------
</div></PRE>
<P>б) современный формат записи (стандарт языка C++) 
<P><PRE><div class="code">     int poly2(int a, int b, int c, int x) {
      return (c+x*(b+x*a));
     }
</div></PRE>
<P>Описание функции используется лишь для уведомления компилятора о том, что 
функция определена позднее в текущем или другом файле исходного текста либо 
находится в библиотеке. Формы описания приведенного примера функции: 
<DL>
  <DD>а) классический формат записи - тип результата, идентификатор и круглые 
  скобки 
  <P><PRE><div class="code">     int poly2();
</div></PRE>
  <P></P>
  <DD>б) современный формат записи - классический формат дополнен списком типов 
  параметров с необязательными идентификаторами параметров: 
  <P><PRE><div class="code">     int poly2(int a, int b, int c, int x);
     int poly2(int, int, int, int);
</div></PRE>
  <P></P></DD></DL>Описание (прототип) функции в современных системах 
программирования позволяет улучшить диагностику правильности ее вызова и 
выполнить преобразования параметров. Наличие определения функции делает излишним 
запись описания в остатке файла исходного текста. Функция, которая не возвращает 
значения, должна описываться как имеющая тип void. Способы вызова функции 
<P>а) вызов по имени 
<P><div class="code">имя_функции(e1,e2,...eN)</div> 
<P>б) вызов по указателю 
<P><div class="code">(*указатель_на_функцию)(e1,e2,...eN)</div> 
<P>Здесь e1,e2,... eN - выражения, определяющие значения аргументов (фактических 
параметров). Порядок вычисления выражений перед вызовом не регламентирован. 
Список аргументов может быть пустым, но круглые скобки опускать в этом случае 
нельзя. Указатель_на_функцию - переменная, содержащая адрес функции, которая 
декларируется, напр., в виде 
<P><div class="code">тип_функции (*указатель_на_функцию)();</div> 
<P>Адрес функции присваивается указателю оператором 
<P><div class="code">указатель_на_функцию = имя_функции;</div> 
<P><div class="code">(имя_функции - указатель_константа).</div> 
<P>Результат операции вызова функции определяется типом возвращаемого функцией 
результата в ее описании. Операция вызова функций, не возвращающих значений, 
может применяться только в операторе вызова функции в форматах: 
<P><div class="code">имя_функции(e1,e2,...eN); (*указатель_на_функцию)(e1,e2,...eN);</div> 
<P>Другие функции могут использоваться в любых выражениях: 
<P><PRE><div class="code">     int getchar();
     ...
     i=getchar(); /* Ввод символа */
     ...
     getchar();   /* Ожидание нажатия любой клавиши */
</div></PRE>
<P>Синтаксис записи списка аргументов совпадает с синтаксисом операции 
последовательного вычисления выражений. Конфликт устраняется использованием 
круглых скобок: ... printf("\n %d",(x=(i==1), i++)); 
<P>Проверка числа и типа аргументов, переданных функции, а также типа 
возвращаемого значения во время выполнения не производится. Предполагается, что 
тип возвращаемого функцией результата совпадает с объявленным в ее описании. 
Аргументы (фактические параметры) функций в языке C всегда передаются по 
значению. Преобразование параметров в теле функции не вызывает изменения полей 
аргументов в вызывающей функции. 
<P>Особенности использования параметров функций: 
<UL>
  <LI>при необходимости изменения функцией некоторого поля небходимо 
  использовать в качестве параметра указатель соответствующего типа; 
  <LI>массивы (функции) всегда адресуются косвенно, т.е. имя массива - 
  указатель-константа, использование которого в качестве параметра позволяет 
  получить доступ к любому элементу массива; 
  <LI>способ адресации производных типов данных (структуры, объединения и их 
  массивы) зависит от реализации транслятора языка C, поэтому для обеспечения 
  переносимости программ рекомендуется использовать в качестве параметра 
  указатель таких типов данных. </LI></UL>
<P><PRE><div class="code">     int i;              /* Пример функции ввода данных */
     scanf("%d",&amp;i);     /* *************************** */
</div></PRE>
<P>функция может вызываться рекурсивно, причем глубина рекурсии ограничивается 
только объемом доступной памяти для раззмещения переменных в динамической 
(стековой) памяти. <PRE><div class="code">#include <STDIO.H>

void trans(register int x) {
 if (x) {
  trans(x&gt;&gt;4);
  printf("%c","0123456789abcdef"[x&amp;0x0f]);
 } else printf("0x");
}


int main(int argc, char *argv[]) {
 int n;
 n = 0x01020304; 
 printf("\n n = %d = %#08x = ",n,n);
 trans(n);
 return 0;
}
</div></PRE>
<P>Описания библиотечных функций помещены в так называемые заголовочные файлы, 
содержимое которых может быть включено в исходный текст программы на этапе 
компиляции директивой препроцессора #include (см. 6.4). 
<P>
<P>
<div class="header"><A name=REF_3_13></A>3.13. Приоритет и порядок выполнения операций 
</div>
<P>В языке C операции делят на группы, имеющие атрибуты приоритета и порядка 
выполнения. Очередность выполнения операций в выражении при отсутствии скобок 
определяется приоритетом группы, а при принадлежности операций одной группе - 
порядком выполнения (см. таблицу). 
<P><PRE>         Приоритеты и порядок выполнения операций
================================================================
 Прио- ¦             Группа                      ¦  Порядок
 ритет ¦            операций                     ¦ выполнения
================================================================
   1   ¦                2                        ¦      3
================================================================
   1   ¦ () вызов функции                        ¦Слева направо
       ¦ [] выделение элемента массива           ¦
       ¦    или объединения                      ¦
       ¦ -&gt; выделение элемента структуры(объеди- ¦
       ¦    ния), адресуемой(ого) указателем     ¦
----------------------------------------------------------------
   2   ¦ !  логическое отрицание                 ¦Справа налево
       ¦ ~  побитовое отрицание (дополнение)     ¦
       ¦ -  изменение знака                      ¦
       ¦ ++ увеличение на единицу                ¦
       ¦ -- уменьшение на единицу                ¦
       ¦ &amp;  определение адреса (указателя)       ¦
       ¦ *  обращение по адресу (указателю)      ¦
       ¦ (тип) преобразование (приведение) типа  ¦
       ¦ sizeof определение размера в байтах     ¦
--------------------------------------------------------------
   3   ¦ * умножение                             ¦Слева направо
       ¦ / деление                               ¦
       ¦ % деление по модулю                     ¦
--------------------------------------------------------------
   4   ¦ + сложение                              ¦   - " 
       ¦ - вычитание                             ¦
--------------------------------------------------------------
   5   ¦ &lt;&lt; сдвиг влево                          ¦   - " 
       ¦ &gt;&gt; сдвиг вправо                         ¦
-------------------------------------------------------------
   6   ¦ &gt;  больше                               ¦   - " 
       ¦ &gt;= больше или равно                     ¦
       ¦ &lt;  меньше                               ¦
       ¦ &lt;= меньше или равно                     ¦
--------------------------------------------------------------
   7   ¦ == равно                                ¦   - " 
       ¦ != не равно                             ¦
--------------------------------------------------------------
   8   ¦ &amp;  побитовая конъюнкция (И)             ¦   - " 
--------------------------------------------------------------
   9   ¦ ^  побитовое исключающее ИЛИ            ¦   - " 
--------------------------------------------------------------
  10   ¦ |  побитовая дизъюнкция (ИЛИ)           ¦   - " 
--------------------------------------------------------------
  11   ¦ &amp;&amp; логическая конъюнкция (И)            ¦   - " 
--------------------------------------------------------------
  12   ¦ || логическая дизъюнкция (ИЛИ)          ¦   - " 
--------------------------------------------------------------
  13   ¦ ?: условное вычисление                  ¦Справа налево
--------------------------------------------------------------
  14   ¦ =  присваивание                         ¦   - " 
       ¦ *= умножение и присваивание             ¦
       ¦ /= деление и присваивание               ¦
       ¦ %= деление по модулю и присваивание     ¦
       ¦ += сложение и присваивание              ¦Справа налево
       ¦ -= вычитание и присваивание             ¦
       ¦ &lt;&lt;= сдвиг влево и присваивание          ¦
       ¦ &gt;&gt;= сдвиг вправо и присваивание         ¦
       ¦ &amp;= побитовая конъюнкция и присваивание  ¦
       ¦ ^= побитовое исключающее ИЛИ и          ¦
       ¦    присваивание                         ¦
       ¦ |= побитовая дизъюнкция и присваивание  ¦
--------------------------------------------------------------
  15   ¦ ,  последовательное вычисление          ¦Слева направо
--------------------------------------------------------------
</P></PRE>
<P>Примеры: 
<P><PRE><div class="code">    x*y/c     &lt;=&gt;  (x*y)/c       /* ==&gt; */
    a=b=c     &lt;=&gt;  a=(b=c)       /* &lt;== */
    alfa[i]() &lt;=&gt;  (alfa[i])()   /* ==&gt; */
</div></PRE>
<P>В сложных выражениях иногда играет роль порядок обработки операндов. Только 
для четырех операций (&amp;&amp; || ?: ,) в языке C левый операнд гарантированно 
обрабатывается первым. С целью обеспечения переносимости (мобильности) программы 
рекомендуется не использовать повторно в выражении переменную, значение которой 
присваивается любым образом в этом выражении. Пример: 
<P><div class="code">y=(x=1)-(++x);</div> 
<P>Перепишем оператор формирования результата в виде 
<P><div class="code">y=ol-or;</div> 
<P>Если компилятор планирует вычисление операндов в скобках слева направо, то 
схема формирования значения y: 
<P><div class="code">ol=1; or=2; y=-1;</div> 
<P>(переменная x последовательно принимает значения 1 и 2). При вычислении 
операндов в обратной последовательности 
<P><div class="code">or=x+1; ol=1; y=x;</div> 
<P>(переменная x вначале увеличивается на 1, затем принимает значение 1). 
Результат присваивания переменных x и y оказался существенно различен. 
<P>
<P>
<P>
<HR SIZE=1 width="100%">
<p>
<A href="#REF_1_C">Начало</A> 

<div class="header"><CENTER><A name=REF_4></A>4. УПРАВЛЯЮЩИЕ ОПЕРАТОРЫ </CENTER></div>
<P>
<div class="header"><A name=REF_4_1></A>4.1. Условные операторы </div>
<P>В языке С имеется две разновидности условных операторов: простой и полный 
операторы условного выполнения. Синтаксис простого оператора условного 
выполнения: 
<P><div class="code">if (выражение) оператор</div> 
<P>Элемент "оператор" подлежит выполнению, если "выражение" от лично от нуля. 
Примеры записи: 
<P><PRE><div class="code">      if (x&gt;0) x=0;
<P>
      if (i!=1) j++, l=1; &lt;===&gt; if (i!=1) { j++, l=1; }
<P>
      if (getch()!=27) {
       k=0;
      }
<P>
      if (i) exit(1);  &lt;===&gt;  if (i!=0) exit(1);
      if (i&gt;0) if (i&lt;n) k++; &lt;===&gt; if ((i&gt;0)&amp;&amp;(i&lt;n)) k++;
      if (1) i=0; &lt;===&gt; i=0;
</P></div></PRE>
<P>Синтаксис полного оператора условного выполнения: 
<P><PRE><div class="code">      if (выражение) оператор_1
      else оператор_2
</div></PRE>
<P>Если "выражение" отлично от нуля, то подлежит выполнению "оператор_1", иначе 
- "оператор_2". Примеры записи: 
<P><div class="code"><PRE>       if (x&gt;0) j=k+1;
       else m=i+10;
</div></PRE>
<P><PRE><div class="code">       if (x) {
        y=i++;
        k=sfn(i);
       } else {
        printf("\n ???");
        exit(0);
       }
</div></PRE>
<P>Элементы "оператор_1" и(или) "оператор_2" могут быть любым оператором, в том 
числе и условным оператором. Фраза "else ..." относится к непосредственно 
предшествующей ей фразе "if ...", поэтому для устранения коллизий условных 
операторов разных уровней вложенности необходимо заключать их в фигурные скобки: 

<P><PRE><div class="code">      if (!x) if (!y) printf("\n x=YES, y=YES");
      else printf("\n x=NO"); /* x=0 &lt;===&gt; (x!=0)&amp;&amp;(y==0) ??? */
<P>
      if (!x) {
       if (!y) printf("\n x=YES, y=YES");
      } else printf("\n x=NO");
</P></div></PRE>
<P>

<div class="header"><A name=REF_4_2></A>4.2. Операторы цикла </div>
<P>Перечень разновидностей операторов цикла: 
<UL>
  <LI><A href="#REF_421">оператор цикла с 
  предусловием</A>; 
  <LI><A href="#REF_422">оператор цикла с 
  постусловием</A>; 
  <LI><A href="#REF_423">оператор цикла с 
  предусловием и коррекцией</A>. </LI></UL>
<P><A name=REF_421></A>Синтаксис оператора цикла с предусловием: 
<P><pre><div class="code">while (выражение) оператор</div></pre> 
<P>(элемент "оператор" может быть пустым оператором, оператором-выражением или 
операторным блоком). Смысл оператора: на каждой итерации цикла предварительно 
проверяется условие продолжения цикла - ненулевое значение "выражения", затем 
выполняется "оператор". Элемент "оператор" может включать любое количество 
управляющих операторов, связанных с конструкцией while: 
<uL>
  <li>continue - переход к следующей итерации цикла; 
  <li>break - выход из цикла. </li></uL>
<P>Примеры записи: 
<P><PRE><div class="code">     while (i&gt;0) i&lt;&lt;=1, j++;
     while (printf("\n n-?"), scahf(" %d",&amp;n));
        ...
     while (1) { /* Организация бесконечного цикла */
      /* ... */
      if (kbhit()&amp;&amp;(getch()==27)) break; /* Выход по ESC */
      /* ... */
     }
     while (!kbhit()); /* Активное ожидание нажатия клавиши */
</div></PRE>
<P><A name=REF_422></A>Синтаксис оператора цикла с постусловием: 
<P><PRE><div class="code">      do оператор while (выражение);
</PRE>
<P>(элемент "оператор" может быть пустым оператором, оператором выражением или 
операторным блоком). Смысл оператора: на каждой итерации цикла предварительно 
выполняется "оператор", затем проверяется условие продолжения цикла - ненулевое 
значение "выражения". Назначение используемых в элементе "оператор" управляющих 
операторов continue и break совпадает с ранее рассмотренным, но оператор 
continue вызывает переход к этапу оценки "выражения". 
<P><PRE><div class="code">      do printf("\n ???");
      while (!scanf(" %d",&amp;n));
      ...
      float *x;
      int i=0;
      ...
      m=coreleft()/sizeof(*x);
      do {
       printf("\n n-?");
       if (!scanf(" %d",&amp;n)) {
        sound(300);
        printf(" Вводите цифры !");
        continue;
       }
      if (n&gt;m) continue;
       if (!scanf(" %f",x+i)) break;
      } while (++i&lt;n);
</div></PRE>
<P><A name=REF_423></A>Синтаксис оператора цикла с предусловием и коррекцией: 
<P><PRE><div class="code">      for (инициализация; условие_выполнения; коррекция) оператор
</div></PRE>
<P>Здесь "инициализация", "условие_выполнения" и "коррекция" выражения, которые 
могут отсутствовать (пустые выражения), но символы ';' опускать нельзя. 
Оператор-выражение "инициализация" выполняется один раз перед началом итераций 
цикла. Итерации цикла продолжаются, пока истинно "условие_выполнения" - 
выражение пустое либо непустое выражение отлично от нуля. На каждой итерации 
последовательно выполняются "оператор" и оператор-выражение "коррекция". 
Назначение используемых в элементе "оператор" управляющих операторов continue и 
break совпадает с ранее рассмотренным. 
<P><PRE><div class="code">        float  x[10], y;
        int  i,n;
        ...
        for (i=n=sizeof(x)/sizeof(*x); i&gt;0; x[--i]=0);
        ...
        for (i=0; i&lt;n; x[i++]=0);

        for (i=0; i&lt;n; i++) x[i]=0;
        ...
        for (i=0, i=0; i&lt;n; i++)
         if (x[i]&lt;0) y+=x[i];
        ...
</div></PRE>Различные формы операторов цикла могут выражаться друг через друга, 
например: 
<P>а) оператор 
<P><PRE><div class="code">     for (инициализация; условие_выполнения; коррекция) оператор
</div></PRE>
<P>эквивалентен последовательности операторов 
<P><PRE><div class="code">       инициализация;
       while (условие_выполнения) {
        оператор;
        коррекция;
       }
</div></PRE>
<P>(здесь "оператор" не может включать операторы break или continue); 
<P>б) оператор 
<P><PRE><div class="code">     for (; условие_выполнения;) оператор
</div></PRE>
<P>эквивалентен оператору 
<P><PRE><div class="code">     while (условие_выполнения) оператор;
</div></PRE>
<P>в) оператор 
<P><PRE><div class="code">     for (оператор; условие_выполнения;) оператор
</div></PRE>
<P>эквивалентен оператору 
<P><PRE><div class="code">     do оператор while (условие_выполнения);
</div></PRE>
<P>г) оператор 
<P><PRE><div class="code">     for (;;) оператор
</div></PRE>
<P>эквивалентен оператору 
<P><PRE><div class="code">     while (1) оператор;
</div></PRE>
<P>(вместо 1 здесь может быть любое число, отличное от нуля). 
<P>При использовании вложенных циклов следует учитывать, что управляющие 
операторы break и continue действуют внутри собственного цикла. Для выхода из 
вложенного цикла приходится использовать оператор <STRONG>безусловного</STRONG> 
перехода goto: 
<P><PRE><div class="code">     float x[10][20];
     int i,j;
<P>
  /* Проверка наличия отрицательных значений */
<P>
     for (i=0; i&lt;10; i++)
      for (j=0; j&lt;20; j++)
       if (x[i][j]&lt;0) goto next_step;
<P>
     next_step: printf("\nЭлемент (%d,%d) отрицателен...");
</P></div></PRE>
<P>
<P>
<div class="header"><A name=REF_4_3></A>4.3. Оператор выбора альтернатив (переключатель) 
</div>
<P>Синтаксис: 
<P><PRE><div class="code">      switch (выражение) { ------------------------------------
<P>
       case константа_1: оператор_1                 Тело
       case константа_2: оператор_2               оператора
                              ...                  switch
       default:  оператор_N
      } ------------------------------------------------------
</P></div></PRE>
<P>Ключевое слово default и целочисленные значения констант рассматриваются как 
специальные метки операторов, область действия которых - тело оператора switch. 
Порядок следования таких меток не регламентирован. Целочисленное выражение 
сравнивается после вычис ления со значениями констант-меток. При совпадении с 
одной из них выполняется передача управления соответствующему оператору в теле 
оператора switch. В случае несовпадения значения выражения с одной из констант - 
переход на метку default либо, при ее отсутствии, к оператору, следующему за 
оператором switch. Упомянутые здесь специальные метки в теле оператора switch 
недолжны повторяться или использоваться для ссылок в операторе goto. Для выхода 
из тела оператора switch используют управляющий оператор break (дополнительно 
можно воспользоваться операторами goto или return, а при вложенности в оператор 
цикла и оператором continue). Рассмотрим пример построения простейшего 
калькулятора для вычисления значений функций sin(),cos(),log(),sqrt(),tan(). 
<P><PRE><div class="code">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;conio.h&lt;
<P>
char f[]="\n %s(%lf)=%lf";
<P>
void main() {
 double x;
<P>
 while (sound(1000),
        printf("\n x-? "),
        nosound(),
        scanf("%lf",&amp;x)) {
  for (;;) {
   printf("\n x=%lf, Sin, Cos, Log, sQrt, Tan - ? ",x);
   switch(getch()) {
    case 27 : goto cont; /* 27 - код клавиши ESC */
    case 's':
    case 'S': printf(f,"sin",x,sin(x));
              break;
    case 'c':
    case 'C': printf(f,"cos",x,cos(x));
              break;
    case 'l':
    case 'L': printf(f,"log",x,log(x));
              break;
    case 'q':
    case 'Q': printf(f,"sqrt",x,sqrt(x));
              break;
    case 't':
    case 'T': printf(f,"tan",x,tan(x));
              break;
    default:  sound(100);
    printf("\n Select Sin, Cos, Log, sQrt, Tan or ESC");
    nosound();
   }
  }
  cont:;
 }
}
<P>
</P></div></PRE>Очевидно, что здесь оператор switch можно заменить вложенными 
условными операторами: 
<P><PRE><div class="code">     int i;
     ...
     i=getch();
     if ((i=='s')||(i=='S')) printf(f,"sin",x,sin(x));
     else if ((i=='c')||(i=='C')) printf(f,"cos",x,cos(x));
     ...
     else if ((i=='t')||(i=='T')) printf(f,"tan",x,tan(x));
     else {
      sound(100);
      printf ...
      nosound();
     }
</div></PRE>
<P>В последнем варианте используется последовательная проверка условий, его 
вычислительная сложность 6/2 (половина количества альтернатив). Оператор switch 
реализуется переходом по адресу, выбираемому из инвертированной таблицы меток по 
значению выражения, поэтому его вычислительная сложность близка к единице. 
<P>
<P>

<div class="header"><A name=REF_4_4></A>4.4. Операторы передачи управления </div>
<P>Формально к операторам передачи управления относятся: 
<DL>
  <DD>а) оператор безусловного перехода <PRE><div class="code">         goto метка;
</div></PRE>
  <DD>б) оператор перехода к следующему шагу (итерации) цикла 
  <P><PRE><div class="code">         continue;
</div></PRE>
  <P>(игнорирование оставшихся операторов тела цикла); 
  <P></P>
  <DD>в) выход из цикла либо оператора switch 
  <P><PRE><div class="code">         break;
</div></PRE>
  <P>(передача управления следующему оператору); 
  <P></P>
  <DD>г) оператор возврата их функции 
  <P><PRE><div class="code">         return;
         return выражение;
</div></PRE>
  <P>(прекращение выполнения текущей функции и возврат управления вызвавшей 
  программе с передачей, при необходимости, значения выражения). 
</P></DD></DL>Операторы вида a...в рассматривались ранее. Оператор return 
обязательно необходим в функциях, возвращающих значения. В функциях, не 
возвращающих результат, он неявно присутствует после последнего оператора. 
Значение "выражения" при необходимости будет преобразовано к типу возвращаемого 
функцией значения. 
<P><PRE><div class="code">     void error(void *x, int n) {
      if (!x) printf("\nМассив не создан");
      if (!n) printf("\nМассив пустой");
     }
<P>
     float estim(float *x, int n) {
      int i;
      float y;
      if ((!x)||(!n) {
       error(x,n);
       return 0;
      }
      for (y=i=0; i&lt;n; i++)
       y+=x[i];
      return y/n;
     }
</P></div></PRE>
<P>Строго говоря, в языке C имеются дополнительные возможности передачи 
управления: 
<UL>
  <LI>нелокальный переход, организуемый парой функций longjump и setjump; 
  <LI>операторы структурного управления исключениями _try/_except и _try/finally 
  [2-3, 15, 21]. </LI></UL>
<P>
<P>
<P>
<HR SIZE=1 width="100%">

<A href="#REF_1_C">Начало</A>
<p> 

<div class="header"><CENTER><A name=REF_5></A>5. СТРУКТУРИЗАЦИЯ ПРОГРАММ И ДАННЫХ </CENTER></div>
<P>
<div class="header"><A name=REF_5_1></A>5.1. Области действия объектов программ </div>
<P>В языке С можно выделить два уровня детализации модуля программы: файл 
исходного текста и функцию. Файл исходного текста может включать определения 
данных и функций. Операционные объекты, кроме атрибута типа, имеют атрибуты 
области действия и класса памяти. По области действия разделяют объекты: 
<UL>
  <LI>глобальные - доступны во всех функциях файла исходного текста; 
  <LI>локальные - доступны только в теле функции или операторного блока. 
</LI></UL>
<P>В языке С нет ключевого слова, указывающего область действия объекта. Область 
действия определяется местоположением оператора описания объекта в файле 
исходного текста программы (любой объект полностью описывается в одном 
операторе). 
<P>Структура исходного текста программ на языке С 
<P><PRE>  -----------------------------------------  ------------------
  ¦  Описание глобальных объектов         ¦
  -----------------------------------------
  -----------------------------------------
  ¦  Заголовок функции {                  ¦
  ¦                                       ¦    Директивы
  ¦  ----------------------------------   ¦
  ¦  ¦ Описание локальных объектов    ¦   ¦    препроцессора
  ¦  ----------------------------------   ¦
  ¦  ----------------------------------   ¦    и макрокоманды
  ¦  ¦ Операторы                      ¦   ¦
  ¦  ----------------------------------   ¦
  ¦                                       ¦
  ¦  }                                    ¦
  -----------------------------------------  ------------------
</PRE>
<P>Файл исходного текста может включать любое количество определений функций 
и(или) глобальных данных. Параметры функции являются локальными объектами и 
должны отличаться по именам от используемых в теле функции глобальных объектов. 
Локальные объекты, описанные в теле функции, имеют приоритет перед объектами, 
описанными вне функции: 
<P><PRE><div class="code">     int n;      /* Глобальное n */
<P>
     void main (int n, char **l) {
      int i;
     /* ... */
      f1(i);
     /* ... */
      f2(n);     /* Локальное n */
     }
<P>
     f1(int i) {
      /* ... */
       i=n;      /* Глобальное n */
      /* ... */
     }
     f2(int n) {
      int i;
      /* ... */
       i=n;       /* Локальное n */
      /* ... */
     }
</P></div></PRE>
<P>Локальные объекты в программах на языке С можно декларировать в начале любого 
операторного блока, а операторный блок тела функции - частный случай такого 
правила (в языке С++ оператор декларации может размещаться в любом месте 
операторного блока). В любом месте файла исходного текста можно ссылаться на 
глобальные объекты, определенные ниже в остатке текущего файла или в других 
файлах. Для этого необходимо описать тип объекта и добавить к описанию ключевое 
слово extern. Описания функций подразумевают атрибут extern по умолчанию. 
Разрешается опускать длину внешних одномерных массивов, но операция sizeof к 
таким массивам становится бессмысленной. Следует учитывать, что любой оператор 
описания действует только на остаток файла исходного текста. 
<P>
<P>

<div class="header"><A name=REF_5_2></A>5.2. Классы памяти объектов программ </div>
<P>Классы памяти объектов в языке C: 
<UL>
  <LI>статическая память - распределяется на этапе трансляции и заполняется по 
  умолчанию нулями; 
  <LI>динамическая память - выделяется при вызове функции и освобождается при 
  выходе из функции. </LI></UL>Объекты, размещаемые в статической памяти, 
описываются с атрибутом static и могут иметь любой атрибут области действия. 
Значения локальных статических объектов сохраняются при повторном вызове 
функции. Глобальные объекты всегда являются статическими. Атрибут static, 
использованный при описании глобального объекта, предписывает ограничение 
области его применимости только в пределах остатка текущего файла. Таким 
образом, в языке С ключевое слово static имеет разный смысл для локальных и 
глобальных объектов. В динамической памяти могут размещаться только локальные 
объекты, объявленные в теле функции. Такие объекты существуют временно на этапе 
активности функции. 
<P>Имеется две разновидности динамической памяти: 
<UL>
  <LI>автоматическая память (атрибут auto) - объекты располагаются в стековой 
  памяти; 
  <LI>регистровая память (атрибут register) - объекты располагаются в регистрах 
  общего назначения, а при нехватке регистров - в стековой памяти (размер 
  объекта не должен превышать разрядности регистра). </LI></UL>По умолчанию, 
локальные объекты, объявленные в теле функции, имеют атрибут класса памяти auto. 
Регистровая память позволяет увеличить быстродействие программы, но к 
размещаемым в ней объектам неприменима операция адресации &amp; (см. 3.11). 
<P><PRE><div class="code">     void swap(int *x, int *y) {
      register int t;
      t=*x, *x=*y, *y=t;
     }
</div></PRE>
<P>Понятие области действия приходится учитывать при использовании многофайловых 
программных комплексов: 
<P><PRE><div class="code">    /************************ Файл  f1.c *********************/
<P>
    static void f0(); /* f0 доступна только в файле f1.c */
    extern int n; /* Переменная n определена в файле f2.c */
    char x[]="n"; /* Глобальная переменная без атрибута static */
<P>
    void f2() { /* Функция f2 доступна из всех файлов */
     printf("\nЗначение %s=%d",x,n);
     f0(); /* Вызов f0 из текущего файла f1.c */
    }
<P>
<P>
    void f0() {
     printf("\n Функция f0 из файла f1.c");
    }
<P>
   /************************ Файл  f2.c *********************/
<P>
    static void f0() { /* f0 доступна только в файле f2.c */
     printf("\n Функция f0 из файла f2.c");
    }
<P>
    int n=10; /* Глобальная переменная без атрибута static */
<P>
    extern char x[];  /* Массив x определен в файле f1.c */
<P>
    void main() {
     f2(); /* Вызов f2 из файла f1.c */
     printf("\n Справедливо ли (%s==%d) ?",x,n);
     f0(); /* Вызов f0 из текущего файла f2.c */
    }
</P></div></PRE>
<P>
<P>

<div class="header"><A name=REF_5_3></A>5.3. Инициализации объектов программ </div>
<P>Любые объекты, кроме масивов, структур и объединений, имеющих атрибут auto, а 
также формальных параметров, при определении могут получать начальные значения - 
константные выражения. Признак инициализации - символ '=' в поле оператора 
описания объекта. 
<P>Начальные значения записываются по следующим правилам: 
<P>а) основные типы данных 
<P><PRE><div class="code">      int x=0;
      float y=3.14;
      char z='\0';
      int *h=&amp;x;
      char *u=(char *)&amp;y;
      int a=sizeof(float);
      int print(void), (*prnt)(void)=print;
</pre></div>

     <p>б) массивы
<P><pre><div class="code">
      int t[10]={1,2,3,4,5};
      int e[]={1,2,3,4,5};
<P>
      char x[]={'Y','E','S','\0'}; /*  Эквивалентные    */
      char x[]="YES";              /*  описания         */
      char *x="YES";               /*  массива символов */
</P><div></PRE>
<P>(список значений - в фигурных скобках, недостающие значения заменяются 
нулями, если размер массива опущен, то он определяется фактическим числом 
начальных значений, массив символов может быть инициализирован строковой 
константой); 
<P>в) структуры 
<P><PRE><div class="code">      struct part {
       int code;
       char *name;
      };
<P>
      struct part x={121,"Блок питания"};
      struct part y[]= {
        {10,"Болт"},
        {20,"Гайка"},
        {30,"Шайба"}
      };
<P>
      struct part z[10]= {
        {11},
        {12},
        {13}
      };
<P>
</P><div></PRE>(список значений каждой структурной переменной может заключаться в 
фигурные скобки, значения элементам структуры присваиваются в порядке размещения 
элементов в определении структурного типа, список значений может быть неполным, 
тогда оставшиеся поля заполняются нулями). 
<P>Перепишем ранее рассмотренный пример простейшего калькулятора: 
<P><PRE><div class="code">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;conio.h&gt;
#include &lt;ctype.h&gt;
<P>
char f[]="\n %s(%lf)=%lf";
<P>
struct {
 char *fn;
 double (*fa)();
} fd[]={{"Sin",sin},
        {"Cos",cos},
        {"Exp",exp},
        {"Log",log},
        {"sQrt",sqrt},
        {"Tan",tan}
       };
<P>
void main() {
 double x;
 int n=sizeof(fd)/sizeof(*fd);
 int in[256], i,j,k;
<P>
 for (i=0; i&lt;256; in[i++]=n);
 for (i=0; i&lt;n; i++)
  for (j=0; (k=fd[i].fn[j])!=0; j++)
   if (!islower(k)) {
    in[k]=in[tolower(k)]=i;
    break;
   }
<P>
 while (sound(1000),
        printf("\n x-? "),
        nosound(),
        scanf("%lf",&amp;x)) {
<P>
  for (;;) {
   printf("\n x=%lf, f()-?",x);
   switch(k=getch()) {
    case 27 : goto cont;
<P>
    default : if ((i=in[k])&lt;n) printf(f,fd[i].fn,x,(*(fd[i].fa))(x));
              else {
               sound(100);
               printf("\n Набор функций:");
               for (i=0; i&lt;n; i++)
                printf("\n %s",fd[i].fn);
               nosound();
              }
   }
  }
  cont:;
 }
}
</P></div></PRE>
<P>

<div class="header"><A name=REF_5_4></A>5.4. Управляемая память </div>
<P>Любой именованный объект программы размещается в статически либо 
автоматически распределяемой памяти. Статический объект размещается во время 
запуска программы и существует в течение всего времени ее выполнения. 
Автоматический объект размещается каждый раз при входе в его блок и существует 
только до момента выхода из блока. Часто возникает потребность управляемого 
размещения объектов в памяти в соответствии с алгоритмом решения задачи без 
привязки к блокам программы. В языках С и С++ такие объекты могут адресоваться 
только косвенно по значению указателя. Указатель может иметь при этом имя, но 
адресуемый им объект является безымянным. Область памяти для размещения объектов 
может быть получена запросом к операционной системе на выделение блока 
требуемого размера либо назначена на место размещения некоторого известного 
объекта достаточного размера. Управление размещением объектов осуществляется 
операциями захвата и освобождения памяти. В языке С для этих целей приходится 
пользоваться библиотечными функциями. Например, в файле alloc.h декларированы 
функции: 
<uL>
  <li>void *malloc(unsigned nbytes) - возврат указателя на выделенную область 
  размером nbytes (NULL при недостатке памяти или nbytes==0); 
  <li>void free(void *block_pointer) - освобождение захваченной памяти по 
  заданному адресу. </li></uL>Операции захвата и освобождения памяти в стиле языка 
С имеют вид: 
<P><PRE><div class="code">     указатель_на_объект=malloc(sizeof(атрибуты_типа_объекта));
     free(указатель_на_объект);
</div></PRE>
<P>Пример программы с работой в управляемой памяти: 
<P><PRE><div class="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;mem.h&gt;
<P>
/* Процедура сортировки обменным методом */
<P>
     int excngs(void *base,
                int number,
                int width,
                int fcp(const void *x,const void *y)) {
      char *x,*y,*t;
      int i,j,n;
      t=(char *)malloc(width);
      if (t) {
       n=number-1;
       do {
        for (i=j=0; i&lt;n; i++) {
         x=(char *)base+i*width;
         y=x+width;
         if (fcp(x,y)&gt;0) {
          memcpy(t,x,width);
          memcpy(x,y,width);
          memcpy(y,t,width);
          j=n;
         }
        }
       } while (j);
       free(t);
      }
      return (t!=NULL);
     }
<P>
typedef struct {
 int attr, app, group, obj;
} TEST;
<P>
int fcp(const void *x,const void *y) {
 TEST *X=(TEST *)x,
      *Y=(TEST *)y;
 return(X-&gt;attr-Y-&gt;attr);
}
<P>
/* Исходный массив структур */
<P>
TEST x[]={
 { -1, 1, 1, 1},
 {-10, 2, 1, 1},
 { -2, 3, 1, 1},
 { -3, 4, 1, 1},
 { -1, 5, 1, 1}
};
<P>
/* Печать массива структур */
<P>
void print(char *title) {
 int n=sizeof(x)/sizeof(*x);
 printf("\n %s",title);
 for (int i=0; i&lt;n; i++)
  printf("\n %3d) %6d %6d %6d %6d",
         i,x[i].attr,x[i].app,x[i].group,x[i].obj);
 printf("\n");
}
<P>
/* Тестовая программа */
<P>
void main () {
 print("Исходный массив:");
 if (excngs(x,sizeof(x)/sizeof(*x),sizeof(*x),fcp))
  print("Массив после сортировки:");
}
</P></div></PRE>
<P>Безопасное использование управляемой памяти требует обязательной проверки 
успешности выделения памяти. 
<P>
<P>
<HR SIZE=1 width="100%">

<A href="#REF_1_C">Начало</A>
<p> 

<div class="header"><CENTER><A name=REF_6></A>6. ПРЕПРОЦЕССОР ЯЗЫКА C </CENTER></div>
<P>
<div class="header"><A name=REF_6_1></A>6.1. Возможности препроцессора и его вызов 
</div>
<P><strong>Препроцессор</strong> - программа предварительной обработки исходного текста программы 
перед этапом компиляции. Способ включения препроцессора в систему 
программирования определяется стилем ее реализации. Например, в системе 
программирования Turbo-C препроцессор совмещен с компиляторами TC и TCC. Кроме 
этого, имеется и автономный пакетный препроцессор CPP. Чаще всего препроцессор 
автоматически вызывается на этапе компиляции, если в исходном тексте обнаружен 
хотя бы один препро цессорный оператор. Признаком препроцессорного оператора в 
языке C является символ '#'(обычно в начале строки). Такой оператор 
заканчивается символом перевода на новую строку '\n'. При необходимости 
продолжения оператора в следующей строке текущую строку должен завершать символ 
'\'. 
<P>
<UL>Возможности препроцессора языка C: 
  <P>
  <LI><A href="#REF_6_2">лексемное замещение 
  идентификаторов;</A> 
  <LI><A href="#REF_6_3">макрозамещение;</A> 
  <LI><A href="#REF_6_4">включение файлов 
  исходного текста;</A> 
  <LI><A href="#REF_6_5">условная 
  компиляция;</A> 
  <LI><A href="#REF_6_6">изменение нумерации 
  строк и текущего имени файла.</A></LI></UL>
<P>
<P>

<div class="header"><A name=REF_6_2></A>6.2. Операторы лексемного замещения идентификаторов 
</div>
<P>Оператор определения значения идентификатора: <PRE><P><div class="code">
     #define идентификатор строка
</P></div></PRE>
<P>В результате каждое вхождение в исходный текст элемента "идентификатор" 
заменяется на значение элемента "строка": 
<P><PRE><div class="code">     #define L_bufs 2048
     #define binary int
     #define WAIT ffluch(stdin); getch()
     #define BEEP sound(800);\
                  delay(100);nosound()
</div></PRE>
<P>Лексемное замещение весьма удобно для сокращения записи повторяющихся 
фрагментов текста и определения символических констант: 
<P><PRE><div class="code">     #define YES 1
     #define NO  2
     #define ESC 27
     #define Enter 30
</div></PRE>
<P>Примеры использования: 
<P><PRE><div class="code">     if (x==ESC) break;
     BEEP;
     return(YES);
</div></PRE>
<P>Оператор отмены определения идентификатора 
<P><PRE><div class="code">     #undef идентификатор
</div></PRE>
<P>Далее по исходному тексту можно назначить новое значение такого 
идентификатора. Функцию оператора препроцессора #define по отношению к 
именованию типов объектов может выполнять <A 
href="#REF_2_7">оператор переопределения 
типа</A> компилятора языка C typedef (п. 2.7). 
<P>

<div class="header"><A name=REF_6_3></A>6.3. Макрозамещение </div>
<P><strong>Макрозамещение</strong> - обобщение лексемного замещения посредством параметризации 
строки оператора #define в виде: 
<P><PRE><div class="code">     #define идентификатор(параметр1,... ) строка
</div></PRE>
<P>(между элементом "идентификатор" и символом '(' пробелы не допускаются). 
<P>Такой вариант оператора #define иногда называют макроопределением (макросом). 
Элемент "строка" обычно содержит параметры, которые будут заменены 
препроцессором фактическими аргументами так называемой макрокоманды, 
записываемой в формате 
<P><div class="code">идентификатор(аргумент1,... )</div> 
<P>Пример макроопределения и макрокоманд: 
<P><PRE><div class="code">     #define P(X) printf("\n%s",X)
<P>
     char *x;
<P>
  /* Использование макроопределения P(X) */
<P>
     P(x);
     P(" НАЧАЛО ОПТИМИЗАЦИИ");
<P>
  /* Эквивалентные операторы */
<P>
     printf("\n%s",x);
     printf("\n%s"," НАЧАЛО ОПТИМИЗАЦИИ");
<P>
</P></div></PRE>Идентификаторы параметров в строке макроопределений сложных выражений 
рекомендуется заключать в круглые скобки: 
<P><PRE><div class="code">     #define МАХ(A,B) ((A)&gt;(B)? (A):(B))
     #define UP(x) ((x)-'a'+'А')
     #define LOW(x) ((x)-'A'+'a')
</div></PRE>
<P>Потребность в круглых скобках возникает при опасности искажения смысла 
вложенных выражений из-за действия правил приоритета операций. Пример искажения 
смысла операций: 
<P><PRE><div class="code">     #define BP(X) X*X
<P>
     int x,y,z;
<P>
     x=BP(y+z); &lt;===&gt; x=y+z*y+z; &lt;===&gt; x=y+(z*y)+z;
</P></div></PRE>
<P>Очевидно, что ошибки будут и при следующих вариантах: 
<P><PRE><div class="code">     #define BP(X) (X*X)
     #define BP(X) (X)*(X)
</div></PRE>
<P>Безопасный вариант: 
<P><PRE><div class="code">     #define BP(X) ((X)*(X))
</div></PRE>
<P>Иногда источником ошибок может быть символ ';' в конце строки 
макроопределения: 
<P><PRE><div class="code">     #define BP(X) ((X)*(X));
<P>
     int x,y,z;
<P>
     x=BP(z)-BP(y); &lt;===&gt; y=((z)*(z));-((y)*(y));
</P></div></PRE>
<P>Макроопределение отменяется оператором #undef. 
<P>Идентификаторы макроопределений обычно составляют из прописных букв 
латинского алфавита. Это позволяет отличать макрокоманды от вызова функций. 
Например, в Turbo-C построение "далекого" указателя может быть выполнено 
макрокомандой MK_FP: 
<P><PRE><div class="code">     #define MK_FP(seg,ofs) \
      ((void far *)(((unsigned long)(seg)&lt;&lt;16)|(unsigned)(ofs)))
</div></PRE>
<P>
<P>Макрокоманда внешне синтаксически эквивалентна операции вызова функции, но 
смысл их существенно различен. Функция в программе имеется в одном экземпляре, 
но на ее вызов тратится время для подготовки параметров и передачи управления. 
Каждая макрокоманда замещается соответствующей частью макроопределения, но 
потерь на передачу управления нет. Дополнительное отличие: параметры функции 
контролируются на соответствие типа и могут автоматически преобразовываться в 
заданный прототипом тип. 
<P>
<P>

<div class="header"><A name=REF_6_4></A>6.4. Оператор включения файлов исходного текста 
</div>
<P>Имеются два варианта запроса включения в текущий файл содер жимого другого 
файла. Оператор 
<P><div class="code">#include &lt;имя_файла&gt;</div> 
<P>вводит содержимое файла из стандартного каталога (обычно принято именовать 
его \include\), а оператор 
<P><div class="code">#include "имя_файла" </div>
<P>организует последовательный поиск в текущем, системном и стандарт ном 
каталогах. 
<P>Примеры (Turbo-C MS-DOS): 
<P><PRE><div class="code">#include &lt;stdio.h&gt;    /* Стандартные средства ввода-вывода */
#include &lt;alloc.h&gt;    /* Средства распределения памяти */
#include &lt;dos.h&gt;      /* Обращения к функциям ОС */
#include &lt;conio.h&gt;    /* Консольный ввод-вывод */
<P>
#include "a:\prs\head.h"  /* Включение файла пользователя */
</P></div></PRE>
<P>В стандартных каталогах системы программирования помещены операторы описания 
внутренних функций языка C, системных переменных среды исполнения, структур 
данных файловой системы, строк диагностических сообщений, определения констант и 
т.п. 
<P>Рекомендуется описания системных объектов включать из стандартных каталогов и 
размещать их в начале файла исходного текста программы. Системные объекты в 
результате получают атрибут области действия "глобальный", что устранит 
неоднозначность их описания. Включаемый оператором #include исходный текст может 
содержать любые операторы препроцессора. 
<P>
<P>

<div class="header"><A name=REF_6_5>6.5. Условная компиляция </div>
<P>Условность компиляции понимается по отношению к включению фрагментов текста в 
рабочий вариант программы. Операторы условной компиляции и реализуемые правила 
включения исходного текста: 
<DL>
  <DD>а) условное включение 
  <P><PRE><div class="code">      #if&lt;предикат_условия&gt;
       ТЕКСТ
      #endif
</div></PRE>
  <P>(если условие истинно, то ТЕКСТ обрабатывается компилятором);</P>
  <DD>б) альтернативное включение 
  <P><PRE><div class="code">      #if&lt;предикат_условия&gt;
       ТЕКСТ_1
      #else
       ТЕКСТ_2
      #endif
</div></PRE>
  <P>(если условие истинно, то компилятором обрабатывается ТЕКСТ_1, иначе - 
  ТЕКСТ_2). </P></DD></DL>
<P>Виды предикатов условий: 
<P>
<UL>
  <LI>константное_выражение - истина, если его значение не равно нулю; 
  <LI>def идентификатор - истина, если идентификатор был определен ранее 
  оператором #define; 
  <LI>ndef идентификатор - истина, если идентификатор не был определен 
  оператором #define. </LI></UL>
<P>Константное_выражение отделяется от ключевого слова if разделителем, а def и 
ndef - нет. 
<P>Пример: 
<P><PRE><div class="code">     #ifdef DEBUG
      print_state();
     #endif
</div></PRE>
<P>Элементы исходного текста "ТЕКСТ_1" или "ТЕКСТ_2" могут содержать любые 
операторы препроцессора. 
<P>Примеры: 
<P><div class="code"><PRE>#ifndef EOF
#define EOF -1
#endif
<P>
#if UNIT==CON
#include "conproc.c"
#else
#include "outproc.c"
#endif
<P>
/* Блокировка повторного включения заголовочного файла */
<P>
#ifndef _DESCRIPTOR
#define _DESCRIPTOR
 /*
  Текст
 */
#endif
</P></div></PRE>
<P>
<P>Предикаты условий могут использовать системно определенные макросы, например: 

<DL>
  <DD>__DATE__ - дата, 
  <DD>__TIME__ - время компиляции; 
  <DD>__FILE__ - имя компилируемого файла; 
  <DD>__LINE__ - целочисленное значение номера текущей строки. </DD></DL>Пример 
использования системных макроопределений: 
<P><PRE><div class="code">     #include &lt;stdio.h&gt;
     void main() {
      printf("\nФайл %s",__FILE__);
     }
</div></PRE>
<P>Кроме заданных операторами #define и системоопределенных макросов доступными 
оказываются и идентификаторы, задаваемые в командной строке вызова компилятора 
и(или) опциями установки интегрированной среды. </P>
<P>В качестве предиката условия в современных препроцессорах может выступать 
"функция" препроцессора defined(): 
<P><PRE><div class="code">     #if defined(DOS_TARGET)
      puts(msg);
     #else
      MessageBox(NULL,msg,"MSG",MB_OK | MB_TASKMODAL);
     #endi
</div></PRE>
<P>Использование defined() позволяет сокращать текст записи сложных условий: 
<P><PRE><div class="code">     #if defined(DOS_TARGET) &amp;&amp; !defined(NO_DEBUG)
      puts(msg);
     #endif
</div></PRE>
<P>Предикат условия может включать логические операции языка C и операции 
отношений (==, !=, &gt;, &gt;=, &lt;, &lt;=). </P>Последнее расширение 
операторов условной компиляции - оператор #elif: 
<P><PRE><div class="code">    #if выражение_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Включение, если выражение_1 - истина */
<P>
    #elif выражение_2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Включение, если выражение_2 - истина */
<P>
    #else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Включение, если все выражения ложны */
<P>
    #endif
</P></div></PRE>
<P>В последней синтаксической конструкции обязательны лишь первый и последний 
операторы. Типичное применение #elif - альтернативный выбор фрагмента исходного 
текста: 
<P><PRE><div class="code">     void sort(void *x,int n) {
      #if 0
       /* Новая версия программы не отлажена */
<P>
      #elif MODEL==__HUGE__
       /* Работа с "дальними указателями" */
      #else
       /* Использование библиотечной функции */
       qsorts(x,n);
      #endif
     }
</P></div></PRE>
<P>

<div class="header"><A name=REF_6_6></A>6.6. Изменение нумерации строк и имени файла 
</div>
<P>По умолчанию диагностические сообщения компилятора привязываются к номеру 
строки и имени файла исходного текста. 
<P>Оператор 
<P><PRE><div class="code">     #line номер_строки идентификатор_файла
</div></PRE>
<P>позволяет с целью более приметной привязки к фрагментам текста изменить номер 
текущей строки __LINE__ и имя файла __FILE__ на новые значения 
("идентификатор_файла" можно опустить). 
<P>

<div class="header"><A name=REF_6_7></A>6.7. Расширенные возможности современных процессоров 
</div>
<P>Современные версии препроцессоров поддерживают следующие возможности: 
<UL>
  <LI><A href="#REF_671">вывод диагностических 
  сообщений;</A> 
  <LI><A href="#REF_672">преобразование 
  аргументов макроопределений в строку;</A> 
  <LI><A href="#REF_673">конкатенацию(склейку) 
  лексем.</A> </LI></UL><A name=REF_671></A>
<P>Синтаксис оператора <strong>вывода диагностических сообщений:</strong> </P><PRE><div class="code">     #error сообщение_об_ошибке
</div></PRE>
<P>(сообщение об ошибке здесь может включать идентификаторы макроопределений). 
<P><PRE><div class="code">     #if !defined(__HUGE__)
      #error Файл __FILE__: компиляция только в режиме HUGE
     #endif
</div></PRE>
<P><A name=REF_672></A>Рассмотрим возможность <strong>преобразования аргументов 
макроопределений в строку.</strong> В операторе макроопределения 
<P><PRE><div class="code">     #define идентификатор(парам_1,...) строка
</div></PRE>
<P>именам параметров в "строке" может предшествовать символ '#', что 
предписывает преобразование аргумента в строку. Результат преобразования 
объединяется со смежными строками, если он отделен только пробелом: 
<P><PRE><div class="code">     #define DEBUG_OUT(intvar) \
      printf(#intvar "%d\n", (int)(intvar))
<P>
     void main() {
      int alpha=1, betta=2;
      DEBUG_OUT(alpha);
<P>
      DEBUG_OUT(betta);
     }
<P></div></pre>
     Результаты работы программы:
<P><div class="code"><font color="black">
alpha=1
betta=2
<P>
</P></font></div><A name=REF_673></A><strong>Конкатенация</strong>, или склейка, лексем программируется 
следующим образом: оператор X##Y объединяет лексемы X и Y, причем результат 
снова обрабатывается препроцессором. 
<P>Пример: <PRE><div class="code">     #define DEF_Var(n) int __var_##n
     #define USE_Var(n) __var_##n

     DEF_Var(100);
     DEF_Var(200);

     USE_Var(100)=1;
     USE_Var(200)=USE_Var(100)++;
</div></PRE>Приведенный фрагмент программы на вход компилятора поступит в виде <PRE><div class="code">     int __var_100;
     int __var_200;

     __var_100=1;
     __var_200++;
</div></PRE>Очевидно, что рассмотренные здесь расширенные возможности препроцессора 
облегчают параметризацию исходного текста программы. 
<P>
<P>
<P>
<HR SIZE=1 width="100%">

<A href="#REF_1_C">Начало</A>
<p> 
<div class="header"><center><A name=REF_7></A>7. ЗАПУСК И ЗАВЕРШЕНИЕ ПРОГРАММ </center></div>
<P>
<div class="header"><A name=REF_7_1></A>7.1. Головная функция программ на языке 
C </div>
<P>Головной функцией любой программы на языке C является функция main, которая 
может получать аргументы из командной строки вызова программы и среды оболочки. 
Интерпретация командной строки вызова программы 
<P><pre><div class="code"><font color="black">имя арг_1 арг_1 ... арг_N</font></div></pre> 
<P>средствами языка C выглядит так: 
<P><pre><div class="code"><font color="black">char *argv[argc]={"имя","арг_1",..."арг_N"};</font></div></pre> 
<P>(здесь argc=N+1). Интерпретация переменных среды оболочки 
<P><PRE><div class="code"><font color="black">     char *envp[]={
      "имя_1=значение_1",
      "имя_2=значение_2",
      ...
      "имя_M=значение_M",
      NULL  /* Признак конца списка */
     };
</font></div></PRE>
<P>Набор переменных среды оболочки в MS-DOS может меняться и контролироваться 
оператором SET: а) добавление или коррекция переменной 
<P><pre><div class="code"><font color="black">set имя=значение</font></div></pre> 
<P>б) исключение переменной из среды 
<P><pre><div class="code"><font color="black">set имя= </font></div></pre>
<P>в) вывод на экран переменных среды 
<P><pre><div class="code"><font color="black">set </font></div></pre>
<P>Доступ к аргументам командной строки вызова программы и переменным среды 
оболочки возможен в случае использования списка формальных параметров в головной 
функции main. Пример процедуры main с полным списком параметров: 
<P><PRE><div class="code">#include &lt;stdio.h&gt;
void main(int argc, char *argv[], char *envp[]) {
 int i;
 char **p;

 /* Печать параметров командной строки */

 for (i=0; i&lt;argc; i++)
  printf("\nАргумент %d): %s",i,argv[i]);

 /* Печать переменных среды оболочки */

  printf("\n\nПеременные среды оболочки:");
  for (p=envp; *p; p++)
   printf("\n   %s",*p);
}
</div></PRE>
<P>Результаты работы программы: 
<P><PRE><div class="code"><font color = "black">&nbsp;&nbsp;&nbsp;&nbsp;Аргумент 0): D:\RMPL\SP\P1.EXE
   &nbsp;Аргумент 1): x1
   &nbsp;Аргумент 2): x2
Переменные среды оболочки:
   winbootdir=C:\WINDOWS
   COMSPEC=C:\COMMAND.COM
   PROMPT=$p$g
   PATH=C:\WINDOWS;C:\WINDOWS\COMMAND;D:\LEXNEW;E:\CBUILDER\BIN
   TEMP=C:\TMP
   INCLUDE=e:\msdev\include
   LIB=e:\msdev\lib
   windir=C:\WINDOWS
   CMDLINE=p1.exe  x1 x2
</font></div></PRE>
<P>
<P>Результаты выполнения команды set: 
<P><PRE><div class="code"><font color="black">winbootdir=C:\WINDOWS
COMSPEC=C:\COMMAND.COM
PROMPT=$p$g
PATH=C:\WINDOWS;C:\WINDOWS\COMMAND;D:\LEXNEW;E:\CBUILDER\BIN
TEMP=C:\TMP
INCLUDE=e:\msdev\include
LIB=e:\msdev\lib
windir=C:\WINDOWS
</font></div></PRE>
<P>Функция main может вызываться рекурсивно из любой функции: 
<P><PRE><div class="code">     #include &lt;stdio.h&gt;

     int n=5;

     void main() {
       printf("\n %*i",n,n--);
      if (n) main();
     }
</div></PRE>
<P>Результаты работы программы: 
<P><PRE><div class="code"><font color = "black">
        5
       4
      3
     2
    1
</font></div></PRE>
<P>Следует отметить, что в языке C++ рекурсивный вызов функции main не всегда 
допускается. 
<P>
<P>
<P>

<div class="header"><A name=REF_7_2>7.2. Порождение и идентификация задач</A>
</div>
<P>В однопользовательской операционной системе MS-DOS процесс запуска задач 
(программ) активизируется интерпретатором команд COMMAND.COM с использованием по 
умолчанию консоли CON. Имеется возможность назначения вместо консоли других 
стандартных устройств COM1,COM2,... AUX: 
<P>1) оператором SHELL в файле CONFIG.SYS: 
<P><pre><div class="code"><font color = "black">SHELL=[[dos-drive:]dos-path]COMMAND.COMM [device] ... </font></div></pre>
<P>2) при запуске нового экземпляра COMMAND.COM; 
<P><pre><div class="code"><font color = "black">[[dos-drive:]dos-path]COMMAND.COMM [device] ... </font></div></pre>
<P>3) оператором CTTY: 
<P><pre><div class="code"><font color = "black">CTTY device </font></div></pre>
<P>Здесь device - текущее устройство ввода-вывода команд и сообщений 
пользователя (терминал). COMMAND.COM запускает корневую задачу иерархии 
процессов пользователя, интерпретируя входные строки 
<P><pre><div class="code"><font color = "black">[[dos-drive:]dos-path]exec_file p1 p2 ... [&gt;stdout] [&lt;stdin] </font></div></pre>
<P>как запрос на запуск исполнимого файла (программы или пакетного командного 
файла) exec_file с параметрами p1,p2,... и возможным перенаправлением 
стандартных потоков ввода-вывода. Любая задача может породить другие 
задачи-потомки. Примеры функций запуска задач-потомков: 
<P><PRE><div class="code">    int spawnv(int mode, // Режим запуска
               char *path, // Путь к загрузочному модулю
               char *argv[]); // Аргументы командной строки

    int spawnve(int mode, // Режим запуска
                char *path, // Путь к загрузочному модулю
                char *argv[], // Аргументы командной строки
                char *envp[]); // Переменные среды окружения
</div></PRE>
<P>Виды режимов запуска (Turbo-C, Borland C++ 3.1): 
<P>
<P>
<UL>
  <LI>P_WAIT - ожидание момента завершения задачи-потомка; 
  <LI>P_NOWAIT - не реализованное в MS-DOS параллельное выполнение задач 
  (применение приводит к ошибке); 
  <LI>P_OVERLAY - оверлейная загрузка задачи - потомка на место родителя 
  (трансформация задач). </LI></UL>
<P>При успешном запуске после исполнения задачи-потомка возвращается значение 
кода возврата, в противном случае - значение -1 и код ошибки в глобальной 
переменной errno: 
<P>
<UL>
  <LI>E2BIG - длинный список аргументов; 
  <LI>EINVAL - ошибочный аргумент; 
  <LI>ENOENT - файл не найден; 
  <LI>ENOEXEC - ошибка формата файла; 
  <LI>ENOMEM - нехватка памяти. </LI></UL>
<P>Задача-потомок в MS-DOS пользуется стандартными файлами stdin, stdout, stderr 
задачи родителя (их можно переопределить). 
<P>Пример программы: 
<P><PRE><div class="code">#include &lt;process.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
<P>
int main(void) {
 if (freopen("TEMP.OUT","w",stdout)) {
  if (spawnl(P_WAIT,"work.exe",NULL)&lt;0) {
   printf("\n Ошибка %d",errno);
   exit(errno);
  }
 }
 return 0;
}
</P></div></PRE>
<P>Приведенная программа моделирует ввод команды 
<P><pre><div class="code">work &gt; temp.out </div></pre>
<P>
<P>В MS-DOS доступны следующие виды внешнего вмешательства в процесс исполнения 
активной задачи: 
<P>
<UL>
  <LI>Ctrl+Break - снятие задачи; 
  <LI>Pause - приостановка. </LI></UL>
<P>Межзадачное взаимодействие, организуемое средствами MS-DOS, сводится лишь к 
образованию канала обмена данными через временный файл. Например, команда 
<P><pre><div class="code">dir|sort|more </div></pre>
<P>приводит к последовательному выполнению системных программ dir, sort, more и 
выдачи результата на устройство CON. Пусть файл ds.exe получен в результате 
трансляции программы 
<P><PRE><div class="code">     #include &lt;stdio.h&gt;

     void main() {
      int i;
      while ((i=getch())!=EOF)
       putchar(' '), putchar(i);
     }
</div></PRE>
<P>Команда 
<P><pre><div class="code">dir|ds|more </pre></div>
<P>позволит просмотреть результат работы программы dir в виде разреженного 
текста. 
<P>Функции семейства spawn в многозадачных операционных системах позволяют 
организовать динамическую параллельную структуру программы. Для образования 
динамической последовательной структуры можно воспользоваться функциями 
семейства exec: 
<P><PRE><div class="code">     int execl(char _FAR *__path, char _FAR *__arg0, ...);
     int execle(char _FAR *__path, char _FAR *__arg0, ...);
     int execlp(char _FAR *__path, char _FAR *__arg0, ...);

     int execlpe(char _FAR *__path, char _FAR *__arg0, ...);
     int execv(char _FAR *__path, char _FAR *__argv[]);
     int execve(char _FAR *__path, char _FAR *__argv[],
                char _FAR *_FAR *__env);
     int execvp(char _FAR *__path, char _FAR *__argv[]);
     int execvpe(char _FAR *__path, char _FAR *__argv[],
                 char _FAR *_FAR *__env);
</div></PRE>
<P>Такие функции возвращают код завершения задачи-потомка. Можно выполнить 
запуск задачи-потомка через вызов интерпретатора командных строк, используя 
функцию 
<P><pre><div class="code">int system(char *command);</div></pre> 
<P>Здесь строка command может содержать любую команду и/или директиву, 
обрабатываемую интерпретатором командных строк: 
<P><pre><div class="code"><font color = "black">system("dir&gt;test.txt"); </font></div></pre>
<P>(в MS-DOS команда dir выполняется непосредственно интерпретатором командных 
строк). 
<P>
<P>
<P>

<div class="header"><A name=REF_7_3></A>7.3. Завершение программ </div>
<P>Любая функция в языке С обычно завершается после выполнения последнего 
оператора в теле функции либо оператора return. Возврат из любой точки программы 
можно выполнить посредством вызова специальных библиотечных функций. Например, в 
файле stdlib.h определены функции: 
<DL>
  <DD>void exit(int status) - вывод содержимого буферов, закрытие всех файлов и 
  возврат в порождающий процесс кода завершения status; 
  <DD>void abort(void) - возврат в порождающий процесс с кодом завершения 3. 
  </DD></DL>
<P>
<P>

<div class="header"><A name=REF_7_4></A>7.4. Идентификация задач и виды межзадачных 
взаимодействий </div>
<P>В многозадачных средах каждая задача получает уникальный системный 
идентификатор (task ident). Например, в операционной системе QNX функции на 
языке C могут использовать глобальные переменные 
<P><PRE><div class="code">     unsigned int My_tid, /* Идентификатор текущей задачи */
                  Dads_tid, /* Идентификатор задачи - родителя */
                  My_nid; /* Номер узла вычислительной сети */
</div></PRE>
<P>(QNX - сетевая многозадачная многопользовательская операционная система, 
быстрореактивная версия операционной системы семейства UNIX) [1]. Во время 
исполнения задача-родитель информирована об идентификаторах потомков результатом 
функций порождения. Иногда требуется получить идентификатор некоторой задачи, не 
связанной с текущей процессом порождения. Например, это может потребоваться для 
обмена информацией между задачами. Для удобства установления идентификаторов 
задач QNX предоставляет возможность подсоединения к задаче системного имени в 
виде строки символов. Набор функций для работы с системными именами: 
<P><PRE><div class="code">     unsigned name_attach(char *name, unsigned node);
     unsigned name_detach(char *name, unsigned tid);
     unsigned name_locate(char *name, unsigned node, unsigned size);
</div></PRE>
<P>Если в качестве номера узла node указать нуль, то имя задачи будет 
глобальным, т.е. известным во всех узлах сети. В других случаях имя name 
локально на конкретном узле node. QNX поддерживает три механизма межзадачных 
связей: 
<UL>
  <LI>сообщения; 
  <LI>порты; 
  <LI>исключения. </LI></UL>
<P>
<P>
<P>
<HR SIZE=1 width="100%">
<A href="#REF_1_C">Начало</A> 
<p>
<div class="header"><CENTER><A name=REF_8></A>8. СИСТЕМНО ЗАВИСИМЫЕ КОНСТРУКЦИИ ЯЗЫКА С </CENTER></div>
<P>
<div class="header"><A name=REF_8_1></A>8.1. Системно зависимые расширения языка 
C </div>
<P>Наибольшая зависимость системы программирования на языке C от особенностей 
вычислительной среды проявляется в библиотеках стандартных функций. Система 
программирования языка С отражает особенности конкретной вычислительной среды 
посредством: 
<P>
<UL>
  <LI>дополнительных операторов; 
  <LI>атрибутов типа (данных и функций); 
  <LI>системно-определенных объектов (константы, переменные, функции); 
  <LI>макроопределений. </LI></UL>Далее рассмотрим примеры системно зависимых 
расширений применительно к системе программирования Borland C++ 3.1. 
<P>
<P>
<div class="header"><A name=REF_8_2></A>8.2. Понятие псевдо-регистров </div>
<P>Непосредственный доступ к регистрам процессора можно получить, используя 
зарезервированные идентификаторы: 
<P><PRE><div class="code"><font color = "black">     _AX    _AL    _AH    _SI   _ES
     _BX    _BL    _BH    _DI   _SS
     _CX    _CL    _CH    _BP   _CS
     _DX    _DL    _DH    _SP   _DS
</font></div></PRE>
<P>(набор идентификаторов в Borland C++ 3.1 дополнен обозначением регистра 
флагов _FLAGS, а в Borland C++ 4.0 - регистрами _EAX, _EBX, _ECX, _EDX,_ESI, 
_EDI, _ESP, _EBP и т.п.). Представленные идентификаторы без символа 
подчеркивания соответствуют стандартным мнемоническим обозначениям регистров 
микропроцессора. Псевдо-регистры используют, например, для обращения к функциям 
BIOS или MS-DOS посредством программного прерывания. 
<P>Пример обращения к функции BIOS: 
<P><PRE><div class="code">   /* Установка формы курсора в текстовом режиме работы дисплея */

     #include &lt;dos.h&gt;

     void cursor(int top_line, int bottom_line) {
      _CH=top_line;
      _CL=bottom_line;
      _AH=0x01;
      geninterrupt(0x10);
     }
</div></PRE>
<P>При работе с псевдо-регистрами следует учитывать наличие побочных эффектов: 
<P><PRE><div class="code">     #include &lt;dos.h&gt;

     char *msg="Проба пера...";

     void main() {
      _AH=0x09;
      _DX=FP_OFF(msg);
      _DS=FP_SEG(msg);
      geninterrupt(0x21);
     }
</div></PRE>
<P>Здесь присваивание регистров _DX и _DS проводится с временным использованием 
регистра _AX, приводящим к разрушению содержимого регистра _AH. В результате 
требуемая функция MS-DOS наверняка не будет указана. 
<P>
<P>

<div class="header"><A name=REF_8_3></A>8.3. Функции - обработчики прерываний </div>
<P>Функции обработки прерываний должны удовлетворять условиям, определяемыми 
аппаратурой. В Turbo-C MS-DOS такие функции должны описываться с атрибутом 
interrupt: 
<P><PRE><div class="code">     void interrupt int_06h(void);
     void interrupt (*interp)(void);
</div></PRE>
<P>Функция с атрибутом interrupt сохраняет при вызове все регистры процессора и 
завершается машинной командой IRET (возврат из обработчика прерываний). При 
компиляции таких функций необходимо отключать режимы диагностики о переполнении 
стека и использования регистровых переменных. Естественным здесь является 
отсутствие входных параметров и возвращаемых значений. Допускается использование 
глобальных объектов. Операция вызова рассматриваемых функций возможна: 
компилятор планирует программную имитацию аппаратных действий, связанных с 
сохранением и восстановлением регистра флагов. Механизм обработки прерываний 
строится на основе вектора прерываний, поэтому для любого типа прерывания 
необходимо задать соответствие "номер прерывания - адрес процедуры обработки 
прерываний". 
<P>Пример программы обработки прерываний от таймера: 
<P><PRE><div class="code">     #include &lt;stdio.h&gt;
     #include &lt;dos.h&gt;

     long Tick_Counter=100;

     void interrupt (*old_1ch)(void);

     void interrupt new_1ch(void) {
      Tick_Counter--;
      old_1ch(); /* Разрешенная операция вызова */
     }

     void main() {
      old_1ch=getvect(0x1c);
      setvect(0x1c,new_1ch);
      while (Tick_Counter&gt;0) {
       /******************************
        Произвольный набор операторов
       *******************************/
      }
      setvect(0x1c,old_1ch);
      printf("\nФИНИШ...");
      exit(0);
     }
</div></PRE>
<P>
<P>

<div class="header"><A name=REF_8_4></A>8.4. Дополнительные атрибуты 
указателей </div>
<P>Понятие указателя в языке C отражает адрес объекта. Однако в реальных 
вычислительных средах может отсутствовать взаимно однозначные соответствие 
математических и физических адресов памяти. Значения указателей формируются с 
учетом особенностей организации памяти. В шестнадцатирязрядных микропроцессорных 
системах, использующих относительную адресацию с базированием, физический адрес 
FA определяется следующим образом: 
<p><pre><div class="code"><font color = "black">FA=Segm*16+Offs,</font></div></pre> 
<P>где Segm - содержимое сегментного регистра, Offs - смещение относительно 
начала сегмента. Для внешнего представления значения FA принято использовать 
запись Segm:Offs. Таким образом, значение адреса A000:0000 соответствует 640 K. 
В большинстве случаев организация памяти программы учитывается автоматически, но 
учет конкретных особенностей задачи может потребовать назначения свойств 
указателей дополнительными атрибутами. Например, указатели объектов в 
программах, создаваемых в среде Turbo-C, имеют один из атрибутов: 
<UL>
  <LI>near - адрес в текущем сегменте ( смещение, 2 байта); 
  <LI>far - адрес в любом сегменте (сегмент:смещение, 4 байта), но размер 
  объекта не более 64 Кбайт; 
  <LI>huge - адрес в любом сегменте (сегмент:смещение, 4 байта), размер объекта 
  любой, но выполняется нормализация значения адреса для корректного выполнения 
  операций сравнения, инкремента и декремента. </LI></UL>Нормализация указателя с 
атрибутом huge заключается в представлении значения адреса единственным образом 
путем назначения минимально возможного "смещения" и максимально возможного 
"сегмента". По умолчанию указателю приписывается атрибут в зависимости от 
указанного при компиляции вида организации памяти программы. 
<P><PRE>               Характеристика моделей памяти в Turbo-C
--------T------------------T-----------------------------------
        ¦  Тип указателя   ¦        Количество сегментов
 Модель ¦  по умолчанию    ¦         размером 64 Кбайта
 памяти +--------T---------+------T-------T-------T------------
        ¦ Данные ¦ Функции ¦Данные¦Функции¦ Всего ¦ Один объект
--------+--------+---------+------+-------+-------+------------
 TINY   ¦ near   ¦ near    ¦   1  ¦    1  ¦    1  ¦        1
 SMALL  ¦ near   ¦ near    ¦   1  ¦    1  ¦    2  ¦        1
 MEDIUM ¦ near   ¦ far     ¦   1  ¦   &gt;1  ¦   &gt;1  ¦        1
 COMPACT¦ far    ¦ near    ¦  &gt;1  ¦    1  ¦   &gt;1  ¦        1
 LARGE  ¦ far    ¦ far     ¦  &gt;1  ¦   &gt;1  ¦   &gt;1  ¦        1
 HUGE   ¦ far    ¦ far     ¦  &gt;1  ¦   &gt;1  ¦   &gt;1  ¦       &gt;1
</PRE>
<P>Доступ к значениям "дальних" указателей реализуется посредством макрокоманд: 
<P>
<UL>
  <LI>void far *MK_FP(segm, offset) - образовать "дальний" указатель по заданным 
  значениям сегмента segm и смещения offset; 
  <LI>unsigned FP_SEG(far_pointer), 
  <LI>unsigned FP_OFF(far_pointer) - получить значения сегмента и смещения 
  заданного "дальнего" указателя far_pointer. </LI></UL>Перечисленные макрокоманды 
позволяют работать с памятью на основе абсолютных значений адресов, например: 
<P><PRE><div class="code">     char far *x=MK_FP(0,0x466);
     printf("\n Байт режима дисплея %#x",*x);
</div></PRE>
<P>Другая возможность учета механизма сегментации - использование явной привязки 
"ближних" указателей к сегментным регистрам специальными модификаторами типа 
указателей _ds, _es, _cs, _ss. Например, оператор 
<P><pre><div class="code">char _ss *x; </div></pre>
<P>объявляет указатель с атрибутом near для работы относительно базового 
регистра стека. Значение регистра стека можно загрузить, используя идентификатор 
псевдо-регистра _SS. Рассмотрим два варианта программы подсчета контрольной 
суммы двухбайтных слов области BIOS с целью идентификации ПЭВМ. Предположим, что 
интересующая нас область начинается с адреса F000:0000 и заканчивается в поле с 
адресом FFFF:000E. 
<P><PRE><div class="code">    /* Вариант 1. Использование "дальнего" указателя */

.    #include &lt;stdio.h&gt;
     #include &lt;dos.h&gt;

     void main(void) {
      long s=0;
      unsigned huge *p=(unsigned huge *)MK_FP(0xF000,0);
      while (p)
       s+=*p++;
      printf("\nКонтрольная сумма: %#x",s);
     }
</div></PRE>
<P>
<P><PRE><div class="code">    /* Вариант 2. Использование "ближнего" указателя */

     #include &lt;stdio.h&gt;
     #include &lt;dos.h&gt;

     void main(void) {
      long s=0;
      unsigned _es *p=(unsigned _es *)0;
      _ES=0xF000;
      do s+=*p++;
      while (p)
      printf("\nКонтрольная сумма: %#x",s);
     }
</div></PRE>
<P>Результаты работы двух вариантов программ: 
<P><pre><div class="code"><font color = "black">Контрольная сумма: 0x4636 </font></div></pre>
<P>Второй вариант программы предпочтительнее по быстродействию, но требует 
повышенного внимания при отладке. 
<P>
<P>
<P>

<div class="header"><A name=REF_8_5></A>8.5. Модификаторы типа объектов </div>
<P>Если размер объекта превышает размер одного сегмента, то приходится 
использовать модификатор huge, например: 
<P><pre><div class="code">long huge work_area[40000]; </div></pre>
<P>Очевидно, что такой объект должен быть глобальным. 
<P>Объект может размещаться в одном сегменте, но если подобных объектов 
несколько, то модификатор far заставит компилятор разместить их в отдельных 
сегментах: 
<P><pre><div class="code">int far table_1[20000];</div></pre> 
<P><pre><div class="code">int far table_2[20000];</div></pre> 
<P>Другие примеры комбинирования атрибутов: 
<P><PRE><div class="code">int i; /* Переменная в сегменте по умолчанию */
int far j; /* Переменная в дальнем сегменте */
int *ip1=&amp;i; /* Указатель в сегменте по умолчанию */
int far *ip2=&amp;i; /* Дальний указатель в сегменте по умолчанию */
int * far ip3=&amp;i; /* Стандартный указатель в дальнем сегменте */
int far * far ip4=&amp;i; /* Дальний указатель в дальнем сегменте */
void far f1(char *); /* Адресуемая дальним указателем функция */
int near f2(float); /* Адресуемая ближним указателем функция */
</div></PRE>
<P>
<P>
<P>

<div class="header"><A name=REF_8_6></A>8.6. Использование ассемблера </div>
<P>В тело любой функции на языке C можно встроить операторы языка ассемблера. В 
простейшем случае включение отдельного оператора оформляется так: 
<P><pre><div class="code">asm &lt;код операции&gt; &lt;операнды&gt; &lt;';' или '\n'&gt;</div></pre> 
<P>(код операции должен соответствовать мнемоническому обозначению кода команды 
на языке ассемблера, операндами могут быть константы, регистры или любые 
подходящие объекты программы на языке C). Несколько операторов ассемблера можно 
поместить в операторный блок: 
<P><PRE><div class="code">   asm {
    &lt;операторы языка ассемблера&gt;
   }
</div></PRE>
<P>Пример программы с включением операторов языка ассемблера: 
<P><PRE><div class="code">  #include &lt;stdio.h&gt;
<P>
  int Number_1=1997,
      Number_2=1998;
<P>
  void main() {
   printf("\n Number_1=%d, Number_2=%d ?!",Number_1,Number_2);
   asm {
    mov ax, Number_1
    mov dx, Number_2
    xor ax,dx
    xor dx,ax
    xor ax,dx
    mov Number_1, ax
    mov Number_2, dx
   }
   printf("\n Number_1=%d, Number_2=%d ??",Number_1,Number_2);
  }
</P></div></PRE>
<P>Вставка на ассемблере здесь реализует оператор языка С вида 
<P><PRE><div class="code">     Number_1^=Number_2^=Number_1^=Number_2;</div>
</PRE>
<P>
<P>
<P>
<HR SIZE=1 width="100%">

<A href="#REF_1_C">Начало</A>
<p> 

<div class="header"><CENTER><A name=REF_9></A>9. ВВОД-ВЫВОД ДАННЫХ </CENTER></div>
<P>
<div class="header"><A name=REF_9_1></A>9.1. Организация ввода-вывода данных в 
C </div>
<P>Система программирования С и операционная система MS-DOS поддерживают понятие 
файла как поименованной последовательности однобайтных символов. Операции с 
такими последовательностями рассматриваются как однонаправленная 
последовательная передача потоков символов. Состояние процесса ввода-вывода 
определяется смещением текущей позиции от начала файла, которое увеличивается 
после выполнения операции передачи данных. Исходное состояние устанавливается 
обязательной операцией открытия файла. Операция закрытия файла автоматически 
выполняется при завершении программы в MS-DOS, но при необходимости может 
запрашиваться явно. Любые операции, связанные с организацией ввода-вывода, на 
языке C программируются посредством обращения к библиотечным функциям. 
<P>Файл в операционной системе MS-DOS представляется тремя взаимосвязанными 
понятиями: 
<UL>
  <LI>идентификатор файла - символьная строка, имеющая согласно правил 
  именования файлов в MS-DOS формат 
  [диск:][путь\]имя_файла[.расширение_имени_файла] (здесь в квадратные скобки 
  заключены необязательные элементы); 
  <LI>номер обработчика (драйвера) ввода-вывода; 
  <LI>указатель блока управления файлом. </LI></UL>
<P>Набор средств ввода-вывода потоком в системе программирования C декларирован 
в файле stdio.h, где представлены: 
<UL>
  <LI>определение типа данных FILE (блока управления файлом); 
  <LI>определения стандартных параметров и констант; 
  <LI>макроопределения процедур ввода-вывода. </LI></UL>
<P>Среди определенных в файле stdio.h констант наибольший интерес представляют: 
<UL>
  <LI>NULL - значение пустого указателя; 
  <LI>EOF - признак конца файла (целая константа, равная -1). </LI></UL>
<P>Структура блока управления файлом ввода-вывода потоком: 
<P><PRE><div class="code">typedef struct {
 short          level;  /* Заполненность буфера потока */
 unsigned       flags;  /* Флажки состояния файла */
 char           fd;     /* Дескриптор файла(номер обработчика) */
 unsigned char  hold;   /* Возвращенный символ */
 short          bsize;  /* Размер буфера */
 unsigned char *buffer; /* Указатель буфера */
 unsigned char *curp;   /* Указатель текущей позиции */
 unsigned       istemp; /* Индикатор временного файла */
 short          token;  /* Рабочее поле процедур диагностики */
} FILE;
</div></PRE>
<P>Практическое программирование операций ввода-вывода обычно не требует явного 
обращения к элементам структуры FILE. Такие элементы используются библиотечными 
функциями и макроопределениями, например: 
<P><PRE><div class="code">     #define ferror(f)  ((f)-&gt;flags &amp; _F_ERR)
     #define feof(f)    ((f)-&gt;flags &amp; _F_EOF)
     #define fileno(f)  ((f)-&gt;fd)
</div></PRE>
<P>(интерпретация макроопределений приведена ниже). Любое использование файлов 
должно начинаться с открытия потока ввода-вывода и завершаться закрытием этого 
потока. Операция открытия устанавливает взаимно однозначное соответствие между 
идентификатором файла, его обработчиком и указателем блока управления 
вводом-выводом. В момент открытия проверяется корректность запроса на 
организацию потока ввода-вывода и проводится установка начальных значений 
переменных состояния потока. Операция закрытия выводит содержимое буферов 
потоков вывода и освобождает связанную с потоками системно распределенную 
память. После закрытия потока доступ к нему невозможен без операции открытия<BR>
<P>Перейдем к обзору важнейших библиотечных функций системы Turbo-C, 
предназначенных для организации ввода-вывода потоком. Функция FILE *fopen(char 
*path, char *mode) открывает поток ввода-вывода по полной спецификации файла 
path, режиму обработки файла mode и возвращает указатель успешно открытого файла 
или NULL при неудаче. Допустимые символы управляющей строки mode: 
<UL>
  <LI>'r' - открытие для чтения; 
  <LI>'w' - создание файла для вывода; 
  <LI>'a' - открытие для дозаписи в конце существующего файла или создания 
  нового файла; 
  <LI>'+' - разрешение обновления файла; 
  <LI>'b' - открытие двоичного файла; 
  <LI>'t' - открытие текстового файла. </LI></UL>
<P>Примеры управляющих строк: 
<UL>
  <LI>"rb" - двоичный файл ввода; 
  <LI>"w+t" - текстовый файл для вывода и обновления; 
  <LI>"a" - расширяемый существующий или создаваемый новый файл. </LI></UL>
<P>Tип файла (текстовый или двоичный) назначается по умолчанию значением 
глобальной переменной _fmode. 
<P>Текстовый файл характеризуется тем, что выводимый символ перевода строки 
заменяется парой символов возврата каретки и переводастроки, а при вводе 
выполняется обратное преобразование. Операции ввода-вывода для двоичных файлов 
выполняются без подобного преобразования. 
<P>Функция FILE *tmpfile(void) позволяет создать временный файл (на периоде 
активности программы). Иногда полезным оказывается получение уникального имени s 
для временного рабочего файла посредством вызова функции char *tmpnam(char *s). 
<P>Система программирования Turbo-C предоставляет возможность использования 
стандартных потоков ввода-вывода, которые по умолчанию автоматически открываются 
при запуске программы и закрываются при ее завершении. 
<P>Стандартные файлы: 
<UL>
  <LI>stdin - файл ввода; 
  <LI>stdout - файл вывода; 
  <LI>stderr - файл вывода сообщений об ошибках; 
  <LI>stdaux - файл дополнительных данных; 
  <LI>stdprn - файл печати. </LI></UL>
<P>По умолчанию файлы stdin, stdout и stderr назначаются на терминал. 
<P>Функция <font color = "blue">FILE *freopen(char *path, char *mode, FILE *stream)</font> закрывает 
открытый поток ввода вывода stream и назначает ему новый файл path в режиме 
mode. При нормальном открытии нового файла возвращается значение stream, в 
противном случае - NULL. 
<P>Функция <font color = "blue">freopen</font> используется, например, для переназначения потоков 
стандартных файлов ввода-вывода. 
<P>Функция <font color = "blue">int fclose(FILE *stream)</font> закрывает поток stream и возвращает при 
нормальном завершении 0, а в противном случае - EOF. 
<p><font color = "blue">Функция int fcloseall(void)</font> 
закрывает все открытые потоки ввода-вывода, за исключением stdin и stdout. 
Закрытие всех открытых потоков выполняет и функция <font color = "blue">void exit(int status)</font>. 
<P>Макрос <font color = "blue">int ferror(FILE *stream)</font> определяет тип ошибки в потоке stream и 
возвращает 0 при отсутствии ошибок. 
<P>Макрос <font color = "blue">int fileno(FILE *stream)</font> определяет дескриптор файла (номер 
обработчика), связанного с потоком stream. 
<P>Функция <font color = "blue">int eof(int handle)</font> и макрос <font color = "blue">int feof(stream)</font> проверяют состояние 
конца файла, связанного с обработчиком handle или потоком stream, и возвращают 
значения: 
<P>1 - конец файла; 
<P>0 - конец файла не достигнут; 
<P>-1 - обнаружены ошибки.<BR>
<P>Функция <font color = "blue">void clearerr (FILE *stream)</font> обнуляет признаки ошибок в потоке 
stream. 
<P>Функция <font color = "blue">int fflush(FILE *stream)</font> очищает буфер ввода-вывода потока stream: 
для вводного файла удаляются необработанные символы, а для выводного выполняются 
операции передачи символов из буфера на носитель данных. Функция <font color = "blue">int 
flushall(void)</font> выполняет те же действия для всех открытых потоков ввода-вывода. 
<P>Функция <font color = "blue">long filelength(int handle)</font> возвращает размер файла в байтах, 
связанного с обработчиком handle или -1 в случае ошибок. 
<P>Функция <font color = "blue">int rename(char *oldname, char *newname)</font> позволяет заменить имя файла 
oldname на новое имя newname. 
<P>Функция <font color = "blue">int unlink(char *path)</font> удаляет файл с полной спецификацией path. 
<P>Функция <font color = "blue">void rewind(FILE *stream)</font> устанавливает указатель текущей позиции 
потока stream на начало файла. 
<P>Функция <font color = "blue">int fseek(FILE *stream, long offset, int whence)</font> смещает указатель 
текущей позиции потока stream на величину offset относительно позиции, 
отсчитываемой в зависимости от значения параметра whence: 
<UL>
  <LI>SEEK_SET - от начала файла; 
  <LI>SEEK_CUR - от текущей позиции; 
  <LI>SEEK_END - от конца файла. </LI></UL>
<P>Константы SEEK_SET=0, SEEK_CUR=1 и SEEK_END=2 определены в файле stdio.h, где 
находится и определение функции fseek. 
<P>Функция <font color = "blue">int fsetpos(FILE *stream, long *pos)</font> присваивает указателю текущей 
позиции в потоке stream значение целого числа, адресуемого указателем pos, и 
возвращает 0 в случае успешного завершения. 
<P>Функция font color = "blue"long ftell(FILE *stream)</font> возвращает значение указателя текущей 
позиции, а в случае ошибок - EOF. 
<P>Функция <font color = "blue">int fgetpos (FILE *stream, long *pos)</font> присваивает значение указателя 
текущей позиции в потоке stream целому числу, адресуемому указателем pos, и 
возвращает 0 в случае успешного завершения. 
<P>Рассматриваемые далее функции позволяют управлять буферизацией процесса 
ввода-вывода. Возможно использование трех режимов буферизации обмена, 
запрашиваемых соответствующим значением параметра type функции <font color = "blue">setvbuf</font>: 
<UL>
  <LI>_IOFBF - полная буферизация - операция вывода на внешнее устройство 
  выполняется после полного заполнения буфера, а операция ввода при пустом 
  буфере включает попытку заполнения буфера с внешнего устройства; 
  <LI>_IOLBF - строчная буферизация - вывод содержимого полностью заполненного 
  буфера на внешнее устройство прерывается после передачи символа перевода 
  строки '\n', а ввод выполняется подобно режиму полной буферизации; 
  <LI>_IONBF - отсутствие буферизации - каждый оператор ввода-вывода реализует 
  обмен непосредственно с внешним устройством. </LI></UL>
<P>Функция <font color = "blue">int setvbuf(FILE *stream,char *buf,int type,int size)</font> устанавливает 
режим буферизации type для потока stream, причем для режимов полной или строчной 
буферизации размер буфера определяется параметром size, а адрес буфера - 
buf(допускается значение buf=NULL, тогда память будет захвачена с помощью 
функции malloc); при установке не буферизованного обмена параметры buf и size 
игнорируются. 
<P>Функция <font color = "blue">void setbuf(FILE *stream, char *buf)</font> устанавливает режим полной 
буферизации потока stream с буфером стандартного размера BUFSIZ, адресуемого 
непустым указателем buf; в случае обращения с параметром buf=NULL 
устанавливается режим не буферизованного обмена. 
<UL>Особенности использования функций setbuf и setvbuf: 
  <LI>буфер потока не может размещаться в автоматической памяти; 
  <LI>назначение нового буфера взамен автоматически создаваемого должно 
  производиться после открытия потока. </LI></UL>
<P>По умолчанию, потоки stdin и stdout являются не буферизованными. При их 
переопределении функцией freopen они становятся полностью буферизованными. 
Изменить вид буферизации можно и функциями setbuf и setvbuf. 
<P>При программировании ввода-вывода иногда полезным оказывается предвосхищение 
исключительных ситуаций посредством анализа текущей обстановки. 
<P>Например, функция <font color = "blue">int access(char *path,int mode)</font> выполняет проверку 
доступности файла, идентифицируемого символьной строкой path. Вид проверки 
задается параметром mode: 
<UL>
  <LI>0 - существование файла; 
  <LI>1 - исполняемость файла; 
  <LI>2 - разрешение записи; 
  <LI>4 - разрешение чтения; 
  <LI>6 - разрешение записи и чтения. </LI></UL>
<P>Функция <font color = "blue">access</font> возвращает нулевое значение в случае успешного результата 
проверки, в противном случае возвращается -1 и устанавливается значение 
глобальной переменной errno: 
<UL>
  <LI>ENOENT - путь либо файл не найден; 
  <LI>EACCES - доступ запрещен. </LI></UL>
<P>Функция <font color = "blue">char *searchpath(char *filename)</font> осуществляет поиск пути к файлу с 
именем filename сначала в текущем каталоге, а затем по всем каталогам, 
определенным переменной PATH среды окружения. Возвращаемое значение - указатель 
на строку с полным путем доступа к файлу или NULL при безуспешном поиске. 
<P>
<P>
<P>

<div class="header"><A name=REF_9_2></A>9.2. Бесформатный ввод-вывод </div>
<P>Рассматриваемые здесь функции ввода-вывода предназначены для обмена между 
полями данных в оперативной и внешней памяти. Понятие поля данных здесь 
относится к символу, слову, строке и блоку - непрерывной области, размер которой 
указан в байтах. 
<uL>
  <li>Функция <font color = "blue">int fgetc(FILE *stream)</font> возвращает очередной прочитанный символ из 
  потока stream, а в случае обнаружения конца файла или ошибок - значение EOF. 
  Аналогичные действия выполняет и макрос int getc(FILE *stream). 
  <li>Функция <font color = "blue">int fgetchar(void)</font> реализует оператор вызова функции fgetc(stdin). 

  <li>Функция <font color = "blue">int ungetc(int chr, FILE *stream)</font> позволяет вернуть прочитанный 
  символ chr в поток stream для последующего повторного считывания. Макрос int 
  ungetch(int chr) возвращает символ в поток stdin. 
  <li>Функция <font color = "blue">int getw(FILE *stream)</font> возвращает очередное прочитанное слово из 
  потока stream (без учета выравнивания), а в случае обнаружения конца файла или 
  ошибок - значение EOF. Для выявления исключительной ситуации при получении 
  значения EOF можно воспользоваться функциями feof или ferror. 
  <li>Функция <font color = "blue">char *fgets(char *s, int n, FILE *stream)</font> читает из потока stream 
  символы в строку s. Чтение прекращается после передачи n-1 символа либо 
  обнаружения символа новой строки '\n', который заменяется на символ конца 
  строки '\0'. 
  <li>Функция <font color = "blue">char *gets(char *s)</font> читает из потока stdin символы в строку s до 
  обнаружения символа '\n', который заменяется на символ '\0'. 
  <li>Функция <font color = "blue">int fputc(int chr, FILE *stream)</font> или макрос putc выводят символ с 
  внутренним кодом chr в поток stream, a функция int fputchar(int chr) - в поток 
  stdout. 
  <li>Функция <font color = "blue">int putw(int w, FILE *stream)</font> выводит слово w в поток stream. 
  <li>Функция <font color = "blue">int fputs(char *s, FILE *stream)</font> выводит строку символов s в поток 
  stream без символа конца строки '\0', а функция int puts(char *s) - в поток 
  stdout с заменой символа '\0' на символ новой строки '\n'. Возвращаемые 
  значения - последний выведенный символ или EOF в случае ошибок. </li></uL>
<P>Следующие функции выполняют операции над n одинаковыми элементами размером 
size байт блока, адресуемого указателеm ptr и потокомstream: 
<dL>
  <dd><font color = "blue">int fread(void *ptr,int size, int n,FILE *stream)</font> - чтение; 
  <dd><font color = "blue">int fwrite(void *ptr, int size, int n,FILE *stream)</font> - запись. 
</dd></dL>Возвращаемое значение - фактическое количество переданных элементов 
блока. 
<P><PRE><div class="code">/* Пример использования функций бесформатного ввода данных */ 
<P>#include &lt;stdio.h&gt;
#include &lt;io.h&gt;
#include &lt;alloc.h&gt;
<P>
void main() {
 FILE *inpfil;
 char *buffer;
 size_t n;
 if ((inpfil=fopen("b1.c","rb"))!=NULL) {
  n=(size_t)filelength(fileno(inpfil));
  if ((buffer=calloc(sizeof(*buffer),n))!=NULL) {
   fread(buffer,sizeof(*buffer),n,inpfil);
   printf("\n Файл в памяти");
  }
 }
}
</P></div></PRE>
<P>Бесформатный ввод-вывод отличается высоким быстродействием и часто 
применяется для операций с рабочими файлами, когда представленные в файле данные 
не подлежат визуальному просмотру или обработке с помощью текстовых редакторов. 
<P>
<P>
<P> 
<P>

<div class="header"><A name=REF_9_3></A>9.3. Форматный ввод-вывод </div>
<P>Средства форматного ввода-вывода предназначены для преобразования внешнего 
представления данных в текстовой форме во внутреннее кодовое преставление и 
наоборот в соответствии с заданным форматом преобразования. Функции форматного 
ввода-вывода используют три класса параметров - поток ввода-вывода, управляющую 
форматную строку и список идентификаторов объектов ввода-вывода. 
<P>Примеры декларации функций форматного вывода в Turbo-C: 
<P><PRE><div class="code">     int fprintf(FILE *stream, char *format, ...);
     int printf(char *format, ...);
     int cprintf(char *buffer, char *format, ...);
     int sprintf(char *buffer, char *format, ...);
     int vfprintf(FILE *stream, char *format, va_list arglist);
     int vprintf(char *format, va_list arglist);
     int vsprintf(char *buffer, char *format, va_list arglist).</div></pre>
<p>Примеры декларации функций форматного ввода в Turbo-C:
     <PRE><div class="code">int fscanf(FILE *stream, char *format, ...);
     int scanf(char *format, ...);
     int cscanf(char *buffer, char *format, ...);
     int sscanf(char *buffer, char *format, ...);
     int vfscanf(FILE *stream, char *format, va_list arglist);
     int vscanf(char *format, va_list arglist);
     int vsscanf(char *buffer, char *format, va_list arglist).
</div></PRE>
<P>Идентификация аргументов функций форматного ввода-вывода: 
<UL>
  <LI>stream - указатель потока; 
  <LI>format - указатель форматной строки; 
  <LI>buffer - указатель массива символов; 
  <LI>arglist - переменный список аргументов (способы использования переменных 
  списков аргументов в системе Turbo-C изложены в [1,2]). </LI></UL>
<P>Идентификация функций форматного ввода-вывода построена на основе добавления 
префикса к имени функции ввода scanf или вывода printf: 
<UL>
  <LI>отсутствие префикса - ввод из стандартного потока stdin и вывод в 
  стандартный поток stdout; 
  <LI>префикс f - операции с потоком stream; 
  <LI>префикс c - ввод с клавиатуры и вывод на экран терминала; 
  <LI>префикс s - операции с массивом символов buffer. 
  <LI>дополнительный префикс v - использование переменного списка аргументов. 
  </LI></UL>Функции форматного ввода-вывода потоком имеют переменное число 
аргументов. Количество и тип аргументов, определяющих передаваемые данные, 
должны соответствовать спецификации преобразования данных в форматной 
(управляющей) строке. При недостатке аргументов по отношению к количеству 
спецификаций данных в форматной строке результат работы функций ввода-вывода 
непредсказуем, а лишние аргументы игнорируются. 
<P>Форматная строка, определяющая способ преобразования данных, является 
стандартной в языке C символьной строкой. Рассмотрим вопросы программирования 
вывода данных потоком. Пример вывода данных: <PRE><div class="code">     ...
     int n,m;
      ...
     printf("\n Значение n=%d, m=%d",n,m);
     ...
</div></PRE>
<P>Здесь первый параметр - форматная строка, определенная символьной константой, 
а n и m - элементы множества выводимых данных. 
<P>Особенности интерпретации форматной строки функциями вывода printf: 
<UL>
  <LI>символы форматной строки разделяются на обычные и символы спецификации 
  преобразования; 
  <LI>обычные символы без преобразования копируются в поток вывода; 
  <LI>спецификация преобразования в форматной строке включает начальный символ 
  '%' и символы описания формата преобразования аргумента функции вывода. 
</LI></UL>
<P>Спецификация формата вывода данных: %[flags][width][.prec][mode]type (в 
квадратных скобках указаны необязательные элементы). Здесь: 
<UL>
  <LI>flags - флаги, определяющие выравнивание результата в поле вывода, символы 
  знака числа, десятичные точки, незначащие нули, восьмеричные и 
  шестнадцатеричные префиксы; 
  <LI>width - ширина поля вывода - минимальное количество выводимых символов, 
  дополняемых пробелами либо нулями; 
  <LI>prec - точность представления результата; 
  <LI>mode - модификатор размера поля преобразуемого аргумента; 
  <LI>type - тип преобразования. </LI></UL>
<P>Интерпретация обязательного элемента type: 
<UL>
  <LI>d - десятичное целое число со знаком (альтернатива i); 
  <LI>i - десятичное целое число со знаком (альтернатива d); 
  <LI>o - восьмеричное целое число без знака; 
  <LI>u - десятичное целое число без знака; 
  <LI>x - шестнадцатеричное целое число без знака, представленное строчными 
  символами; 
  <LI>X - шестнадцатеричное целое число без знака, представленное прописными 
  символами; 
  <LI>f - десятичное число со знаком с фиксированной точкой; 
  <LI>e - десятичное число со знаком с плавающей точкой, представленное в виде 
  [-]d.ddd e [+/-]ddd строчными символами; 
  <LI>g - наиболее короткий формат из e или f; 
  <LI>E - аналог формата e, представляемый прописными символами; 
  <LI>G - аналог формата g, представляемый прописными символами; 
  <LI>c - символ; 
  <LI>s - строка символов, ограниченная символом '\0' или [.prec]; 
  <LI>% - символ '%'; 
  <LI>p - значение указателя (формат вывода указателя типа near - YYYY, а 
  указателя типа far или huge - XXXX:YYYY, где X и Y - шестнадцатеричные цифры); 

  <LI>n - запоминание текущего количества выведенных символов в поле целого 
  типа, адресуемым очередным аргументом (например, оператор printf("%d%n 
  %d",i,&amp;j,k) помещает в переменную j количество символов в поле вывода 
  переменной i). </LI></UL>
<P>Интерпретация необязательных элементов flags: 
<UL>
  <LI>флаг '-' - выравнивание результата по левому краю и дополнение пробелами 
  справа; 
  <LI>флаг '+' - результат преобразования значений со знаком начинается с 
  символа '+' или '-'; 
  <LI>флаг ' ' (пробел) - результат преобразования положительных значений 
  начинается с пробела, а отрицательных - с символа '-'; 
  <LI>флаг '#' - вывод в альтернативной форме представления результата (при 
  использовании форматов c,s,d,i,u флаг '#' игнорируется; для формата o символ 
  '0' предшествует ненулевому значению, x или X - результат начинается с пары 
  символов "0x" или "0X", e,E,f - всегда используется десятичная точка, g или G 
  - аналогично e или E, но незначащие нули отсутствуют).<BR>
  <P></P></LI></UL>Флаги могут использоваться в произвольной комбинации, но флаг 
'+' обладает приоритетом перед флагом ' '. По умолчанию, результат 
преобразования выравнивается по правому краю и дополняется слева нулями или 
пробелами. 
<P>Интерпретация необязательного элемента width: 
<UL>
  <LI>n - вывод не менее n символов, дополненных, при необходимости, пробелами 
  (n - десятичная константа); 
  <LI>0n - вывод не менее n символов, дополненных, при необходимости, нулями 
  слева; 
  <LI>* - значение width определяется очередным аргументом функции.</LI></UL>
<P>
<UL></UL>По умолчанию, а также при недостаточной явно указанной ширине поля 
вывода, производится его расширение до размеров результата. Интерпретация 
необязательного элемента prec:
<P>
<UL>
  <LI>.0 - для форматов d,i,o,u и x устанавливается точность по умолчанию, а для 
  e, E и f десятичная точка не выводится; 
  <LI>.n - вывод не более n символов с округлением или усечением, в зависимости 
  от типа данных, результата; 
  <LI>* - значение prec определяется очередным аргументом функции. </LI></UL>
<P>
<UL>Интерпретация модификаторов mode: 
  <LI>F - аргумент рассматривается как указатель типа far; 
  <LI>N - аргумент рассматривается как указатель типа near; 
  <LI>h - аргумент, преобразуемый по формату d,i,o,u,x или X, имеет тип short 
  int; 
  <LI>l - аргумент, преобразуемый по формату o,u,x или X, имеет тип long int. 
  </LI></UL>В поле mode может записываться один из перечисленных символов - 
модификаторов. Применение модификаторов обязательно для корректного 
представления указателей и данных типов short int и long int. Каждая функция 
вывода возвращает количество выведенных символов, а в случае ошибки - значение 
EOF. Рассмотрим вопросы программирования ввода данных потоком. Пример ввода 
данных: <PRE><div class="code">     ...
     int n, m;
     ...
     scanf("%d%i",&amp;m,&amp;n);
     ...
</div></PRE>
<P>Здесь первый параметр - форматная строка, определенная символьной константой, 
а n и m - элементы множества вводимых данных. Отметим, что список аргументов 
функций семейства scanf состоит из указателей полей. Последнее обусловлено 
принятой в языке C схемой связи аргумент-параметр, где из-за передачи значений 
аргументов, а не их адресов, приходится при необходимости изменения функцией 
поля аргумента передавать указатель поля аргумента.<BR>
<P>Особенности интерпретации форматной строки функциями ввода scanf: 
<UL>
  <LI>символы форматной строки разделяются на неотображаемые и отображаемые 
  обычные символы и символы спецификации преобразования; 
  <LI>любой из неотображаемых символов ' ', '\t' и '\n' предписывает пропуск 
  всех символов входного потока до первого отображаемого символа; 
  <LI>любой символ, за исключением ' ', '\t', '\n' и '%', считается 
  отображаемым, а его появление в форматной строке предписывает проверку наличия 
  такого же символа во входном потоке; 
  <LI>спецификация преобразования в форматной строке включает начальный символ 
  '%' и символы описания формата преобразования аргумента функции ввода. 
</LI></UL>
<P>Спецификация формата ввода данных: %[*][width][mode]type (в квадратных 
скобках указаны необязательные элементы). Здесь:
<P>
<UL>
  <LI>символ '*' указывает на необходимость чтения данных из входного потока без 
  присваивания результата преобразования; 
  <LI>width - максимальное количество читаемых символов; 
  <LI>mode - явное назначение размера и типа поля, адресуемого аргументом 
  функции ввода; 
  <LI>type - тип преобразования. </LI></UL>
<P>
<UL>
  <LI>Интерпретация обязательного элемента type:
  <P></P>
  <LI>d или D - десятичное целое число со знаком типа int или long; 
  <LI>i или I - десятичное, восьмеричное или шестнадцатеричное целое число со 
  знаком типа int или long; 
  <LI>o или O - восьмеричное целое число без знака типа int или long; 
  <LI>u или U - десятичное целое число без знака типа int или long; 
  <LI>x или X - шестнадцатеричное целое число со знаком типа int или long; 
  <LI>f или F - десятичное число со знаком с фиксированной точкой; 
  <LI>e или E - десятичное число со знаком с плавающей точкой; 
  <LI>c - символ; 
  <LI>s - строка символов, ограниченная во входном потоке символом ' ' или '\n', 
  представляемая в памяти с дополнительным символом '\0' (лидирующие пустые 
  символы при вводе пропускаются); 
  <LI>p - значение указателя, представленное в форме YYYY (near) или XXXX:YYYY 
  (far или huge), где X и Y - шестнадцатеричные цифры; 
  <LI>n - запоминание текущего количества введенных символов в поле целого типа, 
  адресуемым очередным аргументом (например, оператор 
  scanf("%d%d%n%d",&amp;i,&amp;j,&amp;k,&amp;l) помещает в переменную k 
  количество символов, прочитанных при вводе переменных i и j). </LI></UL>
<P>Интерпретация элемента width: 
<P>n - ввод не более n символов (n - десятичная константа). 
<P>Интерпретация модификаторов mode аналогична ранее рассмотренной интерпретации 
для функций вывода printf, разница лишь в направлении передачи данных. 
<P>Особый случай преобразования - ввод символьных строк по образцу. Образец 
определяет множество допустимых символов во входном потоке и представляется 
строкой символов, заключенных в квадратные скобки. Если первым символом образца 
является '^', то допустимыми символами считаются все, кроме перечисленных далее 
в образце. Непрерывный в коде ASCI диапазон символов образца можно представить 
первым и последним символом, разделенными символом '-'.
<P>
<P>Примеры использования образца в спецификациях формата ввода: 
<UL>
  <LI>%[abcd] - перечисление допустимых символов; 
  <LI>%[a-d] - указание диапазона допустимых символов; 
  <LI>%[A-F0-9] - определение символов шестнадцатеричных чисел; 
  <LI>%[^0-9] - определение нецифровых символов. </LI></UL>
<P>Функции ввода данных семейства scanf прекращают обработку входного потока по 
следующим причинам: 
<UL>
  <LI>форматная строка обработана; 
  <LI>достигнут конец файла или обнаружен символ конца строки при вводе данных 
  из области памяти; 
  <LI>очередной символ во входном потоке не совпадает с отображаемым символом в 
  форматной строке. </LI></UL>
<P>Все разновидности функций scanf возвращают количество успешно введенных и 
размещенных в памяти данных (пропущенные поля входного потока в общую сумму не 
включаются). Если при чтении входного потока достигнут конец файла, а в случае 
ввода данных из памяти функциями ssanf или vssanf обнаружен символ конца строки 
'\0', то возвращается значение EOF. 
<P>
<P>
<HR SIZE=1 width="100%">
<p>
<A href="#REF_1_C">Начало</A> 

<div class="header"><CENTER><A name=REF_10></A>10. СТРУКТУРЫ ДАННЫХ </CENTER></div>
<P>
<div class="header"><A name=REF_10_1></A>10.1. Виды организации хранения данных в 
памяти </div>
<P>Любая система программирования предоставляет возможность манипулирования 
некоторым множеством структур данных. Например, в языке C рассматриваются 
скалярные переменные, массивы, строки и структуры как агрегаты данных. При 
разработке программ часто удобнее оперировать естественным по отношению к 
решаемой задаче понятием абстрактной структуры (множества, графа или сети, 
очереди, конечного автомата и т.п.). В случаях, когда программирование ведется 
не на специализированном языке, приходится вводить промежуточные структуры, 
надстраиваемые над памятью ЭВМ из элементов используемого языка. 
<P>Нижний уровень надстраиваемых структур (уровень хранения) данных может иметь 
векторную либо списковую организацию памяти. 
<P><strong>В е к т о р н а я</strong> память поддерживается почти всеми языками высокого уровня и 
предназначена для хранения массивов различной размерности. Каждому массиву 
выделяется н е п р е р ы в н ы й участок памяти достаточного размера. Адресация 
элементов массива определяется некоторой адресной функцией, связывающей адрес и 
индексы элемента. Подобным образом может быть организовано и представление 
агрегатов данных, где элементы не обязательно однородны, но размещаются 
последовательно. 
<P>Пример адресной функции для однородного трехмерного массива 
X(1...n1,1...n2,1...n3): 
<P><pre><div class="code">I(i,j,k)=n1*n2*(i-1)+n2*(j-1)+k, i={1...n1}, j={1...n2}, k={1...n3}.</div></pre> 
<P>Для размещения такого массива требуется область размером n1*n2*n3 элементов. 
Рассматривая такую область как вектор (массив) Y(1...n1*n2*n3), можно установить 
соответствие элемента массива X элементу памяти для его размещения: X(i,j,k) 
&lt;===&gt; Y(I(i,j,k)). 
<P>Элементы массива X размещаются в последовательности 
<P><pre><div class="code">X(1,1,1), X(1,1,2), X(1,1,3),... X(n1,n2,n3-1), X(n1,n2,n3).</div></pre> 
<P>Современные языки высокого уровня поддерживают понятие многомерного массива, 
отображая его подобным рассмотренному способом на непрерывную область памяти. 
При программировании на таких языках необходимость введения адресных функций 
возникает лишь в ситуациях, когда требуется изменить способ отображения с учетом 
особенностей конкретной задачи. 
<P>Например, пусть требуется обеспечить компактное представление верхней 
треугольной матрицы X с диагональю порядка n. 
<P>Адресная функция здесь 
<P><pre><div class="code">K(i,j)=(n-i/2)*(i-1)+j, i={1...n}, j={i...n}.</div></pre> 
<P>Для хранения элементов матрицы необходимо выделить в рабочей памяти массив 
Y(1...n*(n+1)/2), а для доступа к ним использовать отображение 
<P><pre><div class="code">X(i,j) &lt;===&gt; Y(K(i,j)), i={1...n}, j={i...n}</div></pre> 
<P>(допустимые комбинации значений индексов здесь строго фиксированы условиями 
задачи). 
<P><strong>С п и с к о в а я</strong> организация памяти применяется в случаях, когда возможность 
доступа к любому именованному элементу памяти не используется, а потребности 
задачи практически удовлетворяются лишь возможностью перехода от одного элемента 
данных к другому. Очевидно, что в таких случаях н е о б я з а т е л ь н о 
размещать последовательно обрабатываемые элементы в смежных областях памяти. Для 
адресации элементов данных достаточно каждый элемент дополнить полем ссылки 
(указателем) на область размещения следующего элемента и отдельно задать ссылку 
на первый элемент. 
<P>Использование указателей для связи элементов данных позволяет легко отразить 
различные виды взаимосвязей данных. Важным понятием при манипулировании 
указателями является значение "пустого" указателя, используемое для обнаружения 
конца последовательности связей. 
<P><strong>Линейный список (список)</strong> - организация некоторого множества элементов данных, 
при которой каждый элемент содержит собственно данные и указатель на 
расположение в памяти следующего элемента множества. 
<P><strong>Циклический список</strong>, в отличие от линейного, допускает многократное 
прохождение списка, начиная с любого элемента. 
<P><strong>Симметричный список</strong> позволяет организовать продвижение по связям в любом 
направлении и удобен для выполнения операций включения и исключения элементов в 
заданном месте. 
<P>Очевидно, что нет принципиальных ограничений на вид структур, представляемых 
списками. Если элементом списка является другой список, то говорят о списковых 
структурах. 
<P>Наиболее естественно и эффективно списки используются для представления 
множеств, элементы которых имеют переменную длину. Поле данных элемента списка в 
таких случаях включает указатель на размещение элемента множества. В общем 
случае, элемент списка должен содержать явно либо неявно механизм интерпретации 
поля данных. 
<P>Пример образования и использования списка на языке C: 
<P><PRE><div class="code">     #define N 100

     int   head;        /*  Указатель списка */
     int   next[N];     /*  Поля ссылок */
     float data[N];     /*  Поля данных */
<P>
     float Summa;   /* Текущее значение суммы */
<P>
 /* Построение списка положительных элементов */
<P>
     for (head=-1, i=0; i&lt;N; i++) {
      if (data[i] &gt; 0) {
       next[i]=head, head=i;
      }
     }


 /* Использование списка - суммирование полей данных */

     for (Summa=0, i=head; i&gt;=0; i=next[i])
      Summa+=data[i];
</P></div></PRE>
<P>
<P>Отметим наиболее существенные достоинства списков. 
<P>Во-первых, большое разнообразие и гибкость операций над списками: 
<uL>
<li>включение новых элементов; 
<li>исключение элементов; 
<li>объединение и разбиение списков произвольного размера; 
<li>переупорядочение элементов списка и другие операции. </li></ul>
<P>Во-вторых, операции над элементами списка и списками выполняются над 
указателями без перемещения полей данных. 
<P>Недостаток списков - неэффективность выполнения произвольного доступа к 
элементам. 
<P>
<P>
<P>

<div class="header"><A name=REF_10_2></A>10.2. Абстрактные структуры данных </div>
<P>Совокупность обрабатываемых элементов данных и взаимосвязей между ними вне 
аспекта физического размещения - абстрактная структура данных. 
<P>Примеры абстрактных структур: 
<UL>
  <LI>множества, 
  <LI>очереди и стеки, 
  <LI>строки (последовательность элементов некоторого алфавита), 
  <LI>графы и их важная разновидность - деревья, 
  <LI>таблицы и т.п. </LI></UL>
<P>Напомним определения некоторых абстрактных структур. 
<P><strong>М н о ж е с т в о</strong> - неупорядоченная совокупность элементов (данных). По 
определению множество не содержит повторяющихся элементов. Если значения 
элементов повторяются, то говорят о комплекте. 
<P>Очереди и стеки - множества, элементы которых упорядочены по времени 
включения. 
<P><strong>О ч е р е д ь</strong> предполагает доступность только того элемента, который был 
помещен в нее ранее других. 
<P>Очередь с двумя концами - дек, допускает выполнение операций записи - выборки 
с обоих концов. 
<P>В <strong>с т е к е</strong> доступен только тот элемент, который был помещен позже других. 
Обращение к стеку связано с одной единицей хранения - вершиной стека. 
<P>Конечная последовательность элементов некоторого алфавита - <strong>с т р о к а</strong>. 
<P>Ориентированный <strong>г р а ф</strong> - пара множеств вершин и дуг, где элементы множества 
дуг - упорядоченные пары вершин. Для нагруженного графа дополнительно 
определяется соответствующее каждой дуге значение (вес дуги). 
<P><strong>Дерево</strong> - частный случай ориентированного графа, где имеется лишь одна вершина 
с нулевой степенью захода, а остальные вершины имеют единичную степень захода 
(степень захода - число дуг, входящих в вершину графа). 
<P><strong>Т а б л и ц а</strong> - множество элементов, организованное таким образом, что каждый 
элемент и, возможно, его расположение однозначно определяются его ключом. В 
отличие от списков, элемент таблицы идентифицирует только самого себя. В 
контексте понятия систем баз данных таблица - базовый элемент реляционной модели 
данных, а ее элементы называют записями(кортежами). Идентификация записей 
ключами оправдана тем, что по существу решаемых задач обработки данных обычно 
для различения записей существенна только небольшая часть записи, называемая 
ключом. 
<P>Абстрактные структуры данных могут отображаться как в векторной, так и 
списковой памяти. Выбор вида организации памяти определяется задачами 
использования представляемых данных. 
<P>
<P>
<div class="header"><A name=REF_10_3></A>10.3. Отображение структур данных в 
памяти 
</div>
<P>Любые структуры данных могут отображаться в памяти, распределяемой как 
статически на этапе написания программы, так и динамически на этапе выполнения 
программы. Статическое распределение реализуется средствами отображения 
операционных объектов языка программирования на этапе трансляции и/или вызова 
программного модуля. Операционные объекты программ на языке C могут размещаться 
в статической, динамической (стековой) и регистровой памяти, но схема их 
размещения является статической. Динамическое распределение памяти ассоциируется 
с операциями порождения и уничтожения новых объектов по запросу программы, 
которая в языке C не реализована. Программист вынужден заниматься явным 
описанием таких операций посредством обращения к функциям захвата и освобождения 
областей памяти. 
<P>Рассмотрим набор библиотечных функций языка C, используемых для организации 
динамического распределения памяти (см. файл alloc.h,где декларировано и 
значение пустого указателя NULL): 
<UL>
  <LI>выделение памяти для размещения nelem объектов размером elsize байт и 
  заполнение полученной области нулями - функция 
  <LI>void *calloc(unsigned nelem, unsigned elsize) возвращает ука- затель на 
  распределенную область или NULL при нехватке памяти. 
  <LI>coreleft - получение размера неиспользуемой памяти в байтах: 
  <LI>unsigned coreleft(void) - модели tiny, small и medium, 
  <LI>unsigned long coreleft(void) - модели compact, large и huge; 
  <LI>free - освобождение блока памяти, адресуемого указателем blk: 
  <LI>void free(void *blk); 
  <LI>malloc - выделение области памяти для размещения блока размером nbytes 
  байт:
  <LI>void *malloc(unsigned nbytes) возвращает указатель на распределенную 
  область или NULL при нехватке памяти. 
  <LI>realloc - изменение размера размещенного по адресу blk блока на новое 
  значение nbytes и копирование, при необходимости, содержимого блока: 
  <LI>void *realloc(void *blk,unsigned nbytes) возвращает указатель на 
  перераспределенную область или NULL при нехватке памяти. </LI></UL>
<P>Представленные далее функции предназначены для операций над памятью, 
распределяемой в дальних областях памяти. Идентификаторы функций дополнительно 
снабжены префиксом far, а типы аргументов изменены с учетом возможности 
манипулирования большими размерами блоков памяти: <PRE><div class="code">     void far *farcalloc(unsigned long nelem, unsigned long elsize),
     unsigned long farcoreleft(void),
     void farfree(void far *blk),
     void far *farmalloc(unsigned long nbytes),
     void far *farrealloc(void far *blk, unsigned long nbytes).
</div></PRE>При использовании динамически распределяемой памяти следует учитывать, что 
освобождение памяти некоторой области не вызывает сжатия пустых областей. 
<P>
<P>
<P>

<div class="header"><A name=REF_10_4></A>10.4. Примеры представления структур 
данных </div>
<P>Базовым понятием любой абстрактной структуры является понятие множества. 
Множество может быть задано либо перечислением его элементов, либо назначением 
правила установления принадлежности любого объекта множеству. Множество можно 
представить в памяти как в виде массива, так и списка элементов. 
Зарезервированная для представления множества память может рассматриваться с 
точки зрения типа и значения хранящихся данных. 
<p>Использование типа данных - 
простейший и наиболее распространенный прием определения правила установления 
принадлежности множеству в программировании. Здесь адресуемый некоторым образом 
элемент памяти взаимно однозначно соответствует элементу множества. Понятие 
типа поддерживается на уровне используемого языка программирования. В языке С 
каждый операционный объект имеет атрибут типа. Динамическое порождение объектов 
осуществляется посредством захвата памяти, адресуемого указателями на объекты 
заданного типа (пример со структурой ARC приведен ниже). Уничтожение объекта 
означает освобождение области памяти для его представления. Выбор способа 
представления любой абстрактной структуры зависит от набора операций над 
данными. Например, над множествами могут выполняться операции объединения, 
пересечения, вычитания и другие. Элементарное действие при выполнении подобных 
операций - проверка вхождения некоторого значения в заданное множество. Такое 
действие реализуется процедурами поиска, вопросы построения которых рассмотрены 
ранее. 
<P><PRE><div class="code">/* Пример процедуры проверки вложенности множеств */

     int subsetis(int a[], int na, int b[], int nb) {
      int i;
      for (i=0; i&lt;na; i++) {
       if (psearch(b,nb,a[i])&lt;0) return(0);
      }
      return(1);
     }
</div></PRE>
<P>Очевидно, эффективность процедуры subsetis можно повысить, если упорядочить 
массивы a и b и использовать процедуру дихотомического поиска dsearch. 
<P><PRE><div class="code">/* Пример улучшенной процедуры проверки вложенности множеств */

     int subsetis(int a[], int na, int b[], int nb) {
      int dsearch(int x[], int nx, int y);
      int i,j;
      for (i=j=0; i&lt;na; i++) {
       if ((j=dsearch(b+j,nb-j,a[i]))&lt;0) return(0);
      }
      return(1);
     }
</div></PRE>
<P>Наиболее эффективно операция проверки принадлежности множеству числовых 
значений реализуется с использованием понятия характеристической функции. 
Характеристическая функция такого множества - массив логических величин, в 
котором элемент i указывает принадлежность значения i множеству. Подобно ранее 
рассмотренной процедуре поиска на основе инвертированного массива, операция 
проверки принадлежности при этом выполняется за один шаг. Использование 
характеристических функций позволяет реализовать операции объединения, 
пересечения или разности множеств посредством соответствующих элементарных 
логических операций над элементами массивов. В языке С нет понятия массива 
битов, поэтому характеристические массивы множеств приходится представлять 
целочисленными либо символьными массивами, а в случае ограничений по памяти 
выполнять программное моделирование массивов битов. Рассмотрим пример 
компактного представления характеристического массива множества целых 
неотрицательных чисел. 
<P><PRE><div class="code">/* Отображаемое множество неотрицательных целых чисел */

      int X[N];
      ...
/* Указатель характеристического массива */

      char *x_mask;

/* Рабочие переменные */
      int i,j
      ...
/* Захват памяти для характеристического массива */

      for (i=j=0; i&lt;N; i++) if (X[i]&gt;j) j=X[i];
      if ((x_mask=calloc(1,(++j&gt;&gt;3)+1))==NULL) {
       printf("\n Выход из-за нехватки памяти...");
       exit(1);
      }

/* Инициализация характеристического массива */

      for (i=0; i&lt;N; i++) {
       j=X[i], x_mask[(j&gt;&gt;3)]|=(1&lt;&lt;(j&amp;7));
      }
      ...
/* Функция проверки принадлежности значения z множеству X */

      int z_in_x(int z) {
       return((x_mask[(z&gt;&gt;3)]&amp;(1&lt;&lt;(z&amp;7)))? 1:0);
      }
</div></PRE>
<P>Существенными чертами очередей, деков и стеков является зависимость 
количества элементов от времени. Возможны два конкурирующих варианта стратегии 
распределения памяти: статическое распределение требует знания предельного 
размера множества, а динамическое влечет накладные расходы на манипулирование 
блоками памяти. Пример процедуры с динамическим распределением памяти: 
<P><PRE><div class="code">#include &lt;alloc.h&gt;
#include &lt;stdlib.h&gt;

/* Структура элемента списка дуг */

struct ARC {
 unsigned a; /* Начальная вершина дуги */
 unsigned b; /* Конечная вершина дуги */
 long     w; /* Вес дуги a-&gt;b */
 struct ARC *next; /* Указатель описания следующей дуги */
};

struct ARC *arcs=NULL; /* Указатель списка дуг графа */

/* Процедура ввода описания графа в виде списка дуг */

  void main(void) {
   unsigned A,B;
   long W;
   struct ARC *p;

   W=coreleft()/sizeof(struct ARC));
   printf("\nДопустимое количество дуг %ld",W);

/* Ввод списка дуг графа */

   while(printf("\n a,b,w-? "), scanf("%u,%u,%d",&amp;A,&amp;B,&amp;W)) {
    if ((p=(struct ARC *)malloc(sizeof(struct ARC)))==NULL)
     exit(1);
    p-&gt;next=arcs, arcs=p; p-&gt;a=A, p-&gt;b=B, p-&gt;w=W;
   }

/* Печать введенного списка дуг */

   printf("\nВведенный список дуг: \n");
   for (p=arcs; p!=NULL; p=p-&gt;next)
    printf("\n %u %u %d",p-&gt;a,p-&gt;b,p-&gt;w);


/* Освобождение памяти */

   while (arcs!=NULL) {
    p=arcs, arcs=p-&gt;next, free(p);
   }
  }

</div></PRE>
<P>Единственным видом из рассмотренных ранее абстрактных структур данных, для 
которого в языке C имеется операционный набор библиотечных функций, являются 
строки. 
<P>Строка в системах программирования на языке С - последовательность 
однобайтных символов, завершающаяся символом конца строки '\0'(внутренний код 
0). Очевидно, что такое представление обусловливает последовательную схему 
обработки элементов строки. 
<P>Набор групп операций над строками в системе программирования Turbo-C - 
изменение, связывание, сравнение, преобразование, копирование и поиск (описание 
функций приведено в файле string.h). 
<P>
<P>
<P>
<HR SIZE=1 width="100%">

<A href="#REF_1_C">Начало</A>
<p> 

<div class="header"><CENTER><A name=REF_11></A>11. СОРТИРОВКА И ПОИСК ДАННЫХ </CENTER></div>
<P>
<div class="header"><A name=REF_11_1></A>11.1. Характеристика проблемы 
сортировки </div>
<P><strong>С о р т и р о в к а</strong> - процесс упорядочения размещения данных в оперативной 
или внешней памяти в соответствии с заданным законом изменения ключевого 
признака на множестве адресов или номеров записей. Цель сортировки - 
установление соответствия между физическим и логическим порядками следования 
записей. 
<P>Логическая упорядоченность записей в последовательно организованных 
структурах данных может быть задана отношением между любыми двумя записями 
посредством назначения операции сравнения ключевых признаков. Обычно 
используются операции сравнения вида "не меньше" либо "не больше", определяющие 
соответственно упорядоченность записей по неубыванию либо невозрастанию значений 
ключевых признаков. 
<P>В общем случае запрос на сортировку данных должен включать правило проверки 
упорядоченности элементов любой пары записей. Цель операции сортировки - 
истинность условия упорядочения для всех пар записей. Очевидно, что все случаи 
сортировки можно свести к задаче упорядочения массива по возрастанию значений 
его элементов. 
<P>Процесс сортировки реализуется с проведением следующих операций: 
<UL>
  <LI>сравнение ключевых признаков записей; 
  <LI>пересылка содержимого записей. </LI></UL>
<P>Операция пересылки содержимого записей имеет более значимую трудоемкость по 
отношению к операции сравнения ключевых признаков. 
<P>Критерии оценки эффективности процедур сортировки: 
<UL>
  <LI>количество операций пересылки содержимого записей; 
  <LI>объем требуемой памяти помимо памяти исходного массива. </LI></UL>
<P>Теоретический предел оценки трудоемкости сортировки C= n*log2(n), где n - 
количество сортируемых элементов данных. 
<P>
<P>

<div class="header"><A name=REF_11_2></A>11.2. Методы внутренней сортировки </div>
<P>Здесь будут представлены основные идеи конструирования процедур сортировки, 
реализующих наиболее распространенные базовые методы упорядочения данных. 
<P>Рассмотрим задачу упорядочения массива целых чисел X={ x(i), i=0...n-1 } в 
порядке возрастания их значений. Представляемые процедуры сортировки написаны на 
языке C, их параметрами является указатель массива x и количество сортируемых 
элементов n. 
<P><strong>Метод "вставки"</strong>. Сущность метода "вставки": при рассмотрении элемента x(i) 
организуется его "вставка" в предварительно упорядоченное подмножество из (i-1) 
элемента, i=1...n-1. "Вставка" включает операции поиска места элемента x(i) и 
его последующего размещения с целью формирования очередного упорядоченного 
подмножества размерностью i. Упорядоченность подмножеств на каждой итерации 
предоставляет возможность совместить операции поиска и размещения в цикле 
просмотра текущего подмножества. <PRE><div class="code">
/* Пример процедуры сортировки методом вставки  */

     void insert(int x[], int n) {
      int i,j,t;
      for (i=1; i&lt;n; i++) {
       for (j=i; (j&gt;0)&amp;&amp;(x[j-1]&gt;x[j]); j--) {
        t=x[j-1], x[j-1]=x[j], x[j]=t;
       }
      }
     }

</div></PRE>Очевидно, что: 
<UL>
  <LI>в худшем случае, когда исходный массив упорядочен в обратном направлении, 
  количество операций сравнения и пересылки равно n*(n-1)/2; 
  <LI>в лучшем случае, когда исходный массив уже упорядочен, количество операций 
  сравнения равно n-1; 
  <LI>среднее количество операций n*n/4. </LI></UL>Отсюда следует, что 
вычислительная эффективность процедуры сортировки методом "вставки" далека от 
идеальной. Однако схема такой процедуры позволяет естественно включать ее в 
процесс обработки потока буферизуемого потока данных. 
<P><strong>Метод "пузырька"</strong> (обменный метод). Пусть цель сортировки - упорядочить массив 
чисел X={ x(i), i=0...n-1 } по возрастанию. Схема сортировки обменным методом: 
на первой итерации найти максимальное число и разместить его на последнем месте, 
на второй итерации - мак- симальное число в неотсортированном массиве из n-1 
элемента и так далее до тех пор, пока не будет упорядочен весь массив. 
<P>Термин "пузырек" ассоциируется с процессом поиска очередного максимального 
элемента, который совмещается с перемещением элементов массива. Текущее значение 
"пузырька" меняется по мере продвижения к окончательной позиции. Отличительная 
черта такой процедуры состоит в том, что итерации сортировки можно завершить, 
если не было зафиксировано ни одного обмена элементов. <PRE><div class="code">
/*  Пример простой процедуры сортировки обменным методом */

     void excngs(int x[], int n) {
      int i,j,t;
      do {
       for (j=0, i=1; i&lt;n; i++)
        if (x[i-1]&gt;x[i]) {
         t=x[i], x[i]=x[i-1], x[i-1]=t, j=i;
        }
      } while (j);
     }

</div></PRE>
<P>Очевидно, что на каждой итерации сортировки выявляется дополнительная 
информация об упорядоченности массива. Ниже приводится одна из наиболее 
совершенных версий процедур сортировки обменным методом. 
<P><PRE><div class="code">
/*  Пример улучшенной процедуры сортировки обменным методом */

     void shakers(int x[], int n) {
      int i,j,L,R,t;
      L=1, R=j=n-1;
      while (L&lt;=R) {
       for (i=R; i&gt;=L; i--) {
        if (x[i-1]&gt;x[i]) {
         t=x[i-1], x[i-1]=x[i], x[i]=t, j=i;
        }
       }
       L=j+1;
       for (i=L; i&lt;=R; i++) {
        if (x[i-1]&gt;x[i]) {
         t=x[i-1], x[i-1]=x[i], x[i]=t, j=i;
        }
       }
       R=j-1;
      }
     }

</div></PRE>
<P>Эффективность метода "пузырька" в худшем и среднем случаях аналогична методу 
"вставки". 
<P><strong>Метод Шелла</strong>. Трудоемкость сортировки ранее рассмотренными методами зависит 
квадратично от размерности сортируемого массива. Идея метода Шелла базируется на 
разбиении исходной задачи на подзадачи сортировки массивов меньшей размерности. 
Сортируемый массив здесь последовательно разбивается на ряд групп, каждая из 
которых упорядочивается по методу "вставки". Разбиение на группы продолжается до 
тех пор, пока не будет образована группа, совпадающая по размеру с исходным 
массивом. На каждом этапе разбиения размер групп увеличивается, их количество 
сокращается, но степень упорядоченности массива повышается. Эффективность метода 
обусловлена сокращением общего количества пересылок записей.
<P>Рассмотрим схему алгоритма сортировки по методу Шелла. 
<P>Шаг 1. Положим начальный шаг группы a(i)=[n/2], i=1, где [x] - операция 
выделения целой части числа x. 
<P>Шаг 2. Разделим исходный массив на подмножества размером a(i) (на первом шаге 
получится два подмножества, если значение n четно, в противном случае третье 
подмножество будет состоять из одного элемента x(n)). 
<P>Шаг 3. Образуем группы из элементов, имеющих одинаковые номера (индексы) 
внутри выделенных подмножеств (размер групп, за исключением, возможно, первой, 
равен 2*i, где i - номер шага). 
<P>Шаг 4. Проведем упорядочение элементов внутри каждой группы, используя метод 
"вставки". 
<P>Шаг 5. Если шаг группы а(i)&gt;2, то установим новый шаг группы 
a(i+1)=[a(i)/2] и выполним возврат к шагу 2, в противном случае сортировка 
завершена. 
<P>Процедура образования подмножеств может быть произвольной, если гарантируется 
на последнем этапе применение процедуры сортировки методом "вставки" к исходному 
множеству данных. 
<P><PRE><div class="code">
/*  Пример процедуры сортировки методом Шелла */

     void shells(int x[], int n) {
      int i,j,k,m,t;
      if (n&lt;=1) return;
      for (k=1; k&lt;=n; k&lt;=1);
      for (m=k-1; m; m&gt;&gt;=1) {
       for (k=n-m, j=0; j&lt;k; j++)
        for (i=j; (i&gt;=0)&amp;&amp;(x[i+m]&lt;x[i]); i-=m) {
         t=x[i+m], x[i+m]=x[i], x[i]=t;
        }
      }
     }
</div></PRE>
<P>Трудоемкость сортировки по методу Шелла в среднем оценивается зависимостью 
n**(3/2)/2. 
<P>Наиболее эффективным по быстродействию методом сортировки является метод так 
называемой <strong>"быстрой" сортировки Хоара</strong>. Основная идея метода быстрой сортировки 
основывается на перестановке элементов в последовательности, зависящей от 
расстояния. Например, для массива n элементов, первоначально размещенных в 
обратном порядке, количество пересылок равно n/2, если вначале поменять местами 
левый и правый элементы, а затем последовательно продолжить движение с обеих 
сторон. Схема процедуры быстрой сортировки базируется на рекурсивном разделении 
исходного массива на частично упорядоченные подмножества до тех пор, пока каждое 
из подмножеств не будет состоять из одного элемента. 
<P><PRE><div class="code">/*  Пример процедуры быстрой сортировки */

     void qsorts(int x[], int n) {
      void sort(int a[], int L, int R);

 /* Вызов рекурсивной процедуры сортировки */
      sort(x,0,n-1);
     }

 /* Рекурсивная процедура быстрой сортировки */

     void sort(int a[], int L, int R) {
      int i,j,x,t;
      i=L, j=R, x=a[(L+R)/2];
      do {
       while (a[i]&lt;x) i++;
       while (x&lt;a[j]) j--;
       if (i&lt;=j) {
        t=a[i], a[i++]=a[j], a[j--]=t;
       }
      } while (i&lt;=j);
      if (L&lt;j) sort(a,L,j);
      if (i&lt;R) sort(a,i,R);
     }

</div></PRE>Вычислительная сложность процедуры быстрой сортировки оценивается 
зависимостью 2*log(2)*n*log2(n). 
<P>

<div class="header"><A name=REF_11_3></A>11.3. Поиск данных </div>
<P><strong>Поиск данных</strong> - процесс выделения из некоторого множества записей 
определенного подмножества, элементы которого удовлетворяют заранее заданному 
условию. Область определения условия поиска включает элементы записи. Любую из 
разновидностей задач поиска (например, по- иск по совпадению, интервалу, 
близости или логическому выражению ) можно свести к задаче поиска по совпадению 
некоторого эталонного значения (ключа поиска) со значением ключа записи. 
<P>Эффективность методов поиска оценивается числом сравнений пар признаков, 
проведенных до момента окончания поиска. При сравнении различных методов поиска 
моментом его окончания принято считать момент обнаружения первой требуемой 
записи. 
<P>В общем случае эффективность поиска зависит от организации записей в массиве 
и метода доступа к отдельным записям. Для последовательно организованных 
массивов наилучшие условия поиска соответствуют упорядоченности записей по 
возрастанию либо убыванию ключевого признака. 
<P>Параметрами представленных далее процедур поиска являются указатель массива 
целых чисел a, количество его элементов n и искомое(эталонное) значение b. 
Возвращаемое значение - индекс элемента массива x, совпадающего с искомым 
значением b, а в случае неудачного поиска - значение -1. 
<P><PRE><div class="code">
/*  Пример процедуры последовательного поиска по совпадению
    в неупорядоченном линейном массиве */

    int psearch(int a[], int n, int b) {
      for (int i=0, i&lt;n; i++)
       if (a[i]==b) return i;
      return -1;
     }
</div></PRE>
<P>Наиболее эффективным методом поиска произвольных данных в поcледовательно 
организованных упорядоченных массивах является <strong>дихотомический метод (метод 
двоичного поиска).</strong> 
<P><PRE><div class="code">
/*  Пример процедуры дихотомического поиска по совпадению
    в упорядоченном по возрастанию линейном массиве */

     int dsearch(int a[], int n, int b) {
      int i,j,k;
      if (n&lt;1) return -1;
      j=0, k=n-1;
      while (j&lt;k) {
       i=(j+k)&gt;&gt;1;
       if (a[i]&lt;b) j=i+1;
       else k=i;
      }
      return (a[j]!=b)? -1:j;
     }

</div></PRE>
<P>Вычислительная трудоемкость процедур дихотомического поиска - log2(n) 
итераций поиска. 
<P>Рассмотрим другой метод поиска в упорядоченном массиве - <strong>последовательный 
перебор с некоторым шагом</strong>. Вначале здесь выбирается некоторый шаг просмотра m, 
задающий величину интервала записей. Далее последовательно анализируются ключи 
записей с номерами 1,m+1,2m+1,... n. При обнаружении интервала с требуемой 
записью организуется последовательный поиск внутри этого интервала. 
<P>Очевидно, что число операций сравнения составляет в среднем L(n,m)=(n/m+m)/2, 
откуда легко определить оптимальную величину шага просмотра m'=n**(1/2). 
<P>Вычислительная трудоемкость процедуры последовательного поиска с равномерным 
оптимальным шагом - n**(1/2) итераций поиска. 
<P>Аналогичный по эффективности метод поиска - использование справочника 
размещения записей. 
<P>Наиболее эффективный поиск реализуется на основе <strong>адресной функции</strong> вида 
i=f(p), где i - номер или адрес записи, p - значение ключа поиска. 
<P>Например, пусть ключи записей принимают значения в интервале[a,b]. Очевидно, 
что количество записей здесь не превышает значения (b-a+1). Предполагая, что для 
хранения записей используется линейный массив X(0...b-a), можно предложить для 
адресации записей зависимость i=(p-a). 
<P>Использование адресной функции предоставляет возможность доступа к требуемой 
записи за один шаг, однако, на практике не всегда удается найти подходящий вид 
зависимости f(p). 
<P>Вырожденный случай адресной функции i=p соответствует понятию 
инвертированного массива. Рассмотрим пример построения и использования 
инвертированного массива. 
<P><PRE><div class="code">
/* Пример исходного массива целых чисел */
     int x[]={3,5,1,7,9};
/* Размерность исходного массива */
     int n=sizeof(x)/sizeof(*x);
     ...
/* Указатель инвертированного массива */
     int *y;
/* Размерность инвертированного массива */
     int m;
     ...
/* Создание инвертированного массива */

    void prepar(int x[], int n, int *y) {
     int i,m;
/* Оценка размерности инвертированного массива */
     for (i=0; i&lt;n; i++)
      if (x[i]&gt;m) m=x[i];
/* Захват памяти для размещения инвертированного массива */
     if ((y=malloc(m*sizeof(*y)))==NULL) return;
/* Инициализация инвертированного массива */
     for (i=0; i&lt;m; i++) y[i]=m;
/* Окончательное формирование инвертированного массива */
     for (i=0; i&lt;n; i++) y[x[i]]=i;
    }
    ...
/*  Процедура поиска в инвертированном массиве */

    int invsrc(int y[], int m, int b) {
     return (b&lt;m)? y[b]: -1;
    }

</div></PRE>Рассмотренные здесь процедуры поиска не учитывают частоту выборки 
конкретных данных. Очевидно, что возможно размещение данных с учетом частоты их 
использования, при котором среднее время поиска будет минимальным. Например, 
данные могут быть связаны в древовидную структуру, вид которой определяется 
априорными частотами выборки. 
<P>
<P>
<P>

<div class="header"><A name=REF_11_4></A>11.4. Cтандартные процедуры сортировки и поиска 
данных </div>
<P>Рассмотрим набор библиотечных процедур поиска и сортировки данных в системе 
программирования Turbo-C. Представляемые процедуры предназначены для обработки 
массивов последовательно размещенных в памяти одинаковых по размеру элементов 
данных. Внутреннее представление данных может быть произвольным, но программист 
должен определить понятие ключа сортировки либо поиска посредством задания 
процедуры-функции проверки порядка следования любой пары элементов массива. 
<P>Мнемонические обозначения аргументов библиотечных функций сортировки и поиска 
данных: 
<UL>
  <LI>base - указатель последовательного массива данных в памяти; 
  <LI>nelem - количество элементов данных; 
  <LI>width - длина элемента данных в байтах; 
  <LI>fcmp - указатель функции сравнения элементов данных; 
  <LI>x,y - указатели аргументов функции fcmp; 
  <LI>key - эталонный элемент процедур поиска данных; 
  <LI>pnelem - указатель поля, содержащего количество элементов данных. </LI></UL>
<P>Декларация функций поиска и сортировки данных: 
<P><PRE><div class="code">
/* Cортировка линейного массива по возрастанию
   значений ключевых элементов */

     void qsort(void *base, int nelen, int width,
                int (*fcmp)(void *x, void *y));

/* Дихотомический поиск в линейном массиве,
   упорядоченном по возрастанию ключевых элементов */

     void *bsearch(void *key, void *base, int nelen, int width,
                   int (*fcmp)(void *x, void *y));

/* Последовательный поиск в линейном неупорядоченном массиве
   с добавлением отсутствующих элементов данных */

     void *lsearch(void *key, void *base, int *pnelen, int width,
                   int (*fcmp)(void *x, void *y));

/* Последовательный поиск в линейном неупорядоченном массиве */

     void *lfind(void *key, void *base, int *pnelen, int width,
                 int (*fcmp)(void *x, void *y));

</div></PRE>Особенности использования функций поиска и сортировки: 
<UL>
  <LI>процедура-функция *fcmp должна возвращать целочисленное значение 
  K(*x)-K(*y), где K(z) - значение ключа элемента данных z (абсолютная величина 
  получаемой разности принципиального значения не имеет, учитывается лишь ее 
  знак для установления относительного порядка следования элементов данныx *x и 
  *y при условии упорядочения массива по возрастанию значений ключей - знак '-' 
  означает, что элемент *x предшествует элементу *y, знак '+' - элемент *x 
  следует за элементом *y, а нуль означает совпадение ключей элементов *x и *y); 

  <LI>процедуры поиска bsearch и lfind возвращают указатель на первый найденный 
  элемент данных или 0 (пустой указатель NULL) в случае неудачи; 
  <LI>процедурa поиска lsearch возвращает указатель на первый найденный элемент, 
  а в случае неудачи - на место размещения добавленного в конец массива 
  элемента; 
  <LI>поиск второго и последующих элементов данных с совпадающими значениями 
  ключа возможен посредством рекуррентного обращения к функции поиска с 
  коррекцией на каждом шаге значений указателя массива и количества оставшихся 
  элементов. </LI></UL>
<P>Примеры использования процедур поиска и сортировки <PRE><div class="code">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char *x[]={
 "3","1","2","5","4"
};

void print(char **x, int n, char *t) {
 int i;
 printf("\n %s:",t);
 for (i=0; i&lt;n; i++)
  printf(" %s",x[i]);
}

int fcmp(void *x, void *y) {
 return strcmp(*(char **)x,*(char **)y);
}

void main() {
 int n=sizeof(x)/sizeof(*x);
 print(x,n," Вход");
 qsort(x,n,sizeof(*x),fcmp);
 print(x,n,"Выход");
}

<div></PRE>Результаты работы программы: 
<P><PRE><div class="code"><font color="black">  Вход: 3 1 2 5 4
  Выход: 1 2 3 4 5

</font></div></PRE>
<P>Поиск в строках символов можно выполнить обращением к функциям strchr, 
strstr, strbrk, strtok и др. (см. файл string.h). 
<P>
<P>
<P>
<HR SIZE=1 width="100%">

<A href="#REF_1_C">Начало</A>
<p> 

<div class="header"><CENTER><A name=REF_12></A>12. ПРИМЕРЫ РЕШЕНИЯ ЗАДАЧ СИСТЕМНОГО ПРОГРАММИРОВАНИЯ </CENTER></div>
<P>
<div class="header"><A name=REF_12_1></A>12.1. Анализ схемы распределения памяти в 
MS-DOS 
</div>
<P>Пусть возникла необходимость оценки схемы использования памяти программами, 
загруженных любым способом в вычислительной среде MS-DOS. В такой ОС любая 
загружаемая программа первоначально захватывает всю память, но затем 
неиспользуемая память выделяется в отдельный блок, используемый для 
динамического перераспределения. Динамическое перераспределение обычно ведется 
посредством обращения к ОС через программное прерывание 0x21 со следующими 
видами запросов: 
<UL>
  <LI>выделить блок памяти указанного размера; 
  <LI>освободить блок памяти; 
  <LI>перераспределить блок памяти (уменьшить либо увеличить его размер). 
</LI></UL>
<P>Модуль обработки прерывания 0x21 различает перечисленные запросы по коду, 
помещаемому в регистр _AH (0x48, 0x49 или 0x4a). Программист на языке С может 
воспользоваться для тех же целей обращением к библиотечным функциям, например, 
malloc, free или realloc, декларированными в файле alloc.h. 
<P>Механизм управления памятью в MS DOS строится на основе однотипного 
представления любого ее блока в виде следующей структуры данных: 
<P><PRE><div class="code">
struct Memory_Control_Block { /* Структура блока памяти */
 char type; /* Тип: 'M' - промежуточный, 'Z' - последний блок */
 unsigned int ownr; /* PSP: cегментный адрес владельца */
 unsigned int size; /* Размер блока памяти в параграфах (16 байт) */
 char reserved[11]; /* Резервируемая область */
 char area[1]; /* Начало области памяти для использования */
};

</div></PRE>
<P>Первые 16 байт называются <strong>блоком управления памятью</strong> (Memory Control Block - 
MCB). Функции типа alloc возвращают указатель на "область памяти для прикладных 
программ", а функции типа free по такому адресу обнуляют с учетом известного 
смещения поле "указатель владельца" и/или корректируют поле типа. 
<P>Все блоки памяти оказываются выравненными на границу параграфа, а размер их 
кратен размеру параграфа (16 байтам). ОС может просматривать блоки только 
последовательно - последующий блок отыскивается путем смещения на размер 
текущего блока и его MCB. Освобождение памяти возможно только от конца 
последовательности. 
<P>В Turbo-C можно получить сегментный адрес своей программы (Program Segment 
Prefix - PSP), используя значение глобальной системно определенной переменной 
<P><pre><div class="code">unsigned int _psp;</div></pre> 
<P>Зная свой PSP, можно программировать нетривиальное распределение оставшейся 
памяти. 
<P>Если требуется анализ списка всех блоков памяти, то необходимо иметь адрес 
первого выделенного блока памяти. Такой адрес можно получить косвенным путем, 
если воспользоваться недокументированной функцией 0x52 прерывания 0x21 MS-DOS. 
<P>Результатом обращения к такой функции являются помещаемый в регистр _ES 
сегментный адрес, а в регистр _ВХ - увеличенное на 2 значение смещения области 
со следующей важной системной информацией: 
<DL>
<DD>1) сегментный адрес первого блока памяти (смещение от начала области 0 байт, 
размер - 2 байта); 
<dd>2) смещение и сегментный адрес описания устройств прямого доступа (смещение 
от начала - 2 байта, размер - 4 байта); 
<DD>3) смещение и сегментный адрес описания первого драйвера из списка драйверов 
устройств (смещение от начала - 36 байт, размер - 4 байта) и др. </dd></dl>
<P>Рассмотрим пример программы, которая позволяет выделить: 
<UL>
  <LI>выделенные ОС блоки памяти; 
  <LI>имена загруженных в память программ; 
  <LI>содержимое среды оболочки для каждой программы. </LI></UL>
<P>Сегментный адрес среды оболочки легко определяется по документированному 
описанию PSP - двухбайтное поле со смещением 0x2c. Среда окружения 
представляется последовательно размещенными строками символов с нулевым символом 
в качестве признака кoнца строки. Признак конца данных среды окружения - пустая 
строка. 
<P>Пример содержимого среды окружения: 
<P><pre><div class="code"><font color="black">COMSPEC=C:\COMAND.COM\0PROMPT=$P$G\0\0 </font></div></pre>
<P>После пары нулевых символов стандартно размещается значение 0x0001, за 
которым следует строка символов с именем пути и файла программы. 
<P><PRE><div class="code">
#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
struct { /* Структура блока памяти */
 char type;          /* Тип блока */
 unsigned int ownr;  /* Указатель владельца */
 unsigned int size;  /* Размер блока памяти */
 char reserved[11];  /* Резервируемая область */
 char area[1];       /* Начало блока памяти */
} far *mcb;

struct work { /* Структура описания имени файла программы */
 int mark; /* Признак имени файла программы */
 char name[1]; /* Начало строки имени файла программы */
} far *wrk;

void main(void) {
 unsigned int es, ax, bx, i;
 int far *env;
 char far *end;

 /* Поиск указателя списка блоков памяти */

  _AH=0x52;
  geninterrupt(0x21);
  bx=_BX-2;  /* Выделение смещения и сегмента */
  es=_ES;    /*  указателя системной области  */
  ax=peek(es,bx); /* Чтение сегментного адреса первого MCB */

 /* Просмотр блоков памяти */

  for (es=0;;es=1) {
   mcb=MK_FP(ax,0); /* Формирование указателя текущего MCB */
   printf("\nАдрес блока %p",mcb);
   printf("\nТип блока \'%c\'",mcb-&gt;type);
   printf("\nВладелец %4x",mcb-&gt;ownr);
   printf("\nРазмер блока %u",mcb-&gt;size);

  /* Вывод данных о программе-владельце блока */

   if (es &amp;&amp; mcb-&gt;ownr) { /* Проверка наличия владельца */

   /* Вывод строк оболочки */

    printf("\nСодержимое среды оболочки:");
    env=MK_FP(mcb-&gt;ownr,0x2c);
    for (end=MK_FP(*env,0); (bx=strlen(end))&gt;0; end+=bx+1)
     printf("\n %s",end);

   /* Вывод пути и имени файла программы */

    wrk=(struct work far *)(end+1);
    if (wrk-&gt;mark==1)  /* Проверка корректности структуры данных */
     printf("\nИмя файла программы %s",wrk-&gt;name);
   }
   if (mcb-&gt;type=='Z') break; /* Проверка полноты просмотра */
   ax+=mcb-&gt;size+1; /* Вычисление сегм. адр. следующего MCB */
  }
}

</div></PRE>
<P>
<P>

<div class="header"><A name=REF_12_2></A>12.2. Вывод списка установленных драйверов 
устройств 
</div>
<P>Операции ввода-вывода на ПЭВМ реализуются на физическом уровне программным 
путем микропроцессором. Программы обслуживания устройств называют <strong>д р а й в е р 
а м и</strong>, отражая их непосредственное участие в управлении устройством. Некоторые 
драйверы являются элементами системы управления вводом-выводом, но 
пользователь может установить собственные драйверы. В MS-DOS такая установка 
производится директивой DEVICE в файле CONFIG.SYS. 
<P>Иногда представляет интерес получение информации об активных драйверах по 
ходу работы программы. 
<P>Драйверы устройств представлены списком со следующей структурой элементов: 
<P><PRE><div class="code">     struct Driver_Code_Area {
      unsigned int NextOff;
      unsigned int NextSeg;
      unsigned int Strategy;
      unsigned int Interrupt;
      char DeviceName[10];
      char DriverProgramCodeArea[1];
     };

</div></PRE>
<P>Здесь
<ul>
<li>NextSeg и NextOff - сегментный адрес и смещение заголовка следующего 
драйвера("далекий" указатель следующего элемента списка; признак "пустого" 
указателя: NextSeg=NextOff=0xffff); 
<LI>DevAttr - атрибуты драйвера; 
<li>Strategy - смещение программы отработки стратегии обслуживания устройства; 
<li>Interrupt - смещение программы обработки прерываний с запросом ввода-вывода. </li></ul>
<P>Рассмотрим пример программы для вывода списка установленных драйверов. Для 
получения указателя головного элемента воспользуемся обсужденным в предыдущей 
задаче приемом (прерывание 0x21, функция 0x52). Компоненты указателя списка 
будут прочитаны из области системных данных. 
<P>В отличие от предшествующей программы, здесь не будет использоваться 
отображение структур данных на память средствами языка С. Причина - 
нестандартное хранение поля указателя. Для выборки элементов данных будут 
применены библиотечные функции: 
<UL>
  <LI>int peek(int seg, int off) - чтение слова, 
  <LI>char peekb(int seg, int off) - чтение байта по заданным значениям 
  сегментного адреса seg и смещения off. </LI></UL>
<P><PRE><div class="code">
#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
void main(void) {
 unsigned int es, bx, seg, off, i,j,k=0;
<P>
 /* Поиск указателя списка блоков памяти */
<P>
 _AH=0x52;
 geninterrupt(0x21);
<P>
 bx=_BX-2;  /* Выделение смещения и сегмента */
 es=_ES;    /*  указателя системной области  */
 seg=peek(es,bx+38); /* Выделение сегмента и смещения */
 off=peek(es,bx+36); /*  указателя первого драйвера   */
 while(off!=0xffff) {  /* Просмотр списка драйверов */
  printf("\nДрайвер %d: ",++k);
  for (i=10; i&lt;18; i++)
   if ((j=peekb(seg,off+i))==' ') break;
   else printf("%c",j);
  bx=peek(seg,off+2); /*********************************/
  es=peek(seg,off);   /* Выделение сегмента и смещения */
  seg=bx;             /* указателя следующего драйвера */
  off=es;             /*********************************/
 }
}

</P><div></PRE>Результаты работы программы: 
<P><PRE><div class="code"><font color="black"> 1) CON
 2)
 3)
 4) CON
 5) AUX
 6) PRN
 7) CLOCK$
 8)
 9) COM1
10) LPT1
11) LPT2
12) LPT3
13) COM2
14) COM3
15) COM4

</div></PRE>
<P>
<P>
<P>

<div class="header"><A name=REF_12_3></A>12.3. Получение информации о системных 
ресурсах </div>
<P>Способы получения системной информации о конкретной ПЭВМ во время выполнения 
программы: 
<UL>
  <LI>чтение стандартно распределенных областей памяти; 
  <LI>чтение регистров состояния оборудования через порты обмена; 
  <LI>запрос через программное прерывание к BIOS; 
  <LI>использование библиотечных функций. </LI></UL>
<P>Сведения о распределении памяти и портов ввода-вывода - исходная рабочая 
информация системного программиста. 
<P>Укрупненная схема распределения памяти ПЭВМ IBM PC/XT/AT (в форме "сегментный 
адрес - содержимое"): 
<ul>
<li>0000:0000 - векторы прерываний (256*4 байт); 
<li>0040:0000 - область данных BIOS; 
<li>0050:0000 - область памяти, управляемая ОС MS DOS (модули ОС IBMBIO.COM, 
IBMDOS.COM, буферы ОС, резидент СOMAND.COM, резидентные программы пользователя, 
область памяти прикладных программ); 
<li>A000:0000 - начало области буферов экрана; 
<li>A000:0000 - буфер экрана EGA/VGA; 
<li>B000:0000 - буфер экрана MGA; 
<li>B800:0000 - буфер экрана CGA; 
<li>C000:0000 - начало области ПЗУ; 
<li>F600:0000 - интерпретатор BASIC; 
<li>FE00:0000 - модуль BIOS.</li></ul> 
<P>
<P>Важнейшая оперативная информация хранится в области данных BIOS, как, 
например: 
<ul>
<li>0000:0410 (2) - флажки установленного оборудования; 
<li>0000:0413 (2) - объем оперативной памяти в килобайтах; 
<li>0000:041А (2) - адрес начала очереди введенных кодов клавиш; 
<li>0000:041C (2) - адрес конца очереди введенных кодов клавиш; 
<li>0000:041E (2) - началo буфера клавиатуры; 
<li>0000:0450 (16) - координаты курсора (колонка,столбец) по четырем возможным 
видеостраницам и т.д. </ul></li>
<P>
<P>Некоторая информация находится в области BIOS: 
<ul>
<li>F000:FFF5 (8) - номер версии BIOS (дата); 
<li>F000:FFFE (1) - код типа ПЭВМ: 
<li>FF - IBM PC; 
<li>FE - IBM PC/XT; 
<li>FD - PCjr; 
<li>FC - IBM PC/AT.</ul></li> 
<P>
<P>Интерпретация флажков установленного оборудования: 
<ul>
<li>0 - наличие НГМД; 
<li>1 - наличие математического сопроцессора; 
<li>2,3 - размер базовой памяти (устарело); 
<li>4,5 - тип активного видеоадаптера: 
<li>00 - нет видеоадаптера; 
<li>01 - цветной 40*25 (PCjr); 
<li>10 - цветной 80*25; 
<li>11 - монохромный; 
<li>6,7 - уменьшенное на единицу количество НГМД; 
<li>9,A,B - уменьшенное на единицу количество коммуникационных адаптеров; 
<li>С - наличие игрового адаптера; 
<li>E,F - количество принтеров. 
<P>
<P>Пример программы отображения системных ресурсов: 
<P><PRE><div class="code">
#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
void main(void) {
  char *name;
  unsigned dflags;

 /* Вывод типа ПЭВМ */

  printf("\nМодель ПЭВМ: ");
  switch(peekb(0xf000,0xfffe)) {
   case 0xff: name="IBM PC";
              break;
   case 0xfe: name="IBM PC/XT";
              break;
   case 0xfd: name="IBM PCjr";
              break;
   case 0xfc: name="IBM PC/AT";
              break;
   default:   name="Unknown";
  }
  printf("%s",name);

 /* Вывод объема памяти */

  printf("\nОбьем памяти: %d K",peek(0,0x413)+1);

 /* Вывод описания оборудования */

  dflags=peek(0,0x410);
  printf("\nФлаги конфигурации оборудования: %#04x",dflags);
  if (dflags&amp;1)
   printf("\nКоличество НГМД: %d",((dflags&amp;0x00c0)&gt;&gt;6)+1);
  printf("\nСопроцессор %sустановлен",(dflags&amp;2)? NULL:"не ");
  printf("\nКоличество коммуникационных адаптеров: %d",
         (dflags&amp;0x0e00)&gt;&gt;9);
  printf("\nКоличество обслуживаемых принтеров: %d",
         (dflags&amp;0x0c00)&gt;&gt;9);
  printf("\nТип видеоадаптера: ");
  switch ((dflags&amp;0x0030)&gt;&gt;4) {
   case 1: name="C 40*25";
           break;
   case 2: name="C 80*25";
           break;
   case 3: name="MDA";
           break;
  }
  printf("%s",name);
}
</div></PRE>
<P>Результаты работы программы: 
<P><PRE><div class="code"><font color = "black">Модель ПЭВМ: IBM PC/AT
Обьем памяти: 640 K
Флаги конфигурации оборудования: 0x4461
Количество НГМД: 2
Сопроцессор не установлен
Количество коммуникационных адаптеров: 2
Количество обслуживаемых принтеров: 2
Тип видеоадаптера: C 80*25
</font></div></PRE>
<P>Другой способ получения информации о системных ресурсах - запрос через 
программные прерывания к BIOS: 
<ul>
  <li>прерывание 0x11 - получение флагов конфигурации оборудования в регистре 
  _AX; 
  <li>прерывание 0x12 - получение в регистре _AX размера оперативной памяти в 
  килобайтах (значение уменьшено на единицу). </li></ul>
<P><pre><div class="code">#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
void main(void) {
 unsigned dflags;
 unsigned memsiz;
 geninterrupt(0x11);
 dflags=_AX;
 printf("\nФлаги конфигурации оборудования: %#04x",dflags);
<P>
 geninterrupt(0x12);
 memsiz=_AX+1;
 printf("\nОбьем основной памяти: %u К",memsiz);
}
</P></div></PRE>
<P>Результаты работы программы: 
<P><PRE><div class="code"><font color = "black">Флаги конфигурации оборудования: 0x4461
Обьем основной памяти: 640 К
</font></div></PRE>
<P>Третий способ получения информации о системных ресурсах - использование 
библиотечных функций. Представленная ниже программа демонстрирует такие функции 
в системах программирования Turbo-C и Turbo-C++ фирмы Borland: 
<P><PRE><div class="code">#include &lt;stdio.h&gt;
#include &lt;bios.h&gt;
<P>
void main(void) {
 unsigned dflags;
 unsigned memsiz;
<P>
 dflags=biosequip();
 printf("\nКод конфигурации оборудования: %#04x",dflags);
<P>
 memsiz=biosmemory()+1;
 printf("\nОбьем основной памяти: %u К",memsiz);
}
</P></div></PRE>
<P>Результаты работы программы двух последних программ совпадают. 
<P>Все три представленных способа функционально эквивалентны, но последний, как 
самый высокоуровневый, здесь наиболее предпочтителен. Однако часто для 
реализации рассмотренных способов подходящие библиотечные отсутствуют, а запрос 
по прерыванию слишком медлителен. Первый способ всегда наиболее 
быстродействующий. 
<P>Рассмотрим пример ситуации, когда детализированная информация получается 
путем обращения непосредственно к оборудованию через порты ввода-вывода. 
<P>ПЭВМ класса IBM PC/AT хранит информацию о конфигурации в специальной 
CMOS-памяти (микросхема с батарейным питанием). Она имеет 64 однобайтных 
регистра, доступ к которым осуществляется посылкой номера регистра в порт 0x70 и 
выборкой или установкой содержимого регистра операцией чтения или записи порта 
0x71. 
<P>Например, информация о наличии памяти: 
<P>0x15-0x16 - объем памяти на системной плате; 
<P>0x17-0x18 - объем установленной расширенной (expansion) памяти (свыше 1 
Мбайта); 
<P>0x30-0x31 - объем работоспособной расширенной памяти (по данным программы 
самотестирования). 
<P>Пример программы вывода сведений о памяти ПЭВМ класса IBM PC/AT из 
CMOS-памяти: 
<P><PRE><div class="code">#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
<P>
/* Порты адреса(номера регистра) и данных CMOS-памяти */
<P>
#define ADDR_PORT 0x70
#define DATA_PORT 0x71
<P>
/* Чтение слова из однобайтных регистров CMOS-памяти */
<P>
unsigned getwrd(int port_s) {
 union {
  unsigned word;
  char byte[2];
 } x;
 outportb(ADDR_PORT,port_s);
 x.byte[0]=inportb(DATA_PORT);
 outportb(ADDR_PORT,port_s+1);
 x.byte[1]=inportb(DATA_PORT);
 return x.word;
}
<P>
char *format="\n%s: %u K"; /* Формат вывода данных */
<P>
/* Макрос вывода данных */
<P>
#define P(X,Y) printf(format,X,getwrd(Y))
<P>
/* Регистровые адреса данных описания памяти */
enum {
 MMS=0x15, /* Обьем основной памяти */
 EMS=0x17, /* Обьем установленной расширенной памяти */
 AMS=0x30  /* Обьем работоспособной расширенной памяти */
};
<P>
void main(void) {
 P("Oбьем основной памяти",MMS);
 P("Обьем установленной расширенной памяти",EMS);
 P("Обьем работоспособной расширенной памяти",AMS);
}
</P></div></PRE>
<P>Результаты работы программы: 
<P><PRE><div class="code"><font color = "black">Oбьем основной памяти: 640 К
Oбьем установленной расширенной памяти: 384 К
Oбьем работоспособной расширенной памяти: 384 К
</font></div></PRE>
<P>Кроме сведений о конфигурации ПЭВМ, CMOS-память хранит данные о текущем 
времени и моменте запланированного прерывания от таймера, контрольную сумму 
байтов байтов описания оборудования и т.д. 
<P>Хранение информации о конфигурации системы в CMOS-памяти избавляет от 
необходимости аппаратной настройки ПЭВМ при ее изготовлении или замене элементов 
(периферийных устройств, блоков памяти). Вместе с тем, возникает опасность 
разрушения содержимого CMOS из-за неисп- равности источника питания или 
неправильной работы прикладных программ. Содержимое CMOS можно контролировать и 
изменять автоматически вызываемой на этапе начальной загрузки операционной 
системы программы SETUP. Нетрудно разработать программу 
сохранения-восстановления СМОS памяти. 
<P>
<P>
<P>

<div class="header"><A name=REF_12_4></A>12.4. Обработка прерываний в ПЭВМ типа IBM 
PC/XT/AT 
</div>
<P>Под <strong>прерыванием</strong> понимают передачу управления заранее подготовленной программе 
обработки некоторой ситуации в ответ на асинхронный по отношению к текущему 
вычислительному процессу внешний аппаратный сигнал или запрос команды 
программного прерывания (команда типа INT). 
<P>Механизм обработки прерываний в ПЭВМ типа IBM PC/XT/AT базируется на основе 
вектора прерываний, который имеет 256 четырехбайтных элементов и располагается в 
начале оперативной памяти. Элементы векторов содержат "далекий" адрес программы 
обработки прерывания в формате "сегмент:смещение". 
<P>Любые прерывания с точки зрения микропроцессора идентифицируются номером в 
диапазоне 0...255. При возникновении прерывания с некоторым номером слово 
состояния текущей программы (регистры микропроцессора CS, IP и регистр флагов) 
запоминается в стеке. Далее по номеру прерывания в регистры CS и IP загружается 
адрес точки входа в соответствующую программу обработки прерывания. Именно 
последнее означает переход к программной обработке прерывания. Программа 
обработки прерывания должна, как правило, завершаться командой IRET, которая 
восстанавливает из стека содержимое регистров слова состояния текущей программы. 
В системе программирования Turbo-C программа обработки прерывания должна 
оформляться как функция с атрибутом interrupt. 
<P>Программирование процессов обработки аппаратных прерываний требует знакомства 
со следующими понятиями: 
<UL>
  <LI>регистр флагов микропроцессора; 
  <LI>уровни и приоритеты аппаратных прерываний; 
  <LI>обслуживание контроллера прерываний. </LI></UL>Интерпретация разрядов 
регистра флагов микропроцессоров фирмы Intel: 
<P>а) микропроцессор Intel 8080: 0: CF - перенос или заем; 2: PF - четность 
результата; 4: AF - вспомогательный (десятичный) перенос; 6: ZF - нулевой 
результат; 7: SF - знак результата; 
<P>б) дополнительные флаги микропроцессора Intel 8086: 8: TF - пошаговый режим; 
9: IF - разрешение прерываний; 10: DF - направление (автоинкремент); 11: OF - 
переполнение. 
<P>Единичное значение флага IF разрешает микропроцессору реагировать на 
аппаратные прерывания. Установка и сброс этого флага может выполняться, 
соответственно, командами ассемблера STI и CLI. При программировании на языке С 
в системе Turbo-C для тех же целей можно воспользоваться библиотечными функциями 
enable() и disable(). Различают три вида причин прерываний: 
<UL>
  <LI>процессорные прерывания - обнаружение исключительных ситуаций 
  микропроцессором; 
  <LI>аппаратные прерывания - сигнал от внешнего к микропроцессору контроллера 
  прерываний (от аппаратуры ЭВМ); 
  <LI>программные прерывания - инициатива программы. </LI></UL>
<P>Процессорные и аппаратные прерывания жестко привязаны к вектору прерываний. 
<P>Привязка номера прерывания и причины возникновения процессорных прерываний 
предопределена изготовителем микропроцессора: 
<UL>
  <LI>0 - деление на нуль; 
  <LI>1 - пошаговый режим; 
  <LI>2 - немаскируемое прерывание (напр., из-за падения напряжения питания, 
  сбоя памяти); 
  <LI>3 - ситуация приостановки; 
  <LI>4 - переполнение. </LI></UL>Привязка аппаратных прерываний к вектору 
прерываний реализуется посредством программируемого контроллера прерываний и 
предопределена изготовителем ПЭВМ. Контроллер прерываний ПЭВМ обслуживает 8 
уровней прерываний, но у IBM PC/AT таких контроллеров два. Каждому уровню 
прерывания соответствует определенный аппаратный сигнал, обозначаемый как IRQx, 
где x - номер сигнала. Набор сигналов прерывания ПЭВМ типа IBM PC/XT (в скобках 
- первого контроллера для IBM PC/AT): 
<UL>
  <LI>0 - таймер; 
  <LI>1 - клавиатура; 
  <LI>2 - сигнал второго контроллера прерываний; 
  <LI>3 - коммуникационный адаптер COM1 (COM2); 
  <LI>4 - коммуникационный адаптер COM2 (COM1); 
  <LI>5 - винчестер (принтер); 
  <LI>6 - НГМД; 
  <LI>7 - принтер. </LI></UL>
<P>Набор сигналов прерывания второго контроллера IBM PC/AT: 
<UL>
  <LI>8 - таймер времени дня (CMOS); 
  <LI>9 - программный аналог IRQ2; 
  <LI>13 - сопроцессор; 
  <LI>14 - винчестер </LI></UL>
<P>(остальные сигналы зарезервированы). 
<P>Приоритет прерываний убывает с возрастанием номера сигнала, но учитывая связь 
контроллеров в ПЭВМ типа IBM PC/AT прерывания IRQ8...IRQ15 имеют приоритет 2. 
<P>Сигналы прерывания отображаются на вектор прерываний следующим образом (номер 
сигнала - номер вектора): 
<P>IRQ0...IRQ7 - Ox8...0xf; IRQ8...IRQ15 - 0x70...0x77. 
<P>Программируемый контроллер прерывания для программиста можно условно 
представить однобайтными регистрами данных и управления. Регистр данных первого 
контроллера прерываний доступен для обмена через порт 0x21, а второго - через 
порт 0xa1. Адреса портов регистров управления - 0х20 и 0xa0 соответственно. 
Регистр данных предназначен для чтения и установки маски прерываний сигналов. 
Сигналам IRQ0 и IRQ8 соответствуют младшие разряды регистра данных. 
<P><PRE><div class="code">/* Программа чтения текущих масок прерывания */
<P>
#include &lt;stdio.h&gt;
<P>
#define PIC_D0 0x21
#define PIC_D1 0xa1

#define P(X)\
 printf("\nПорт %#02x: маска прерывания %#02x",X,inportb(X))
<P>
void main() {
 P(PIC_D0);
 P(PIC_D1);
}
</P></div></PRE>
<P>Результаты работы программы: 
<P><PRE><div class="code"><font color="black">Порт 0x21: маска прерывания 0xa8
Порт 0xa1: маска прерывания 0xbd
</font></div></PRE>
<P>Интерпретация результата: 
<P>1010 1000 - запрет IRQ3, IRQ5, IRQ7 1011 1101 - запрет IRQ8, IRQ10, IRQ11, 
IRQ12, IRQ13, IRQ15 
<P>Процедура установки маски прерывания является критичной к аппаратным 
прерываниям, поэтому на момент ее исполнения рекомендуется сбрасывать в нуль 
флаг IF. 
<P><PRE><div class="code">#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
<P>
#define PIC_D0 0x21
<P>
void main() {
 unsigned char mask; /* Исходная маска прерываний */
<P>
/* Запрет прерываний от клавиатуры */
<P>
 disable();
 mask=inportb(PIC_D0);
 outportb(PIC_D0,mask&amp;0xfd);
 enable();
 printf("\nКлавиши не обслуживаются...");

/* Работа без клавиатуры */

 sleep(10);

/* Разрешение прерываний от клавиатуры */

 disable();
 outportb(PIC_D0,mask);
 enable();
 printf("\nКлавиши обслуживаются...");
 /* ... */
}
</P></div></PRE>
<P>После возникновения аппаратного прерывания программа его обработки должна 
сбросить через регистр управления контроллер прерываний в исходное состояние. 
Это реализуется посылкой значения 0x20 в порт 0x20 (для сигналов IRQ8...IRQ15, 
кроме этого, необходимо послать значение 0x20 и в порт 0xa0). Схема типичного 
обработчика аппаратных прерываний на языке С: 
<P><PRE><div class="code">     void interrupt() {
<P>
      /************************************
         Операторы обработки прерывания
      ************************************/
<P>
      outportb(0x20,0x20);  /* Сброс контроллера прерываний */
     }
</P></div></PRE>
<P>Для работы в вычислительной среде конкретной ОС необходимо зна- ние схемы 
вектора прерываний, формируемого на этапе первоначальной загрузки. 
<P>
<P>
<P>

<div class="header"><A name=REF_12_5>12.5. Понятие системы типа 
"клиент-сервер" </div>
<P>Под системой типа <strong>"клиент-сервер"</strong> подразумевают систему централизованной 
обработки запросов. Полезность централизации в системах обработки данных обычно 
обусловлена необходимостью управления разделением некоторого вычислительного 
ресурса (программ, данных, устройств или памяти) между многими пользователями. 
Примеры таких систем: 
<UL>
  <LI>администраторы устройств; 
  <LI>файловые системы(локальные и распределенные); 
  <LI>системы управления базами данных и т.п. </LI></UL>Внутренние механизмы 
операционных систем и прикладных систем, построенные по рассматриваемой схеме, 
как правило, ориентированы на обслуживание переменного во времени количества 
пользователей. Интерфейс связи удобно строить на основе механизма обмена 
сообщениями, рассмотренного ранее. При этом сервер обычно является 
задачей-получателем сообщений от задач пользователя, а обратная связь 
реализуется репликами ответов. Протокол передачи сообщений может быть любым. При 
работе в среде многозадачных ОС (QNX, UNIX, OS/2, Nowell Netware) средства его 
построения предоставляет система. Формально сервер как механизм синхронизации 
процессов играет роль монитора. 
<P>Разделяют два вида серверов: 
<UL>
  <LI>поддержка транзакций - обслуживание независимых запросов; 
  <LI>поддержка зависимых запросов задачи. </LI></UL>
<P>Транзакция проще в программировании - каждый запрос рассматривается как 
новый, поэтому сервер не должен учитывать состояние задачи пользователя или 
следить за ее уничтожением. Однако пользователь обязан предоставлять в каждом 
запросе полное описание задачи. 
<P>Поддержка зависимых запросов задачи требует от нее начального запроса на 
открытие ресурса и конечного запроса на его закрытие. Открытие обычно использует 
символическое имя ресурса, которому сервером ставится в соответствие некоторый 
идентификатор ресурса для последующих обращений. Например, файловая система 
назначает при открытии имени файла указатель структуры описания файла с его 
номером в системной таблице (см. функции fopen, fileno, _open). Очевидно, 
чтосервер здесь должен быть информирован о фактах уничтожения задач, которые 
могут не закрывать ресурс. 
<P>
<P>

<div class="header"><A name=REF_12_6></A>12.6. Пример построения системы "клиент-сервер" в 
QNX 
</div>
<P>Пусть в системе управления транспортными процессами возникает потребность 
определения множества справок по кратчайшим маршрутам между произвольными 
вершинами некоторой транспортной сети. Можно показать, что выдачу справок для 
реальных транспортных сетей эффектив- нее производить не путем выборки из файла 
матрицы кратчайших маршрутов, а посредством оптимизации маршрута по запросу. 
<P>Задача поиска кратчайших маршрутов на графе транспортной сети в 
математическом отношении является хорошо изученной, а практический интерес в 
последнее время представляют лишь способы реализации вычислительных схем ее 
решения. Здесь мы будем использовать вариант эффективной реализации алгоритма 
Дийкстры. Таким образом, каждый запрос на оптимизацию маршрута интерпретируется 
в терминах получения характеристик дерева кратчайших маршрутов от некоторой 
исходной вершины до конкретно заданной вершины либо до всех остальных вершин 
графа сети. Взаимозависимостью запросов, ассоциированных при этом лишь с 
некоторой корневой вершиной, не будем пренебрегать, но для простоты рассуждений 
естественно возникающую идею диспетчеризации запросов оставим вне рассмотрения. 
<P>Реализация схемы решения любой задачи вынуждает выполнить предварительное 
планирование распределения памяти для представления переменных состояния (по 
крайней мере, c целью оценки реальной возможности решения задачи). 
<P>Область определения процесса оптимизации маршрутов на транспортной сети 
включает: 
<UL>
  <LI>множество данных представления графа транспортной сети; 
  <LI>массивы результата оптимизации в виде описания дерева кратчайших маршрутов 
  и расстояний от заданной корневой вершины; 
  <LI>множество переменных описания инвариантных характеристик задачи 
  оптимизации маршрутов на графе транспортной сети. </LI></UL>
<P>Рассмотрим последовательно состав перечисленных элементов с целью определения 
структуры глобальных переменных процедур оптимизации. 
<P>Графы реальных транспортных сетей обычно характеризуются незначительной 
степенью связности, поэтому их представление в памяти удобно выбирать в виде 
списковых структур данных (см. 4). Модель транспортной сети в этом случае 
включает следующие элементы данных: 
<UL>
  <LI>N_dot - количество вершин графа транспортной сети; 
  <LI>N_lst - массив указателей списков смежности; 
  <LI>B_arc - массив элементов списков смежности (конечных вершин дуг графа); 
  <LI>W_arc - массив весов дуг. </LI></UL>
<P>Предполагается, что вершины графа транспортной сети пронумерованы числами 
0,1,... N_dot-1. 
<P>Элементы массивов N_lst, B_arc, W_arc после нумерации вершин фиксируются 
следующим образом: <PRE><div class="code">
     N_lst[0]=0;
<P>
     N_lst[i+1]=N_lst[i]+card(i'), i=0,1,... N_dot-1;
<P>
     B_arc[N_lst[i]+j]=i'(j),
     W_arc[N_lst[i]+j]=w(i,i'(j)),
     j=0,1,...card(i')-1, i=0,1,... N_dot-1.

</P></div></PRE>
<P>Здесь x' - множество номеров вершин, для которых существуют направленные дуги 
из вершины графа x; 
<P>w(x,y) - вес дуги из вершины x в вершину y; 
<P>card(z) - размерность множества z. 
<P>Очевидно, что 
<P><PRE><div class="code">     card(N_lst)=N_dot+1,
     card(B_arc)=card(W_arc)=N_lst[N_dot]                  (12.1)
</div></PRE>
<P>(элемент N_lst[N_dot] содержит количество дуг графа сети по определению). 
<P>Результат построения дерева кратчайших маршрутов размещается в следующих 
массивах: 
<P>D_dot - массив расстояний от корня дерева; 
<P>P_dot - массив вершин кратчайшего пути. 
<P>Размерность таких массивов 
<P><PRE><div class="code">     card(D_dot)=card(P_dot)=N_dot.                        (12.2)

</div></PRE>
<P>Состав инвариантных параметров задачи оптимизации маршрутов на графе 
транспортной сети, которые целесообразно определить один раз на этапе 
инициализации резидентной части программы, предопределен процедурой оптимизации 
маршрутов. Можно показать, что такими пара- метрами являются: 
<UL>
  <LI>L_arc - максимальная длина дуги; 
  <LI>t_root - номер корневой вершины последнего полностью построенного дерева 
  кратчайших маршрутов; 
  <LI>x_next и x_prec - массивы указателей следующих и предыдущих элементов 
  списка очередей вершин; 
  <LI>t_size - размер горизонта планирования дерева; 
  <LI>t_base и t_stop - начало и конец индексов указателей очередей вершин. 
</LI></UL>Списки очередей вершин представимы в массивах следующей размер- ности 
[3]: 
<P><PRE><div class="code">     card(x_prec)=N_dot;                                   (12.3)
     card(x_next)=N_dot+L_arc+1.                           (12.4)

</div></PRE>
<P>Очевидно, что наиболее существенный вес здесь имеют области массивов. 
Заключение о возможности решения задачи при известном объеме доступной памяти 
практически можно обосновать его сравнением с суммой значений, получаемых на 
основе (6.1-6.4). 
<P>Рассмотрим пример программной реализации в среде ОС QNX справочника 
кратчайших маршрутов задачей-администратором со следующей схемой 
функционирования: 
<UL>
  <LI>чтение параметров размерности и описания графа транспортной сети из файла 
  сжатого описания сети; 
  <LI>подключение идентификационного имени задачи-администратора; 
  <LI>переход в состояние обработки запросов. </LI></UL>Предполагается, что файл 
сжатого описания сети подготовлен заранее с помощью загружаемой в пакетном 
режиме программы. Соответствие имени такого файла идентификационному имени 
задачи - администратора задается командной строкой запуска этой задачи: 
<P><pre><div class="code">interx netfile tskname </div></pre>
<P>Здесь interx - имя файла - загрузочного модуля задачи - администратора 
(результата компиляции и компоновки исходного текста из файла interx.c); 
<P>netfile - имя файла сжатого описания транспортной сети; 
<P>tskname - идентификационное имя задачи - администратора. Задача - 
администратор обрабатывает следующие запросы: 
<UL>
  <LI>запрос операции расчета; 
  <LI>запрос параметров сети; 
  <LI>команда завершения работы. </LI></UL>
<P>Структуры сообщений потока информационного обмена и коды запросов определены 
в заголовочном файле interz.h. 
<P>Содержимое заголовочного файла interz.h: /* Декларация структур сообщений */ 
<P><PRE><div class="code">#ifndef INTERZ_H
#define INTERZ_H

typedef struct { /* Запрос на расчет маршрута */
 int code;       /* код сообщения */
 int sour;       /* номер исходной вершины */
 int dest;       /* номер конечной вершины */
} QUERY;

typedef struct { /* Запрос размерности описания графа сети */
 int code;       /* код сообщения */
 int dots;       /* количество вершин */
 int arcs;       /* количество дуг */
} CARDS;

typedef struct { /* Элемент результата расчета */
 int code;       /* код сообщения */
 int prec;       /* номер предшествующей вершины маршрута */
 long dist;      /* значение расстояния от корневой вершины */
} RESULT;

/* Коды сообщений потока межзадачного обмена */

enum {
 CALC=1, /* Запрос операции расчета */
 EXIT,   /* Команда завершения работы */
 SIZE    /* Запрос параметров сети */
};

#endif

</div></PRE>Исходный текст задачи - администратора (размещается в файле interx.c): 
<P><PRE><div class="code">#include &lt;stdio.h&gt;
#include &lt;magic.h&gt;
#include "interz.h"

int t_root;

/* Параметры описания графа сети */

int   N_dot;  /* количество вершин */
int   N_arc;  /* количество дуг */
int  *N_lst;  /* массив указателей списков смежности */
int  *B_arc;  /* массив конечных вершин дуг графа */
int  *W_arc;  /* массив весов дуг */

/* Параметры описания дерева кратчайших путей */

int *x_next;
int *x_prec;
int  t_size;
int  t_base;
int  t_stop;

/* Массивы результатов */

int  *P_dot;  /* массив вершин кратчайшего пути */
long *D_dot;  /* массив расстояний */

int mread(void *p, int s, int n, FILE *f) {
 return (fread(p,s,n,f)!=n);
}

void main(int na, char **la) {
 FILE *stream;
 QUERY buf;     /* Буфер приема запросов */
 RESULT out;    /* Буфер выдачи результатов */
 int L_arc;     /* Максимальная длина дуги */
 unsigned xid;  /* Идентификатор прикладной задачи */
 long length;

 if (na&lt;3) {
  printf("\n\n %s","СПРАВОЧНИК КРАТЧАЙШИХ РАССТОЯНИЙ");
  printf("\n\nСинтаксис вызова:\n\n %s netfile tskname",la[0]);
  printf("\n   netname - имя файла сжатого описания сети");
  printf("\n   tskname - локальное имя задачи");
  exit(1);
 }
 if (!(stream=fopen(la[1],"r")))
  error("Ошибка открытия файла модели сети");

/* Чтение параметров размерности сети */

 if (
  mread(&amp;N_dot,sizeof(N_dot),1,stream) ||
  mread(&amp;N_arc,sizeof(N_arc),1,stream) ||
  mread(&amp;L_arc,sizeof(L_arc),1,stream)
 ) error("Ошибка чтения размерности сети");

/* Захват памяти для рабочих массивов */

 t_base=N_dot+1, t_size=L_arc+1, t_stop=N_dot+t_size;
 length=(long)N_dot*(long)(sizeof(*D_dot));
 length+=(long)N_dot*(long)(sizeof(*P_dot)+sizeof(*x_prec));
 length+=(long)t_stop*(long)sizeof(*x_next);
 length+=(long)(N_dot+1)*(long)sizeof(*N_lst);
 length+=(long)N_arc*(long)(sizeof(*B_arc)+sizeof(*W_arc));
 x_next=malloc((unsigned)length);
 if (!x_next)
  error("Ошибка захвата памяти");

/* Инициализация указателей рабочих массивов */

 x_prec=x_next+t_stop;
 P_dot=x_prec+N_dot;
 N_lst=P_dot+N_dot;
 B_arc=N_lst+N_dot+1;
 W_arc=B_arc+N_arc;
 D_dot=(long *)(W_arc+N_arc);

/* Чтение массивов описания структуры сети */

 *N_lst=0, t_root=N_dot;

 if (
  mread(N_lst+1,sizeof(*N_lst),N_dot,stream) ||
  mread(B_arc,sizeof(*B_arc),N_arc,stream) ||
  mread(W_arc,sizeof(*W_arc),N_arc,stream)
 ) error("Ошибка чтения структуры сети");
 fclose(stream);

/* Переход в режим обслуживания запросов */

 if (name_attach(la[2],My_nid)) {
  while (N_dot)
   if ((xid=receive(0,&amp;buf,sizeof(buf))) &amp;&amp; (~xid))
    switch(buf.code) {
     case SIZE: /* Запрос параметров графа сети */
                buf.sour=N_dot;
                buf.dest=N_arc;
                reply(xid,&amp;buf,sizeof(buf));
                break;

     case CALC: /* Заявка на оптимизацию маршрута */
                if (buf.sour!=t_root)
                 shrtpt(buf.sour,buf.dest);
                out.code=buf.code;
                out.dist=D_dot[buf.dest];
                out.prec=P_dot[buf.dest];
                reply(xid,&amp;out,sizeof(out));
                break;

     case EXIT: /* Завершение работы */
                N_dot=0;
                break;
   }
 } else error("Ошибка подключения имени задачи");
}

/* Процедура построения кратчайших путей на графе */

void shrtpt(int i, int z) {
 int  j,k,l,m,n,w,t;
 long Q,R,S;
 static long infinity=0x7fffffffL;

/* Инициализация рабочих массивов */

 for (j=0; j&lt;N_dot; D_dot[P_dot[j]=j]=infinity, j++);
 D_dot[x_next[t_root=N_dot]=i]=0, w=1;
 for (j=t_base; j&lt;t_stop; x_next[j++]=N_dot);
 x_next[i]=x_prec[i]=N_dot;

/* Организация процесса ветвления */

 while (w&gt;0) {
  for (m=N_dot; m&lt;t_stop; m++)
   while((j=x_next[m])&lt;N_dot) {
    if (j==z) return;
    k=x_next[m]=x_next[j], w--;
    if (k&lt;N_dot) x_prec[k]=m;
    for (l=N_lst[j], Q=D_dot[j]; l&lt;N_lst[j+1]; l++) {
     if ((S=D_dot[(n=B_arc[l])])&gt;=Q)
      if ((R=Q+(t=W_arc[l]))&lt;S) {
       if (S==infinity) w++;
       else {
        k=x_next[x_prec[n]]=x_next[n];
        if (k&lt;N_dot) x_prec[k]=x_prec[n];
       }
       D_dot[n]=R, P_dot[n]=j, t+=m;
       if (t&gt;=t_stop) t-=t_size;
       k=x_next[n]=x_next[t], x_prec[n]=t, x_next[t]=n;
       if (k&lt;N_dot) x_prec[k]=n;
      }
    }
   }
 }
 t_root=i;
}

</div></PRE>
<P>Прикладные задачи могут установить связь с задачей - администратором 
посредством проверки активности задачи - владельца идентификационного имени. 
После установления связи и получения параметров размерности описания графа 
транспортной сети можно порождать поток запросов на получение сведений о 
кратчайших маршрутах между любыми вершинами сети. 
<P>Исходный текст примера прикладной программы формирования запросов 
(размещается в файле intery.c): <PRE><div class="code">
/* Пример прикладной программы формирования запросов */
<P>
#include &lt;stdio.h&gt;
#include &lt;magic.h&gt;
#include "interz.h"

void main(na,la) int na; char **la; {
 unsigned xid;  /* Идентификатор задачи - получателя */
 QUERY buf;     /* Буфер приема запросов */
 RESULT out;    /* Буфер выдачи результатов */
 union buffer { /* Объединение буферов обмена */
  QUERY  buf;
  RESULT out;
 };

 if (na&lt;2) {
  printf("\n\n %s","ПРОВЕРКА СПРАВОЧНИКА КРАТЧАЙШИХ РАССТОЯНИЙ");
  printf("\n\nСинтаксис вызова:\n\n %s tskname",la[0]);
  printf("\n   tskname - локальное имя задачи");
  exit(1);
 }
 if (xid=name_locate(la[1],0,sizeof(union buffer))) {

/* Запрос параметров сети */

  buf.code=SIZE;
  send(xid,&amp;buf,&amp;buf,sizeof(buf));
  printf("\n Размерность транспортной сети:");
  printf("\n  количество вершин %d",buf.sour);
  printf("\n  количество дуг %d",buf.dest);

/* Цикл рабочих запросов */

  buf.code=CALC;
  while(printf("\nОткуда, куда - ? "),
        scanf(" %d %d",&amp;buf.sour,&amp;buf.dest)) {
   send(xid,&amp;buf,&amp;out,sizeof(buf));
   if (out.code==buf.code)
    printf("\n Расстояние %ld через вершину %d",out.dist,out.prec);
  }

/* Завершение работы */

  buf.code=EXIT;
  send(xid,&amp;buf,&amp;out,sizeof(buf));
 } else error("\n СПРАВОЧНИК КРАТЧАЙШИХ РАССТОЯНИЙ ПАССИВЕН");
 printf("\n Конец работы !\n\n");
}

</P></div></PRE>Пусть intery - имя файла загрузочного модуля прикладной задачи 
формирования запросов (результата компиляции и компоновки исходного текста из 
файла intery.c). Взаимодействие с задачей - администратором interx реализуется 
лишь после указания при запуске программы intery в командной строке вида 
<P><pre><div class="code">intery tskname </div></pre>
<P>идентификационного имени tskname, использованного при запуске задачи interx. 
<P>
<P>
<P>

<div class="header"><A name=REF_12_7></A>12.7. Защита файлов от копирования 
</div>
<P>Ниже приведен пример программы защиты от несанкционированного копирования 
файлов в файловой системе FAT. Метод организации защиты - запись и контроль 
ключевой информации в неиспользуемую область последнего кластера выделенных 
файлов [2]. 
<P><PRE><div class="code">// Модуль тестирования привязки

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#include &lt;io.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;direct.h&gt;
#include &lt;dos.h&gt;
#include &lt;alloc.h&gt;
#include &lt;conio.h&gt;
#pragma warn -par

void far handler(unsigned deverr,
                 unsigned errval, unsigned far *devhdr) {
 _hardretn(5);  /* Code 5: DOS "access denied" error */
}

enum exit_code {
 ok=0,
 f_call,   // Ошибка обращения
 f_open,   // Контролируемый файл не найден
 f_search, // Неудача поиска в DTF
 f_core,   // Нехватка памяти
 r_disk,   // Ошибка чтения сектора
 f_random, // Пароль неверен
 w_disk,   // Ошибка записи сектора
 f_time    // Таймаут контроля
};

struct dtfitm { // Элемент таблицы DTF
 char s1[17];
 unsigned long l;
 char s2[11];
 char x[11]; // Имя файла
 char s3[10];
 unsigned int r; // Номер последнего прочитанного кластера
 char s4[4];
};
struct dtflst {
 unsigned int o,s,n;
 struct dtfitm e[1];
};

void isname(char *t, char *x) {
 char *y;
 for (int i=0; i&lt;11; t[i++]=' ');
 if ((y=strrchr(x,'.'))!=0)
  for (y++, i=0; (i&lt;3)&amp;&amp;y[i]; i++) t[i+8]=toupper(y[i]);
 if (((y=strrchr(x,'\\'))!=0)||
      ((y=strrchr(x,':'))!=0)||((y=x-1)!=0))
  for (y++, i=0; (i&lt;8)&amp;&amp;y[i]&amp;&amp;(y[i]!='.'); i++)
   t[i]=toupper(y[i]);
}

struct dtfitm far *search(char *t) {
 unsigned int ps,po;
 _AX=0x5200;
 geninterrupt(0x21);
 ps=_ES, po=_BX;
 struct dtfhdr {
  unsigned int tx,ty,to,ts;
 } far *tp=(struct dtfhdr far *)MK_FP(ps,po);
 struct dtflst far *ft=(struct dtflst far *)MK_FP(tp-&gt;ts,tp-&gt;to);
 while (1) {
  for (int i=0; (i&lt;ft-&gt;n); i++) {
   for (int j=0; j&lt;11; j++)
    if (ft-&gt;e[i].x[j]!=t[j]) break;
   if (j==11) return &amp;(ft-&gt;e[i]);
  }
  if (ft-&gt;o==0xffff) break;
  ft=(struct dtflst far *)MK_FP(ft-&gt;s,ft-&gt;o);
 }
 return 0;
}

int diskon(char *x) {
 return (x[1]==':')? toupper(x[0])-'A':getdisk();
}

#define INTR 0x1C

#ifdef __cplusplus

#define __CPPARGS ...
#else
#define __CPPARGS
#endif

void interrupt (*old1ch)(__CPPARGS);

static int countc=0;

void exiter(int x) {
 setvect(0x1c,old1ch);
 nosound();
 delay(300);
 for (int i=0; i&lt;x; ) {
  sound(++i*100);
  delay(200);
  nosound();
  delay(100);
 }
 exit(x);
}

// Управление звуковыми сигналами

void interrupt new1ch(__CPPARGS) {
 countc++;
 switch (countc%20) {
  case 16: sound(800);
           break;
  case 19: nosound();
           break;
 }
}

// Контроль таймаута

void protec() {
 if (countc&gt;50) exiter(f_time);
}

// Контроль и модификация сигнатуры файла

void main(int na,char **la) {
 old1ch=getvect(0x1c);
 countc=0;
 setvect(0x1c,new1ch);
 if (na&gt;1) {
  _harderr(handler);
  FILE *fp=fopen(la[1],"r+b");
  protec();
  if (fp) {
   char t[11];
   isname(t,la[1]);
   protec();
   struct dtfitm far *fx=search(t);
   if (fx) {
    struct {
     char s1[11];
     unsigned int  sl;     // Размер сектора
     unsigned char ks;     // Число секторов кластера
     unsigned int  rs;     // Число резервируемых секторов
     unsigned char fn;     // Количество FAT
     unsigned int  rn;     // Число записей корневого каталога
     unsigned int  vs;     // Число секторoв на томе
     unsigned char bd;     // Байт описания носителя
     unsigned int  fs;     // Число секторов в FAT
     unsigned int  ts;     // Число секторов на дорожке
     unsigned int  hn;     // Число головок
     char s2[11];
     unsigned long vi;     // Серийный номер тома
     unsigned char vl[11]; // Метка тома
     char s3[458];
    } sector;

    int disk=diskon(la[1]);
    if (absread(disk,1,0,§or))
     exiter(r_disk);
    protec();
    unsigned int clustbyte=sector.sl*sector.ks;
    char *clsbuf=new char[clustbyte];
    if (clsbuf) {
     unsigned int tailsz=fx-&gt;l%clustbyte;
     fseek(fp,long(fx-&gt;l-tailsz),0);
     fread(clsbuf,1,tailsz,fp);
     long clsnum=1l;
     clsnum+=long(sector.fn)*long(sector.fs);
     protec();
     clsnum+=long(sector.rn&gt;&gt;4);
     clsnum+=long(fx-&gt;r-2)*long(sector.ks);
     protec();
     if (absread(disk,sector.ks,clsnum,clsbuf))
      exiter(r_disk);
     srand(clsbuf[tailsz]);
     protec();
     for (int i=tailsz+1; i&lt;clustbyte; i++)
      if (clsbuf[i]!=char(random(256)))
       exiter(f_random);
     protec();
     randomize();
     clsbuf[tailsz]=random(256);
     protec();
     srand(clsbuf[tailsz]);
     for (i=tailsz+1; i&lt;clustbyte; i++) {
      protec();
      clsbuf[i]=random(256);
     }
     protec();
     if (abswrite(disk,sector.ks,clsnum,clsbuf))
      exiter(w_disk);
     delete clsbuf;
    } else exiter(f_core);
   } else exiter(f_search);
  } else exiter(f_open);
  fclose(fp);
 } else exiter(f_call);
 protec();
 exiter(ok);
}

</div></PRE>
<P>

<HR SIZE=1 width="100%">

<A href="#REF_1_C">Начало</A> 
<p> 

<div class="header"><CENTER><A name=REF_13></A>13. ИНТЕРПРЕТАЦИЯ СИСТЕМ ПРОДУКЦИЙ НА ЯЗЫКЕ С </CENTER></div>
<P>
<div class="header"><A name=REF_13_1></A>13.1. Сетевое представление системы 
продукций 
</div>
<P>Под <strong>продукцией</strong> понимают элементарную систему типа "условие-действие". Частный 
случай систем продукций - сети Петри и их расширения [3]. Очевидно, что системы 
продукций характеризуются дискретностью поведения как упорядоченной 
последовательности действий, управляемой соответствующим набором условий. 
Управление здесь подразумевает не обязательно связанные с понятием времени этапы 
анализа состояния сети с целью активизации соответствующих действиям переходов. 
Можно показать, что система продукций эквивалентна расширенной сети Петри с 
задержками в переходах (TPN). 
<P>Переход t системы продукций представим четверкой функций, определяемых на 
множестве переменных состояния системы продукций:</P>
<uL>
  <li>A(t) - проверка условия активизации; 
  <li>B(t) - изменение переменных состояния в момент активизации (входные 
  действия); 
  <li>C(t) - автономный процесс актисного состояния; 
  <li>D(t) - изменение переменных состояния в момент пассивизации (выходные 
  действия). </li></uL>В случае TPN переменные состояния - разметка позиций, 
функции A,B,D связывают разметку позиций с весами дуг сети, а функция C - 
задержка во времени.
<P>Нетрудно заметить, что цель интерпретации системы продукций - построение 
последовательности активизаций переходов. Решение такой задачи может решаться на 
основе схемы интерпретации процессов на TPN. Действительно, если некоторый 
переход t=i стал пассивным, то это особое событие порождает необходимость 
проверки условий активизации переходов j, функции A(j) которых включают 
переменные, измененные функцией D(i). Если условие A(j) истинно, то выполняются 
действия B(j), после чего активизируется переход j и проверяется возможность 
активизации переходов, условия активизации которых определены и на переменных 
функции B(j). 
<P>Таким образом, порождение процесса активизации переходов основано на 
восприимчивости отдельных переходов системы продукций к изменению только 
локальных переменных состояния. Отсюда следует, что на переходах системы 
продукций можно формально построить сеть, связывающую переходы с потенциальной 
возможностью активизации. Например, пусть TPN со стартовым переходом as и 
начальной нулевой разметкой позиций преставлена структурой смежности 
<P><PRE><div class="code">
     as:b1;b2;b6
     a1:b3;b4
     a2:b5
     a3:b2;b1
     a4:b7
     b1:af;a1                                             (13.1)
     b2:af;a1
     b3:a2
     b4:a3
     b5:a3
     b6:a4
     b7:af
</div></PRE>
<P>Сеть интерпретации процессов в этом случае имеет вид: 
<P><PRE><div class="code">     as:a1,a4
     a1:a2,a3
     a2:a3
     a3:af,a1                                            (13.2)
     a4:af
</div></PRE>
<P>Переменные состояния здесь образуют множество 
<P><PRE><div class="code">     X={b1,b2,b3,b4,b5,b6,b7}.                           (13.3)
</div></PRE>
<P>При этом предполагается, что в исходный момент времени начальное состояние 
<P><PRE><div class="code">     X={0,0,0,0,0,0,0},                                  (13.4)
</div></PRE>
<P>a веса дуг TPN являются единичными. Соответствующая система продукций будет 
полностью определена, если записать следующие из определения TPN определения 
функций: 
<P><PRE><div class="code">     A(as)=0;
     A(a1)=b1&amp;&amp;b2;
     A(a2)=b3;
     A(a3)=b4&amp;&amp;b5;
     A(a4)=b6;
     A(af)=b1&amp;&amp;b2&amp;&amp;b7;

     B(as)=0;
     B(a1)=b1--, b2--;
     B(a2)=b3--;                                         (13.5)
     B(a3)=b4--, b5--;
     B(a4)=b6--;
     B(af)=b1--, b2--, b7--;

     C(as)=0;
     C(a1)=d1;
     C(a2)=d2;
     C(a3)=d3;
     C(a4)=d4;
     C(af)=b1--, b2--, b7--;

     D(as)=b1++, b2++, b5++;
     D(a1)=b3++, b4++;
     D(a2)=b5++;
     D(a3)=b1++, b5++;
     D(a4)=b7++;
     D(af)=0;

</div></PRE>
<P>(логические и арифметические операции здесь обозначены симво- лами операции 
языка C/C++). 
<P>
<P>
<P>

<div class="header"><A name=REF_13_2></A>13.2. Входное описание систем 
продукций 
</div>
<P>Для решения практических задач описание системы продукций конкретизируется в 
реальной вычислительной среде. Например, в системе моделирования дискретных 
процессов в реальном времени СМДП-РВ TPN (7.1-7.5) может быть закодирована в 
выде: <PRE><div class="code">// РАЗДЕЛ СТАТИЧЕСКОГО ОПИСАНИЯ МОДЕЛИ
PLACES
<P>
// Позиции тестовой TPN
   int b1,b2,b3,b4,b5,b6,b7;
<P>
// РАЗДЕЛ ДИНАМИЧЕСКОГО ОПИСАНИЯ МОДЕЛИРУЕМЫХ ПРОЦЕССОВ */
<P>
TRANSITION
<P>
as: {0},
    { printf("\nМОДЕЛИРОВАНИЕ ПРОЦЕССОВ НА TPN");
      b1=b2=b3=b4=b5=b6=b7=0;
      count=0;
    },,{b1++,b2++,b6++;};
<P>
af: { b1 &amp;&amp; b2 &amp;&amp; b7 },
    { b1--, b2--, b7--;
      printf("\n ФИНИШ... "); };
<P>
a1: { b1 &amp;&amp; b2 },
    { b1--, b2--; },
    { d1 },
    { b3++, b4++; };
<P>
a2: { b3 },
    { b3--; },
    { d2 },
    { b5++; };
<P>
a3: { b4 &amp;&amp; b5 },
    { b4--, b5--; },
    { d3 },
    { b1++, b2++;
      printf("\n Время %ld, cчетчик %d, ",Event_Time,++count);
    };
<P>
a4: { b6 },
    { b6--; },
    { d4 },
    { b7++; };

SOURCE
<P>
#include &lt;stdio.h&gt;
long d1=2, d2=3, d3=4, d4=10;
int count;
<P>
</P></div></PRE>После трансляции такого исходного текста система СМДП-РВ подго- товит 
следующий текст программы, пригодный для обработки системой программирования на 
языках C/C++: 
<P><PRE><div class="code">
// ТЕКСТ ДЕТАЛИЗАЦИИ ОПИСАНИЯ МОДЕЛИ
<P>
#include &lt;stdio.h&gt;
long d1=2, d2=3, d3=4, d4=10;
int count;
<P>
// ОПРЕДЕЛЕНИЕ ПЕРЕМЕННЫХ СОСТОЯНИЯ
<P>
int b1, // 0
    b2, // 1
    b3, // 2
    b4, // 3
    b5, // 4
    b6, // 5
    b7; // 6
<P>
// ОПИСАНИЕ ФУНКЦИЙ УСЛОВИЙ АКТИВИЗАЦИИ И ДЕЙСТВИЙ ПЕРЕХОДОВ
<P>
int as_1(void), // 0
    af_1(void), // 1
    a1_1(void), // 2
    a2_1(void), // 3
    a3_1(void), // 4
    a4_1(void); // 5

int (*smdp_1[])(void) = {
 as_1,af_1,a1_1,a2_1,a3_1,a4_1
};

void as_2(void),
     af_2(void),
     a1_2(void),
     a2_2(void),
     a3_2(void),
     a4_2(void);
<P>
void (*smdp_2[])(void) = {
 0,af_2,a1_2,a2_2,a3_2,a4_2
};
<P>
long a1_3(void),
     a2_3(void),
     a3_3(void),
     a4_3(void);
<P>
long (*smdp_3[])(void) = {
 0,0,a1_3,a2_3,a3_3,a4_3
};
<P>
void as_4(void),
     a1_4(void),
     a2_4(void),
     a3_4(void),
     a4_4(void);
<P>
void (*smdp_4[])(void) = {
 as_4,0,a1_4,a2_4,a3_4,a4_4
};
<P>
// ОПРЕДЕЛЕНИЕ ФУНКЦИЙ УСЛОВИЙ АКТИВИЗАЦИИ И ДЕЙСТВИЙ ПЕРЕХОДОВ
<P>
int as_1(void) { return(0); }
<P>
void as_4(void) {
 printf("\nМОДЕЛИРОВАНИЕ ПРОЦЕССОВ НА TPN");
<P>
 b1=b2=b3=b4=b5=b6=b7=0;
 count=0;
 b1++,b2++,b6++;
}
<P>
int af_1(void) {
 return(b1 &amp;&amp; b2 &amp;&amp; b7);
}
<P>
void af_2(void) {
 b1--, b2--, b7--;
 printf("\n ФИНИШ... ");
}
<P>
int a1_1(void) { return(b1 &amp;&amp; b2); }

long a1_3(void) { return(d1); }

void a1_2(void) { b1--, b2--; }

void a1_4(void) { b3++, b4++; }
int a2_1(void) { return(b3); }
long a2_3(void) { return(d2); }
void a2_2(void) { b3--; }
void a2_4(void) { b5++; }
int a3_1(void) { return(b4 &amp;&amp; b5); }
long a3_3(void) { return(d3); }
void a3_2(void) { b4--, b5--; }
void a3_4(void) {
 b1++, b2++;
 printf("\n Время %ld, cчетчик %d, ",EL_time,++count); }

int a4_1(void) { return(b6); }
long a4_3(void) { return(d4); }
void a4_2(void) { b6--; }
void a4_4(void) { b7++; }
<P>
// СХЕМА СВЯЗИ ПЕРЕХОДОВ
<P>
#define N_tran 6
<P>
    int L_tran[] = { // Индексы списка связанных позиций переходов
     0,7,10,14,16,20,22 };
<P>
    int M_tran[] = { // Связи переходов
     0,1,2,3,4,5,6, 0,1,6, 0,1,2,3, 2,4, 3,4,0,1, 5,6
//   as             af     a1       a2   a3       a4
    };
<P>
// СХЕМА СВЯЗИ ПОЗИЦИЙ
<P>
    int L_plac[] = { // Индексы списка связанных переходов позиций
     0,2,4,5,6,7,8,9,9
    };
<P>
    int M_plac[] = { // Связи позиций
     1,2, 1,2, 3, 4, 4, 5, 1
//   b1   b2   b3 b4 b5 b6 b7
    };
<P>
</P></div></PRE>Схема связи переходов и позиций по существу определяют TPN, 
соответствующую сети переходов системы продукций. 
<P>
<P>

<div class="header"><A name=REF_13_3></A>13.3. Интерпретация систем продукций 
</div>
<P>Здесь представлен результат конструирования процедуры интерпретации системы 
продукций посредством построения обрамляющей сети типа TPN на исходном тексте 
описания такой системы. 
<P><PRE><div class="code">
/****************************************************************
  Процедура интерпретации системы продукций в ускоренном времени
 ****************************************************************/
<P>
// Включение описания варианта сети
<P>
#include "test.c"
<P>
// Описание списка событий
<P>
int   EL_next[N_tran]; // Поля ссылок
long  EL_time[N_tran]; // Моменты времени
#define HEAD EL_next[0]  // Указатель списка активных переходов
#define TEMP EL_time[0]  // Момент очередного особого события
<P>
void main(void) {
 int i,j,k,l,m,n,p,q,t;
 long f;
<P>
// Инициализация списка событий
<P>
 HEAD=0; // Стартовый переход имеет нулевой номер
 TEMP=0; // Отсчет времени от нуля
<P>
// Фиксация пассивности переходов
<p>
 for (i=1; i&lt;N_tran; EL_next[i++]=N_tran);
<p>
// Выходные действия стартового перехода
<p>
 if (smdp_2[0]) smdp_2[0](); 
<P>
// Обработка последовательности событий
<P>
 do {
  t=HEAD, HEAD=EL_next[t]; // Выборка очередного перехода
  TEMP=EL_time[t];   // Mомент пассивизации
  if (t) EL_next[t]=N_tran; // Фиксация пассивности перехода t

// Обработка последствий пассивизации перехода t
<p>
  if (smdp_4[t]) smdp_4[t](); // Выходные действия
  for (i=L_tran[t], j=L_tran[t+1]; i&lt;j; i++)
   for (k=M_tran[i], l=L_plac[k], m=L_plac[k+1]; l&lt;m; l++) {
<P>
// Обработка последствий изменения разметки позиции k
<p>
    if (EL_next[n=M_plac[l]]!=N_tran)
     continue; // Отказ от активизации активного перехода
    if (smdp_1[n]()) { // Проверка условий активизации
     if (smdp_2[n]) smdp_2[n](); // Входные действия
<P>
// Планирование момента пассивизации перехода n
<P>
     f=EL_time[n]=TEMP+(smdp_3[n]? smdp_3[n]():0);
     for (p=0, q=HEAD; (q&gt;0)&amp;&amp;(f&gt;=EL_time[q]); p=q, q=EL_next[p]);
     EL_next[n]=q, EL_next[p]=n;
    }
   }
 } while (HEAD&gt;0);
<P>
 printf("\n* Завершение моделирования в момент %ld\n",TEMP);
}
</P></div></PRE>
<P>Результаты работы программы 
<P><PRE><div class="code"><font color = "black">МОДЕЛИРОВАНИЕ ПРОЦЕССОВ НА TPN
 Время 9, cчетчик 1
 Время 18, cчетчик 2
 ФИНИШ...
* Завершение моделирования в момент 18
</font></div></PRE>
<P>Таким образом, полученные результаты полностью соответствуют результатам 
интерпретации представленной рассматриваемой системой продукций TPN. 
<P>
<P>
<P>
<HR SIZE=1 width="100%">

<A href="#REF_1_C">Начало</A> 
<p> 
<div class="header"><CENTER><A name=REF_Z></A>ЗАКЛЮЧЕНИЕ </CENTER></div>
<P>Говоря о программировании на языке С, следует предполагать знание не только 
собственно лингвистических конструкций, но и библиотек функций конкретной 
системы программирования. Язык С появился в годы широкого применения 
многопользовательского режима использования ЭВМ Понятие терминала или консоли 
оператора при программировании в среде повсеместно распространенных в настоящее 
время операционных систем семейства Windows потеряло привлекательность для 
пользователей новых систем. Однако задачи системного программирования с 
непритязательным интерфейсом ввода-вывода, а также критичные по эффективности 
реализации модули программ могут программироваться на языке C.<BR>
<P>Среди других алгоритмических языков программирования процедурного типа 
наиболее отличительным свойством языка С явилась поддержка адресной арифметики. 
Другое важное свойство - мобильность. Последнее позволило достичь успеха в 
создании крупных, развиваемых и долгоживущих программных систем. Логическим 
следствием эволюции языка С в направлении улучшения технологии программирования 
явилось создание языка объектно-ориентированного программирования C++. 
<P>Технология объектно-ориентированного программирования основана на 
конструктивном использовании принципов структуризации, модульности и абстракции. 
Ключевые понятия систем объектно-ориентированного прогаммирования: 
<UL>
  <LI>пакетирование - связывание в единое целое объектов существующих типов и 
  функций доступа к ним с целью определения объектов нового типа; 
  <LI>наследование - использование элементов данных и функций ранее определенных 
  объектов для образования иерархии производных объектов; 
  <LI>полиморфизм - возможность ассоциации некоторого имени с множеством 
  уникальных для каждого уровня иерархии производных объектов понятий. </LI></UL>
<P>Объектно-ориентированное программирование на языке C++ - предмет изучения в 
следующем учебном курсе. Знание языка C и опыт его практического использования - 
непременное условие понимания языка C++, а также концепций построения 
современных систем программирования [5-10]. 
<P>
<HR SIZE=1 width="100%">

<A href="#REF_1_C">Начало</A>
<p>
<div class="header"><CENTER><A name=REFERENCE></A>ЛИТЕРАТУРА </CENTER></div>
<P>
<OL>
  <LI>Болски М.И. Язык программирования Си: Справочник. - М.:Радио и связь, 
  1988. - 96 с. 
  <LI>Бруно Бабэ. Просто и ясно о Borland C++: Пер. с англ. - М.: БИНОМ, 1995. - 
  400 с. 
  <LI>Голуб А.И. C и C++. Правила программирования. - М.:БИНОМ,1996. - 272 с. 
  <LI>Джордейн Р. Справочник программиста персональных компьютеров типа IBM PC, 
  XT и AT. - М.: Финансы и статистика, 1991. - 541 с. 
  <LI>Иванчиков А.А., Ревотюк М.П. Лабораторный практикум по курсу "Системное 
  программирование". - Мн.: БГУИР, 1995. - 194 с. 
  <LI>Касаткин А.И., Вальвачев А.Н. Профессиональное программирование на языке 
  Си: От Turbo-C к Borland C++: Справ. пособие. - Мн.: Выш. шк., 1992.- 240 с. 
  <LI>Касаткин А.И. Профессиональное программирование на языке Си: Управление 
  ресурсами: Справ. пособие. - Мн.: Выш. шк.,1992. - 432 с. 
  <LI>Касаткин А.И. Профессиональное программирование на языке Си: Системное 
  программирование. - Мн.: Выш. шк., 1993.- 300 с. 
  <LI>Керниган Б., Ритчи Д., Фьюэр А. Язык программирования Си.- М.: Финансы и 
  статистика, 1992. - 271 с. 
  <LI>Лазаревич Э.Г., Хорошавина Г.Ф. Аппаратурные и программные средства 
  профессиональных персональных ЭВМ: Справ. пособие. - Мн.: Выш. шк., 1991. - 
  270 с. 
  <LI>Лю Ю-Чжен, Гибсон Г. Микропроцессоры семейства 8086/8088. Архитектура, 
  программирование и проектирование микрокомпьютерных систем. - М.: Радио и 
  связь, 1987. - 512 с. 
  <LI>Михальчук В.М., Ровдо А.А., Рыжиков С.В. Микропроцессоры 80x86, Pentium. 
  Архитектура, функционирование, программирование,оптимизация кода. - Мн.: 
  Битрикс, 1994. - 400 с. 
  <LI>Ревотюк М.П. Системное программирование. Ч.1.Язык системного программирования С. Конспект лекций.- Мн.: БГУИР, 1999.- 96 c. 
  <LI>Ревотюк М.П. Системное программирование. Ч.2. Применение языка программирования С. Конспект лекций.- Мн.: БГУИР, 2000. - 100 с.  
  <LI>Ревотюк М.П. Объектно-ориентированное программирование на языке С++. Ч.1. 
  Переход от языка С к языку С++. Учеб. пособие. - Мн.: БГУИР, 1993. - 162 с. 
  <LI>Ревотюк М.П. Объектно-ориентированное программирование на языке С++. Ч.2. 
  Технология объектно-ориентированного программирования. Учеб. пособие. - Мн.: 
  БГУИР, 1997. - 96с. 
  <LI>Рихтер Д. Windows для профессионалов. Программирование в Win32API для 
  Windows NT и Windows 95. - М.: Изд. отдел "Русская редакция" ТОО "ChannelTrading Ltd.", 1995. - 720 с. 
  <LI>Скляров В.А. Программное и лингвистическое обеспечение персональных ЭВМ: 
  Системы общего назначения: Справ. пособие. - Мн.: Выш. шк., 1992. - 462 с. 
  <LI>Скляров В.А. Программное и лингвистическое обеспечение персональных ЭВМ: 
  Новые системы: Справ. пособие. - Мн.:Выш. шк., 1992. - 334 с. 
  <LI>Скляров В.А. Язык С++ и объектно-ориентированное программирование. - Мн.: 
  Выш. шк., 1997. - 478 с. 
  <LI>Скэнлон Л. Персональные ЭВМ IBM PC и XT. Программирование на языке 
  ассемблера. - М.: Радио и связь, 1989. - 336 с. 
  <LI>Уэйт М., Прата С., Мартин Д. Язык Си. Руководство для начинающих. - М.: 
  Мир, 1988. - 512 с. 
  <LI>Эллис М., Строуструп Б. Справочное руководство по языку рограммирования 
  С++ с комментариями: Пер с англ. - М.: Мир, 1992. - 445 с. 
  <LI>Юлин В.А., Булатова И.Р. Приглашение к Си. - Мн.: Выш. шк., 1990. - 224 с. 
  </LI></OL><BR>
<P>
<P>
<HR SIZE=1 width="100%">
<A href="#REF_1_C">Начало</A> 
</DD>

</p>
</body>
</p>
</html>